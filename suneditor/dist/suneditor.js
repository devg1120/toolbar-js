const _e = {
  // rtl icon
  rtl: {
    italic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.5 15.8" xml:space="preserve"><g><path d="M0.3,0.1c0.3,0,0.5,0,0.7,0c1,0.1,1.7,0.1,2.2,0.1H4L7.2,0l0.2,1.1H7c-0.5,0-1,0.1-1.5,0.3v0.4l0.3,1.9L6,4.4L6.3,6 l0.1,0.4l0.1,0.5c0.1,0.2,0.1,0.4,0.2,0.7s0.1,0.6,0.2,0.9L7,9.1l0.6,2.8l0.3,1.4c0.1,0.4,0.2,0.7,0.4,1c0.4,0.2,0.8,0.3,1.2,0.4 l0.8,0.2l0.2,0.9l-1.1,0c-0.9-0.1-1.5-0.1-1.8-0.1h-2c-0.9,0.1-1.4,0.2-1.5,0.2c-0.1,0-0.2,0-0.3,0H3.4c-0.1,0-0.2,0-0.2,0 l-0.1-0.4c0-0.2-0.1-0.4-0.1-0.6l0.7-0.1c0.4,0,0.8-0.1,1.2-0.2c0-0.1,0-0.2,0-0.3l-0.1-0.5l-0.4-2.4L4,9.6L3.4,6.4 C3.2,5.7,3,4.7,2.7,3.3c0-0.3-0.1-0.5-0.1-0.8C2.5,2.1,2.4,1.9,2.3,1.6C2,1.4,1.6,1.3,1.3,1.2C0.9,1.2,0.5,1.1,0.2,0.9L0,0.4L0,0 L0.3,0.1L0.3,0.1z"/></g></svg>',
    indent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><g><path d="M15.5,10.1L15.5,10.1c0.1,0,0.3,0.1,0.3,0.3v1.7c0,0.1,0,0.1-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1l-15.2,0 c-0.1,0-0.1,0-0.2-0.1C0,12.2,0,12.2,0,12.1l0-1.7c0-0.1,0-0.1,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C0.3,10.1,15.5,10.1,15.5,10.1z M9.8,6.7c0.1,0,0.1,0,0.2,0.1C10.1,6.9,10.1,7,10.1,7v1.7c0,0.1,0,0.2-0.1,0.2C10,9,9.9,9,9.8,9L0.3,9C0.2,9,0.1,9,0.1,8.9 C0,8.9,0,8.8,0,8.7V7C0,7,0,6.9,0.1,6.8c0.1-0.1,0.1-0.1,0.2-0.1C0.3,6.7,9.8,6.7,9.8,6.7z M0.3,3.4h9.6h0c0.1,0,0.3,0.1,0.3,0.3 v1.7v0c0,0.1-0.1,0.3-0.3,0.3H0.3c-0.1,0-0.1,0-0.2-0.1C0,5.5,0,5.4,0,5.3V3.6c0-0.1,0-0.1,0.1-0.2C0.1,3.4,0.2,3.4,0.3,3.4 L0.3,3.4z M0.3,0l15.2,0c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2V2c0,0.1,0,0.2-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1H0.3 c-0.1,0-0.1,0-0.2-0.1C0,2.1,0,2,0,2l0-1.7c0-0.1,0-0.1,0.1-0.2C0.1,0,0.2,0,0.3,0z"/></g><path d="M13.1,3.5L15.7,6c0.1,0.1,0.1,0.3,0,0.4l-2.5,2.5C13.1,9,13,9,12.9,9c-0.1,0-0.1,0-0.2-0.1c-0.1-0.1-0.1-0.1-0.1-0.2V3.7 c0-0.1,0-0.2,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C13,3.4,13.1,3.4,13.1,3.5z"/></g></svg>',
    outdent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><g><path d="M15.5,10.1L15.5,10.1c0.1,0,0.3,0.1,0.3,0.3v1.7c0,0.1,0,0.1-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1l-15.2,0 c-0.1,0-0.1,0-0.2-0.1C0,12.2,0,12.2,0,12.1l0-1.7c0-0.1,0-0.1,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C0.3,10.1,15.5,10.1,15.5,10.1z M9.8,6.7c0.1,0,0.1,0,0.2,0.1C10.1,6.9,10.1,7,10.1,7v1.7c0,0.1,0,0.2-0.1,0.2C10,9,9.9,9,9.8,9L0.3,9C0.2,9,0.1,9,0.1,8.9 C0,8.9,0,8.8,0,8.7V7C0,7,0,6.9,0.1,6.8c0.1-0.1,0.1-0.1,0.2-0.1C0.3,6.7,9.8,6.7,9.8,6.7z M0.3,3.4h9.6h0c0.1,0,0.3,0.1,0.3,0.3 v1.7v0c0,0.1-0.1,0.3-0.3,0.3H0.3c-0.1,0-0.1,0-0.2-0.1C0,5.5,0,5.4,0,5.3V3.6c0-0.1,0-0.1,0.1-0.2C0.1,3.4,0.2,3.4,0.3,3.4 L0.3,3.4z M0.3,0l15.2,0c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2V2c0,0.1,0,0.2-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1H0.3 c-0.1,0-0.1,0-0.2-0.1C0,2.1,0,2,0,2l0-1.7c0-0.1,0-0.1,0.1-0.2C0.1,0,0.2,0,0.3,0z"/></g><path d="M15.5,3.4c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2v5.1c0,0.1,0,0.1-0.1,0.2C15.6,9,15.5,9,15.5,9 c-0.1,0-0.1,0-0.2-0.1l-2.5-2.5c-0.1-0.1-0.1-0.3,0-0.4l2.5-2.5C15.3,3.4,15.4,3.4,15.5,3.4z"/></g></svg>',
    list_bullets: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><path d="M12.4,10.7c0,0.9,0.8,1.7,1.7,1.7c0.9,0,1.7-0.8,1.7-1.7C15.7,9.8,15,9,14.1,9c-0.4,0-0.9,0.2-1.2,0.5 C12.5,9.8,12.4,10.2,12.4,10.7C12.4,10.7,12.4,10.7,12.4,10.7z M12.4,6.2c0,0.9,0.8,1.7,1.7,1.7c0.4,0,0.9-0.2,1.2-0.5 c0.3-0.3,0.4-0.7,0.4-1.1c0-0.9-0.7-1.7-1.6-1.7C13.1,4.6,12.4,5.3,12.4,6.2C12.4,6.2,12.4,6.2,12.4,6.2z M0,9.8v1.7 c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1l10.7,0c0,0,0,0,0,0c0.1,0,0.3-0.1,0.3-0.3V9.8c0-0.1,0-0.1-0.1-0.2 C11.1,9.6,11,9.6,11,9.6l-10.7,0c-0.1,0-0.1,0-0.2,0.1C0,9.7,0,9.8,0,9.8L0,9.8z M12.9,2.9c0.3,0.3,0.7,0.5,1.2,0.5 c0.4,0,0.9-0.2,1.2-0.5c0.7-0.7,0.7-1.7,0-2.4C14.9,0.2,14.5,0,14.1,0c-0.4,0-0.9,0.2-1.2,0.5c-0.3,0.3-0.5,0.7-0.5,1.2 C12.4,2.1,12.5,2.6,12.9,2.9z M0,5.3V7c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1H11c0.1,0,0.1,0,0.2-0.1 c0.1-0.1,0.1-0.1,0.1-0.2V5.3c0,0,0,0,0,0c0-0.1-0.1-0.3-0.3-0.3H0.3c-0.1,0-0.1,0-0.2,0.1C0,5.2,0,5.3,0,5.3L0,5.3z M0,0.8v1.7 c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1h10.7c0.1,0,0.1,0,0.2-0.1c0,0,0.1-0.1,0.1-0.2V0.8c0-0.1,0-0.1-0.1-0.2 c0-0.1-0.1-0.1-0.2-0.1H0.3c-0.1,0-0.1,0-0.2,0.1C0,0.7,0,0.8,0,0.8L0,0.8z"/></g></svg>',
    list_number: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M0,11.5l0,1.7c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1H11c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2v-1.7 c0-0.1,0-0.1-0.1-0.2c-0.1-0.1-0.1-0.1-0.2-0.1H0.3c-0.1,0-0.2,0-0.2,0.1C0,11.4,0,11.4,0,11.5L0,11.5z M0,8.7c0,0.1,0,0.1,0.1,0.2 C0.1,8.9,0.2,9,0.3,9H11c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2V7c0-0.1,0-0.1-0.1-0.2c-0.1-0.1-0.1-0.1-0.2-0.1l-10.7,0 c-0.1,0-0.2,0-0.2,0.1C0,6.8,0,6.9,0,7C0,7,0,8.7,0,8.7z M0,2.5v1.7c0,0.1,0,0.1,0.1,0.2c0,0,0.1,0.1,0.2,0.1l10.7,0 c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2V2.4c0-0.1,0-0.1-0.1-0.2c-0.1,0-0.1,0-0.2,0H0.3c-0.1,0-0.1,0-0.2,0 C0,2.3,0,2.4,0,2.5L0,2.5z"/></g><path d="M15.6,14.2c0-0.3-0.1-0.6-0.3-0.8c-0.2-0.2-0.4-0.4-0.7-0.4l0.9-1v-0.8h-2.9v1.3h0.9v-0.5h0.9l0,0c-0.1,0.1-0.2,0.2-0.3,0.3 s-0.2,0.3-0.4,0.5l-0.3,0.3l0.2,0.5c0.6,0,0.9,0.1,0.9,0.5c0,0.1-0.1,0.3-0.2,0.4c-0.1,0.1-0.3,0.1-0.4,0.1c-0.3,0-0.7-0.1-0.9-0.3 l-0.5,0.8c0.4,0.4,0.9,0.6,1.5,0.6c0.4,0,0.9-0.1,1.2-0.4C15.5,15.1,15.6,14.7,15.6,14.2z"/><path d="M15.6,8.7h-0.9v0.5h-1.1c0-0.2,0.2-0.4,0.4-0.5c0.2-0.2,0.4-0.3,0.7-0.4c0.3-0.2,0.5-0.3,0.7-0.6c0.2-0.2,0.3-0.5,0.3-0.8 c0-0.4-0.2-0.8-0.5-1c-0.6-0.4-1.4-0.5-2-0.1c-0.3,0.2-0.5,0.4-0.6,0.7L13.3,7c0.1-0.3,0.4-0.5,0.7-0.5c0.1,0,0.3,0,0.3,0.1 c0.1,0.1,0.1,0.2,0.1,0.3c0,0.2-0.1,0.3-0.2,0.4c-0.2,0.1-0.3,0.3-0.5,0.4c-0.2,0.1-0.4,0.3-0.6,0.4c-0.2,0.2-0.4,0.4-0.5,0.6 c-0.1,0.2-0.2,0.5-0.2,0.8c0,0.2,0,0.3,0,0.5h3.2L15.6,8.7L15.6,8.7z"/><path d="M15.6,3.6h-1V0h-0.9l-1.2,1.1l0.6,0.7c0.2-0.1,0.3-0.3,0.4-0.5l0,0v2.2h-0.9v0.9h3L15.6,3.6L15.6,3.6z"/></svg>',
    link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M7.4,9.9l3.1,3.1c0.3,0.3,0.8,0.5,1.3,0.5c0.5,0,0.9-0.2,1.3-0.5c0,0,0,0,0,0c0.7-0.7,0.7-1.9,0-2.6L9.9,7.3 c0-0.1,0-0.2,0-0.3C9.9,7,10,7,10.1,7l2.2-0.2c0.1,0,0.1,0,0.2,0.1l2.1,2.1c0.4,0.4,0.7,0.8,0.9,1.3c0.2,0.5,0.3,1,0.3,1.5 c0,0.5-0.1,1-0.3,1.5c-0.8,2-3.2,3-5.2,2.2c-0.5-0.2-0.9-0.5-1.3-0.9l-2.1-2.1c-0.1,0-0.1-0.1-0.1-0.2L7,10.1C7,10,7,9.9,7.1,9.9 C7.2,9.8,7.3,9.9,7.4,9.9z M1.2,1.1C1.6,0.7,2,0.4,2.5,0.3c1-0.4,2.1-0.4,3.1,0C6,0.4,6.5,0.7,6.8,1.1L9,3.2C9,3.3,9.1,3.3,9,3.4 L8.8,5.6c0,0.1-0.1,0.2-0.2,0.2c-0.1,0.1-0.2,0.1-0.3,0L5.3,2.7C5,2.3,4.5,2.1,4,2.1c-0.5,0-0.9,0.2-1.3,0.5c0,0,0,0,0,0 C2,3.4,2,4.5,2.7,5.2l3.1,3.2c0.1,0.1,0.1,0.2,0,0.3c0,0.1-0.1,0.1-0.2,0.1L3.5,9C3.4,9,3.4,9,3.3,8.9L1.2,6.8c0,0,0,0,0,0 C-0.4,5.2-0.4,2.7,1.2,1.1L1.2,1.1z M14.3,6h-2.6c0,0,0,0,0,0c-0.1,0-0.2-0.1-0.2-0.2c0-0.1,0-0.2,0.1-0.3l2.5-0.7 c0.1,0,0.1,0,0.2,0c0.1,0,0.1,0.1,0.1,0.2l0.1,0.8c0,0.1,0,0.1-0.1,0.2C14.5,6,14.4,6,14.3,6L14.3,6z M10.2,4.1 c0,0.1-0.1,0.2-0.2,0.2l0,0c0,0,0,0,0,0C9.8,4.2,9.7,4.1,9.8,4L9.7,1.4c0-0.1,0-0.1,0.1-0.2c0.1,0,0.1,0,0.2,0h0.8 c0.1,0,0.1,0,0.2,0.1c0,0.1,0,0.1,0,0.2L10.2,4.1L10.2,4.1z M1.5,9.7h1.3h1.3c0.1,0,0.2,0.1,0.2,0.2c0,0.1,0,0.2-0.1,0.3l-2.5,0.6 H1.6c0,0-0.1,0-0.1,0c-0.1,0-0.1-0.1-0.1-0.2L1.2,9.9c0-0.1,0-0.1,0.1-0.2c0-0.1,0.1-0.1,0.2-0.1L1.5,9.7z M5.6,11.6 C5.6,11.6,5.6,11.6,5.6,11.6c0-0.1,0.1-0.2,0.3-0.1c0,0,0,0,0,0c0.1,0,0.2,0.1,0.2,0.2v2.6c0,0.1,0,0.1-0.1,0.2 c0,0-0.1,0.1-0.2,0.1L5,14.5c-0.1,0-0.1,0-0.2-0.1c0-0.1,0-0.1,0-0.2L5.6,11.6L5.6,11.6z"/></g></svg>',
    unlink: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M14.6,14.6c1.6-1.6,1.6-4.1,0-5.7l0,0l-3.1-3.1l-1.2,1.6l2.9,2.9c0.4,0.4,0.6,0.9,0.6,1.5c0,1.1-0.9,2.1-2.1,2.1l0,0 c-0.6,0-1.1-0.2-1.5-0.6l-0.4-0.4l-1.7,1l0.8,0.8C10.4,16.2,13,16.2,14.6,14.6L14.6,14.6L14.6,14.6z M3.6,6C3,5.9,2.6,5.5,2.3,5 S1.9,4,2.1,3.4C2.3,2.9,2.6,2.5,3,2.2C3.5,2,4.1,1.9,4.6,2l3.3,1.4l0.5-2L5.1,0.1C4-0.1,2.9,0,2,0.5C1.1,1.1,0.4,1.9,0.2,3 C-0.1,4,0,5.1,0.6,6C1.1,6.9,1.9,7.6,3,7.8l5.4,2l0.5-2L6.2,6.9L3.6,6z"/></g></svg>'
  },
  // common, ltr icon
  redo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.59 14.18"><g><path d="M11.58,18.48a6.84,6.84,0,1,1,6.85-6.85s0,.26,0,.67a8,8,0,0,1-.22,1.44l.91-.55a.51.51,0,0,1,.36,0,.45.45,0,0,1,.29.22.47.47,0,0,1,.06.36.45.45,0,0,1-.22.29L17.42,15.3l-.12,0h-.25l-.12-.06-.09-.09-.06-.07,0-.06-.87-2.12a.43.43,0,0,1,0-.37.49.49,0,0,1,.27-.26.41.41,0,0,1,.36,0,.53.53,0,0,1,.27.26l.44,1.09a6.51,6.51,0,0,0,.24-1.36,4.58,4.58,0,0,0,0-.64,5.83,5.83,0,0,0-1.73-4.17,5.88,5.88,0,0,0-8.34,0,5.9,5.9,0,0,0,4.17,10.06.51.51,0,0,1,.33.15.48.48,0,0,1,0,.68.53.53,0,0,1-.33.12Z" transform="translate(-4.48 -4.54)"/></g></svg>',
  undo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.59 14.18"><g><path d="M5,14a.43.43,0,0,1-.22-.29.46.46,0,0,1,.06-.36.43.43,0,0,1,.29-.22.56.56,0,0,1,.36,0l.91.55a8.27,8.27,0,0,1-.22-1.45,5.07,5.07,0,0,1,0-.67A6.85,6.85,0,1,1,13,18.47a.44.44,0,0,1-.33-.13.48.48,0,0,1,0-.68.51.51,0,0,1,.33-.15A5.89,5.89,0,0,0,17.15,7.45a5.88,5.88,0,0,0-8.33,0,5.84,5.84,0,0,0-1.73,4.17s0,.25,0,.65a6.49,6.49,0,0,0,.24,1.37l.44-1.09a.57.57,0,0,1,.27-.26.41.41,0,0,1,.36,0,.53.53,0,0,1,.27.26.43.43,0,0,1,0,.37L7.82,15l0,.09-.09.09-.1.07-.06,0H7.28l-.13,0-1.09-.63c-.65-.36-1-.57-1.1-.63Z" transform="translate(-4.49 -4.53)"/></g></svg>',
  bold: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.76 15.75"><g><path d="M6.4,3.76V19.5h6.76a5.55,5.55,0,0,0,2-.32,4.93,4.93,0,0,0,1.52-1,4.27,4.27,0,0,0,1.48-3.34,3.87,3.87,0,0,0-.69-2.37,5.74,5.74,0,0,0-.71-.83,3.44,3.44,0,0,0-1.1-.65,3.6,3.6,0,0,0,1.58-1.36,3.66,3.66,0,0,0,.53-1.93,3.7,3.7,0,0,0-1.21-2.87,4.65,4.65,0,0,0-3.25-1.1H6.4Zm2.46,6.65V5.57h3.52a4.91,4.91,0,0,1,1.36.15,2.3,2.3,0,0,1,.85.45,2.06,2.06,0,0,1,.74,1.71,2.3,2.3,0,0,1-.78,1.92,2.54,2.54,0,0,1-.86.46,4.7,4.7,0,0,1-1.32.15H8.86Zm0,7.27V12.15H12.7a4.56,4.56,0,0,1,1.38.17,3.43,3.43,0,0,1,.95.49,2.29,2.29,0,0,1,.92,2,2.73,2.73,0,0,1-.83,2.1,2.66,2.66,0,0,1-.83.58,3.25,3.25,0,0,1-1.26.2H8.86Z" transform="translate(-6.4 -3.75)"/></g></svg>',
  underline: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9.78 15.74"><g><path d="M14.64,3.76h2.52v7.72a4.51,4.51,0,0,1-.59,2.31,3.76,3.76,0,0,1-1.71,1.53,6.12,6.12,0,0,1-2.64.53,5,5,0,0,1-3.57-1.18,4.17,4.17,0,0,1-1.27-3.24V3.76H9.9v7.3a3,3,0,0,0,.55,2,2.3,2.3,0,0,0,1.83.65,2.26,2.26,0,0,0,1.8-.65,3.09,3.09,0,0,0,.55-2V3.76Zm2.52,13.31V19.5H7.39V17.08h9.77Z" transform="translate(-7.38 -3.76)"/></g></svg>',
  italic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.49 15.76"><g><path d="M17.16,3.79l.37,0-.06.38-.14.52A10,10,0,0,1,16.21,5a9.37,9.37,0,0,0-1,.32,6.68,6.68,0,0,0-.25.89c-.06.31-.11.59-.14.85-.3,1.36-.52,2.41-.68,3.14l-.61,3.18L13.1,15l-.43,2.4-.12.46a.62.62,0,0,0,0,.28c.44.1.85.17,1.23.22l.68.11a4.51,4.51,0,0,1-.08.6l-.09.42a.92.92,0,0,0-.23,0l-.43,0a1.37,1.37,0,0,1-.29,0c-.13,0-.63-.08-1.49-.16l-2,0c-.28,0-.87,0-1.78.12L7,19.5l.17-.88.8-.2A6.61,6.61,0,0,0,9.19,18,2.62,2.62,0,0,0,9.61,17l.28-1.41.58-2.75.12-.66c.05-.3.11-.58.17-.86s.12-.51.17-.69l.12-.48.12-.43.31-1.6.15-.65.31-1.91V5.14a3.86,3.86,0,0,0-1.48-.29l-.38,0,.2-1.06,3.24.14.75,0c.45,0,1.18,0,2.18-.09.23,0,.46,0,.71,0Z" transform="translate(-7.04 -3.76)"/></g></svg>',
  strike: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.9"><g><path d="M12.94,13a4.27,4.27,0,0,1,1.32.58,1.46,1.46,0,0,1,.55,1.2,1.87,1.87,0,0,1-.88,1.64,4.17,4.17,0,0,1-2.35.59,4.44,4.44,0,0,1-2.74-.71,2.72,2.72,0,0,1-1-2.17H5.57a4.56,4.56,0,0,0,1.55,3.7,7,7,0,0,0,4.47,1.23,6,6,0,0,0,4.07-1.3,4.24,4.24,0,0,0,1.52-3.37,4,4,0,0,0-.26-1.4h-4ZM6.37,10.24A3.27,3.27,0,0,1,6,8.68a4,4,0,0,1,1.48-3.3,5.92,5.92,0,0,1,3.88-1.21,5.58,5.58,0,0,1,3.91,1.24,4.36,4.36,0,0,1,1.45,3.17H14.44a2.12,2.12,0,0,0-.91-1.81,4.45,4.45,0,0,0-2.44-.55,3.69,3.69,0,0,0-2,.51A1.64,1.64,0,0,0,8.3,8.22a1.3,1.3,0,0,0,.48,1.11,7,7,0,0,0,2.1.78l.28.06.28.08H6.37Zm13.09.68a.73.73,0,0,1,.49.21.66.66,0,0,1,.2.48.64.64,0,0,1-.2.48.71.71,0,0,1-.49.19H5.1a.67.67,0,0,1-.49-.19.66.66,0,0,1-.2-.48.64.64,0,0,1,.2-.48.73.73,0,0,1,.49-.21H19.46Z" transform="translate(-4.41 -4.17)"/></g></svg>',
  subscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 14.61"><g><path d="M15.38,4.33H12.74L11.19,7c-.28.46-.51.87-.69,1.21L10.07,9h0l-.44-.8c-.22-.4-.45-.81-.71-1.23L7.34,4.33H4.68L8.26,10,4.4,16.08H7.1l1.69-2.83c.38-.63.72-1.22,1-1.78l.25-.46h0l.49.92c.24.45.48.89.74,1.32L13,16.08h2.61L11.84,10l1.77-2.84,1.77-2.85Zm4.77,13.75H17v-.15c0-.4.05-.64.16-.72a4.42,4.42,0,0,1,1.16-.31,3.3,3.3,0,0,0,1.54-.56A1.84,1.84,0,0,0,20.15,15a1.78,1.78,0,0,0-.44-1.41A2.8,2.8,0,0,0,18,13.25a2.71,2.71,0,0,0-1.69.37,1.83,1.83,0,0,0-.44,1.43v.23H17v-.23q0-.63.18-.78a1.62,1.62,0,0,1,.88-.15,1.59,1.59,0,0,1,.88.15q.18.15.18.75t-.18.75a3.58,3.58,0,0,1-1.18.33,3.33,3.33,0,0,0-1.52.51,1.57,1.57,0,0,0-.32,1.18v1.15h4.27v-.86Z" transform="translate(-4.4 -4.33)"/></g></svg>',
  superscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.42"><g><path d="M12,13.14l3.61-5.81H12.94L11.33,10c-.28.46-.51.88-.69,1.25l-.45.83h0l-.45-.85c-.22-.41-.45-.82-.71-1.24L7.4,7.33H4.68l3.66,5.81L4.4,19.33H7.14l1.74-2.87q.58-1,1-1.83l.25-.48h0l.51.94.75,1.37,1.72,2.87h2.67l-1.92-3.09c-1.12-1.8-1.76-2.83-1.92-3.1Zm4.84-4.41h0l0,.15h3.27v.86H15.77V8.58a1.66,1.66,0,0,1,.33-1.22,3.51,3.51,0,0,1,1.56-.51,3.68,3.68,0,0,0,1.21-.34c.13-.1.19-.36.19-.77S19,5.07,18.87,5A1.63,1.63,0,0,0,18,4.8a1.58,1.58,0,0,0-.91.17c-.13.11-.19.38-.19.8V6H15.78V5.76a1.87,1.87,0,0,1,.45-1.47A2.84,2.84,0,0,1,18,3.91a2.8,2.8,0,0,1,1.72.38,1.84,1.84,0,0,1,.45,1.44,1.91,1.91,0,0,1-.34,1.35,3.24,3.24,0,0,1-1.58.57A3.69,3.69,0,0,0,17,8c-.12.1-.17.35-.17.76Z" transform="translate(-4.4 -3.91)"/></g></svg>',
  erase: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.76"><g><path d="M13.69,17.2h6.46v1.31H8.56L4.41,14.37,14,4.75l6.06,6.06L16.89,14l-3.2,3.19Zm-4.61,0h2.77L14.09,15,9.88,10.75,6.25,14.38l1.41,1.41c.84.82,1.31,1.29,1.42,1.41Z" transform="translate(-4.41 -4.75)"/></g></svg>',
  indent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.36"><g><path d="M4.68,14.45a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V9.1a.27.27,0,0,1,.08-.19.28.28,0,0,1,.2-.08.25.25,0,0,1,.19.07l2.54,2.54a.29.29,0,0,1,0,.4L4.88,14.36a.24.24,0,0,1-.2.09Zm15.19,1.12a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.25.25,0,0,1-.08-.19V15.84a.27.27,0,0,1,.27-.27H19.87Zm0-3.38a.27.27,0,0,1,.19.08.28.28,0,0,1,.08.21v1.68a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V12.48a.32.32,0,0,1,.08-.21.24.24,0,0,1,.19-.08h9.56Zm0-3.37a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.27-.27V9.1a.27.27,0,0,1,.27-.27h9.56Zm.2-3.29a.28.28,0,0,1,.08.2V7.41a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V5.73a.32.32,0,0,1,.08-.21.25.25,0,0,1,.19-.08H19.87a.28.28,0,0,1,.2.09Z" transform="translate(-4.41 -5.44)"/></g></svg>',
  outdent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.36"><g><path d="M19.87,15.57a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.25.25,0,0,1-.08-.19V15.84a.27.27,0,0,1,.27-.27H19.87ZM7.5,14.45a.25.25,0,0,1-.2-.09L4.76,11.84a.29.29,0,0,1,0-.4L7.3,8.9a.29.29,0,0,1,.4,0,.31.31,0,0,1,.07.2v5.06a.32.32,0,0,1-.08.21.26.26,0,0,1-.19.08ZM19.87,8.82a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.27-.27V9.1a.27.27,0,0,1,.27-.27h9.56Zm0,3.37a.27.27,0,0,1,.19.08.28.28,0,0,1,.08.21v1.68a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V12.48a.32.32,0,0,1,.08-.21.24.24,0,0,1,.19-.08h9.56Zm.2-6.66a.28.28,0,0,1,.08.2V7.41a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V5.73a.32.32,0,0,1,.08-.21.25.25,0,0,1,.19-.08H19.87a.28.28,0,0,1,.2.09Z" transform="translate(-4.41 -5.44)"/></g></svg>',
  expansion: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M11.8,13.06l-5.1,5.1H9.51V19.5H4.41V14.4H5.75v2.81L8.3,14.66q2.25-2.23,2.55-2.55Zm8.35-9.3v5.1H18.81V6.05l-5.1,5.1-1-1,5.1-5.1H15.05V3.76Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  reduction: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M14.91,10h2.87v1.38H12.55V6.12h1.38V9l5.24-5.24.48.49.49.48ZM6.77,11.92H12v5.23H10.62V14.26L5.37,19.5l-1-1L9.63,13.3H6.77Z" transform="translate(-4.4 -3.76)"/></g></svg>',
  code_view: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 11.8"><g><path d="M8.09,7.94a.76.76,0,0,1,.53.22.72.72,0,0,1,.21.52.76.76,0,0,1-.22.54L6.18,11.63l2.43,2.44a.69.69,0,0,1,.2.51.66.66,0,0,1-.21.51.75.75,0,0,1-.51.22.63.63,0,0,1-.51-.21h0L4.63,12.15a.7.7,0,0,1-.22-.53.67.67,0,0,1,.25-.55L7.57,8.16a.82.82,0,0,1,.52-.22Zm12.05,3.69a.7.7,0,0,1-.23.52L17,15.1h0a.66.66,0,0,1-.51.21.73.73,0,0,1-.51-.22.75.75,0,0,1-.22-.51.63.63,0,0,1,.21-.51l2.43-2.44L15.92,9.22a.73.73,0,0,1-.22-.53A.74.74,0,0,1,17,8.18h0l2.91,2.91a.67.67,0,0,1,.27.54Zm-5.9-5.9a.73.73,0,0,1,.61.32.71.71,0,0,1,.07.68L11,17a1,1,0,0,1-.22.32.6.6,0,0,1-.35.16.75.75,0,0,1-.69-.26.69.69,0,0,1-.12-.72L13.56,6.23a.75.75,0,0,1,.26-.35.74.74,0,0,1,.42-.15Z" transform="translate(-4.41 -5.73)"/></g></svg>',
  preview: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.65 15.66"><g><path d="M16.19,14.43l2.49,2.49a.73.73,0,0,1,.21.52.67.67,0,0,1-.22.51.7.7,0,0,1-.52.22.69.69,0,0,1-.51-.21l-2.49-2.48a5.17,5.17,0,0,1-1.34.69,4.64,4.64,0,0,1-1.48.24,4.78,4.78,0,1,1,0-9.56,4.79,4.79,0,0,1,1.84.36,4.9,4.9,0,0,1,1.56,1,4.77,4.77,0,0,1,.46,6.18ZM10,14a3.3,3.3,0,0,0,2.34.93A3.37,3.37,0,0,0,14.7,14a3.3,3.3,0,0,0-1.08-5.41,3.47,3.47,0,0,0-2.56,0A3,3,0,0,0,10,9.28,3.31,3.31,0,0,0,10,14ZM16,4a3.86,3.86,0,0,1,2.77,1.14A3.9,3.9,0,0,1,20,7.85v4a.77.77,0,0,1-.22.53.7.7,0,0,1-.52.21.72.72,0,0,1-.74-.74v-4a2.46,2.46,0,0,0-.72-1.73A2.37,2.37,0,0,0,16,5.45H8.53A2.42,2.42,0,0,0,6.08,7.89v7.52a2.41,2.41,0,0,0,.71,1.73,2.46,2.46,0,0,0,1.74.72h4.08a.73.73,0,0,1,0,1.46H8.53a3.85,3.85,0,0,1-2.78-1.14A3.93,3.93,0,0,1,4.6,15.4V7.87A3.94,3.94,0,0,1,5.76,5.09,3.88,3.88,0,0,1,8.54,4H16Z" transform="translate(-4.45 -3.8)"/></g></svg>',
  print: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16.05 16.04"><g><path d="M19.76,15.84a1.29,1.29,0,0,0,.39-.92V8.35A2.05,2.05,0,0,0,19.57,7a1.93,1.93,0,0,0-1.38-.57H6.37a1.95,1.95,0,0,0-2,2v6.56a1.23,1.23,0,0,0,.38.92,1.35,1.35,0,0,0,.93.38h2V14.9l-2,0V8.35a.67.67,0,0,1,.18-.47.62.62,0,0,1,.48-.19H18.18a.6.6,0,0,1,.46.19.66.66,0,0,1,.18.47V14.9h-2v1.32h2A1.35,1.35,0,0,0,19.76,15.84ZM17.52,7.69V5.06a1.31,1.31,0,0,0-.38-.92,1.34,1.34,0,0,0-.94-.38H8.34A1.3,1.3,0,0,0,7,5.06V7.69H8.34V5.06h7.87V7.69h1.31ZM8.34,12.93h7.87l0,5.26H8.34V12.93Zm7.87,5.26v0Zm.65,1.31a.6.6,0,0,0,.46-.19.72.72,0,0,0,.2-.47V12.29a.74.74,0,0,0-.2-.47.6.6,0,0,0-.46-.19H7.68a.6.6,0,0,0-.46.19.72.72,0,0,0-.2.47v6.55a.74.74,0,0,0,.2.47.6.6,0,0,0,.46.19h9.18ZM16.67,9.28a.7.7,0,0,0-.94,0,.63.63,0,0,0-.18.46.67.67,0,0,0,.18.47.68.68,0,0,0,.94,0,.66.66,0,0,0,.18-.47A.58.58,0,0,0,16.67,9.28Z" transform="translate(-4.25 -3.61)"/></g></svg>',
  template: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.27 15.64"><g><path d="M18.18,19.16a1,1,0,0,0,1-1V5.73a1,1,0,0,0-1-1h-2v1h2V18.19H6.37V5.73h2v-1h-2A.94.94,0,0,0,5.68,5a1,1,0,0,0-.29.7V18.18a.94.94,0,0,0,.29.69,1,1,0,0,0,.69.29H18.18ZM9.82,10.31h4.92a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.49.49,0,0,0-.15-.35.47.47,0,0,0-.35-.15H9.82a.49.49,0,0,0-.35.15.47.47,0,0,0-.15.35.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15Zm5.9,4.92H8.83a.49.49,0,0,0-.35.15.47.47,0,0,0-.15.35.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15h6.89a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.51.51,0,0,0-.5-.5ZM7.36,12.77a.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15h8.85a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.49.49,0,0,0-.15-.35.47.47,0,0,0-.35-.15H7.85a.49.49,0,0,0-.35.15.52.52,0,0,0-.14.35Z" transform="translate(-5.14 -3.77)"/><path d="M14.24,6.71a1,1,0,0,0,1-1,1,1,0,0,0-1-1,1,1,0,0,0-1-1h-2a.94.94,0,0,0-.69.28,1,1,0,0,0-.29.7A.94.94,0,0,0,9.62,5a.91.91,0,0,0-.29.69,1,1,0,0,0,.29.7,1,1,0,0,0,.69.29h3.93Z" transform="translate(-5.14 -3.77)"/></g></svg>',
  line_height: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 13.56"><g><path d="M4.4,4.88V8.26a2,2,0,0,0,.5.39s.1,0,.18-.12a.62.62,0,0,0,.17-.28c.06-.19.13-.44.21-.74s.14-.52.19-.66a.58.58,0,0,1,.21-.3,2.41,2.41,0,0,1,.63-.21,3.83,3.83,0,0,1,.88-.12,9.15,9.15,0,0,1,1.31.06.16.16,0,0,1,.11,0,.26.26,0,0,1,.06.14,4,4,0,0,1,0,.49v2l.05,3.77c0,1.41,0,2.68-.05,3.81a1.79,1.79,0,0,1-.11.49,10.68,10.68,0,0,1-1.4.45,1.12,1.12,0,0,0-.69.43v.31l0,.22.61,0c.85-.08,1.54-.12,2.06-.12a19.76,19.76,0,0,1,2.09.08,15.08,15.08,0,0,0,1.64.08,1.4,1.4,0,0,0,.29,0,1.58,1.58,0,0,0,0-.26l-.05-.43a2.26,2.26,0,0,0-.43-.17l-.77-.22-.15,0a2.55,2.55,0,0,1-.78-.28,2.56,2.56,0,0,1-.11-.75l0-1.29,0-3.15V7.53a10.51,10.51,0,0,1,.06-1.2,3.83,3.83,0,0,1,.6,0l1.88,0a2.18,2.18,0,0,1,.38,0,.45.45,0,0,1,.23.17.9.9,0,0,1,.05.25c0,.16.06.35.1.58a3.33,3.33,0,0,0,.14.55A6.39,6.39,0,0,0,15,9a2.91,2.91,0,0,0,.6-.15,2.77,2.77,0,0,0,0-.46l0-.51,0-2.95-.25,0-.38,0L15,4.94a.71.71,0,0,1-.18.15.45.45,0,0,1-.25.07l-.29,0H8.75l-.15,0H7.45a17,17,0,0,1-1.86,0L5.36,5l-.25-.13ZM19.75,16.14h-.69v-9h.69A.4.4,0,0,0,20.13,7c.06-.11,0-.24-.1-.39L18.92,5.15a.52.52,0,0,0-.86,0L17,6.58c-.12.15-.16.28-.1.39s.18.16.38.16h.69v9h-.69a.4.4,0,0,0-.38.16c-.06.11,0,.24.1.39l1.11,1.43a.52.52,0,0,0,.86,0L20,16.69c.12-.15.16-.28.1-.39a.4.4,0,0,0-.38-.16Z" transform="translate(-4.4 -4.86)"/></g></svg>',
  paragraph_style: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.81 15.74"><g><path d="M18.18,3.76v2h-2V19.5h-2V5.73h-2V19.5h-2V11.63a3.94,3.94,0,0,1,0-7.87h7.87Z" transform="translate(-6.37 -3.76)"/></g></svg>',
  text_style: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.76 15.74"><g><path d="M17.68,6.71a2.22,2.22,0,0,0,1.06-.22.74.74,0,0,0,.42-.7.73.73,0,0,0-.08-.33.67.67,0,0,0-.17-.22,1,1,0,0,0-.31-.15L18.26,5l-.45-.09A15.27,15.27,0,0,0,13.26,5V4.74c0-.66-.63-1-1.92-1-.24,0-.43.15-.59.46a4,4,0,0,0-.36,1.14h0v0a26.45,26.45,0,0,1-3.5.35A2,2,0,0,0,5.77,6a.84.84,0,0,0-.37.79,2.14,2.14,0,0,0,.41,1.29,1.23,1.23,0,0,0,1.05.63,16.62,16.62,0,0,0,3.29-.45l-.34,3.35c-.16,1.61-.29,2.9-.37,3.86s-.12,1.66-.12,2.09l0,.65a5.15,5.15,0,0,0,.05.6,1.28,1.28,0,0,0,.16.54.34.34,0,0,0,.28.18,1.16,1.16,0,0,0,.79-.46,3.66,3.66,0,0,0,.68-1,22.08,22.08,0,0,0,1-4.33q.49-3.1.78-6.15a24.69,24.69,0,0,1,4.62-.84Z" transform="translate(-5.4 -3.76)"/></g></svg>',
  save: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M18.53,19.5l.2-.05A1.78,1.78,0,0,0,20.13,18l0-.09V7.14a2,2,0,0,0-.28-.64A3.18,3.18,0,0,0,19.43,6c-.5-.52-1-1-1.55-1.54A2.59,2.59,0,0,0,17.37,4a1.83,1.83,0,0,0-.61-.25H6l-.21,0a1.78,1.78,0,0,0-1.4,1.49l0,.1V17.87a2.49,2.49,0,0,0,.09.37,1.79,1.79,0,0,0,1.44,1.23l.09,0Zm-6.25-.6H6.92a.61.61,0,0,1-.68-.48.78.78,0,0,1,0-.22V12.3a.62.62,0,0,1,.69-.68H17.64a.62.62,0,0,1,.69.69V18.2a.64.64,0,0,1-.71.69H12.28ZM12,9.81H8.15a.63.63,0,0,1-.72-.71v-4a.64.64,0,0,1,.72-.72h7.66a.64.64,0,0,1,.72.72v4a.65.65,0,0,1-.74.72ZM13.5,5V9.18h1.78V5Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  blockquote: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 475.082 475.081"><g><path d="M164.45,219.27h-63.954c-7.614,0-14.087-2.664-19.417-7.994c-5.327-5.33-7.994-11.801-7.994-19.417v-9.132c0-20.177,7.139-37.401,21.416-51.678c14.276-14.272,31.503-21.411,51.678-21.411h18.271c4.948,0,9.229-1.809,12.847-5.424c3.616-3.617,5.424-7.898,5.424-12.847V54.819c0-4.948-1.809-9.233-5.424-12.85c-3.617-3.612-7.898-5.424-12.847-5.424h-18.271c-19.797,0-38.684,3.858-56.673,11.563c-17.987,7.71-33.545,18.132-46.68,31.267c-13.134,13.129-23.553,28.688-31.262,46.677C3.855,144.039,0,162.931,0,182.726v200.991c0,15.235,5.327,28.171,15.986,38.834c10.66,10.657,23.606,15.985,38.832,15.985h109.639c15.225,0,28.167-5.328,38.828-15.985c10.657-10.663,15.987-23.599,15.987-38.834V274.088c0-15.232-5.33-28.168-15.994-38.832C192.622,224.6,179.675,219.27,164.45,219.27z"/><path d="M459.103,235.256c-10.656-10.656-23.599-15.986-38.828-15.986h-63.953c-7.61,0-14.089-2.664-19.41-7.994c-5.332-5.33-7.994-11.801-7.994-19.417v-9.132c0-20.177,7.139-37.401,21.409-51.678c14.271-14.272,31.497-21.411,51.682-21.411h18.267c4.949,0,9.233-1.809,12.848-5.424c3.613-3.617,5.428-7.898,5.428-12.847V54.819c0-4.948-1.814-9.233-5.428-12.85c-3.614-3.612-7.898-5.424-12.848-5.424h-18.267c-19.808,0-38.691,3.858-56.685,11.563c-17.984,7.71-33.537,18.132-46.672,31.267c-13.135,13.129-23.559,28.688-31.265,46.677c-7.707,17.987-11.567,36.879-11.567,56.674v200.991c0,15.235,5.332,28.171,15.988,38.834c10.657,10.657,23.6,15.985,38.828,15.985h109.633c15.229,0,28.171-5.328,38.827-15.985c10.664-10.663,15.985-23.599,15.985-38.834V274.088C475.082,258.855,469.76,245.92,459.103,235.256z"/></g></svg>',
  arrow_down: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 8.67"><g><path d="M18.79,7.52a.8.8,0,0,1,.56-.23.82.82,0,0,1,.79.79.8.8,0,0,1-.23.56l-7.07,7.07a.79.79,0,0,1-.57.25.77.77,0,0,1-.57-.25h0L4.64,8.65a.8.8,0,0,1-.23-.57.82.82,0,0,1,.79-.79.8.8,0,0,1,.56.23L12.28,14l3.26-3.26,3.25-3.26Z" transform="translate(-4.41 -7.29)"/></g></svg>',
  align_justify: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm0,5.9H20.15v-2H4.41v2Zm0,3.94H20.15v-2H4.41v2Zm0,3.93h7.87v-2H4.41v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
  align_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm11.8,3.94H4.41v2H16.22v-2Zm-11.8,5.9H18.18v-2H4.41v2Zm0,3.93h9.84v-2H4.41v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
  align_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm3.93,5.9H20.15v-2H8.34v2Zm-2,3.94H20.14v-2H6.37v2Zm3.94,3.93h9.84v-2H10.31v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
  align_center: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm2,3.94v2H18.18v-2H6.37Zm-1,5.9H19.16v-2H5.39v2Zm2,3.93H17.2v-2H7.36v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
  font_color: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.61"><g><path d="M18.5,15.57,14.28,4.32h-3.4L6.65,15.57h3l.8-2.26h4.23l.8,2.26h3ZM14,11.07H11.14L12.54,7,13.25,9c.41,1.18.64,1.86.7,2ZM4.41,16.69v2.24H20.15V16.69H4.41Z" transform="translate(-4.41 -4.32)"/></g></svg>',
  highlight_color: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.66 15.74"><g><path d="M12.32,9.31,13.38,13H11.21l.52-1.83q.46-1.61.54-1.83ZM4.44,3.76H20.1V19.5H4.44V3.76ZM14.71,17.32h2.63L13.7,6H10.89L7.26,17.32H9.89l.63-2.24h3.55l.32,1.12c.18.65.29,1,.32,1.12Z" transform="translate(-4.44 -3.76)"/></g></svg>',
  list_bullets: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.37"><g><path d="M7.77,16.12a1.59,1.59,0,0,0-.49-1.18,1.62,1.62,0,0,0-1.19-.49,1.68,1.68,0,1,0,0,3.36,1.67,1.67,0,0,0,1.68-1.69Zm0-4.48A1.67,1.67,0,0,0,6.09,10,1.68,1.68,0,0,0,4.9,12.82a1.62,1.62,0,0,0,1.19.49,1.67,1.67,0,0,0,1.68-1.67Zm12.38,3.64a.27.27,0,0,0-.08-.19.28.28,0,0,0-.2-.09H9.19a.28.28,0,0,0-.2.08.29.29,0,0,0-.08.19V17a.27.27,0,0,0,.28.28H19.87a.27.27,0,0,0,.19-.08.24.24,0,0,0,.08-.2V15.28ZM7.77,7.13a1.63,1.63,0,0,0-.49-1.2,1.61,1.61,0,0,0-1.19-.49,1.61,1.61,0,0,0-1.19.49,1.71,1.71,0,0,0,0,2.4,1.62,1.62,0,0,0,1.19.49,1.61,1.61,0,0,0,1.19-.49,1.63,1.63,0,0,0,.49-1.2Zm12.38,3.66a.28.28,0,0,0-.08-.2.29.29,0,0,0-.19-.08H9.19a.27.27,0,0,0-.28.28v1.69a.27.27,0,0,0,.08.19.24.24,0,0,0,.2.08H19.87a.27.27,0,0,0,.19-.08.25.25,0,0,0,.08-.19V10.79Zm0-4.5a.27.27,0,0,0-.08-.19A.25.25,0,0,0,19.88,6H9.19A.28.28,0,0,0,9,6.1a.26.26,0,0,0-.08.19V8A.27.27,0,0,0,9,8.17a.24.24,0,0,0,.2.08H19.87a.27.27,0,0,0,.19-.08A.25.25,0,0,0,20.14,8V6.29Z" transform="translate(-4.41 -5.44)"/></g></svg>',
  list_number: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.69 15.74"><g><path d="M7.66,18a1.24,1.24,0,0,0-.26-.78,1.17,1.17,0,0,0-.72-.42l.85-1V15H4.58v1.34h.94v-.46l.85,0h0c-.11.11-.22.23-.32.35s-.23.27-.37.47L5.39,17l.23.51c.61-.05.92.11.92.49a.42.42,0,0,1-.18.37.79.79,0,0,1-.45.12A1.41,1.41,0,0,1,5,18.15l-.51.77A2.06,2.06,0,0,0,6,19.5a1.8,1.8,0,0,0,1.2-.41A1.38,1.38,0,0,0,7.66,18Zm0-5.54H6.75V13H5.63A.72.72,0,0,1,6,12.51a5.45,5.45,0,0,1,.66-.45,2.71,2.71,0,0,0,.67-.57,1.19,1.19,0,0,0,.31-.81,1.29,1.29,0,0,0-.45-1,1.86,1.86,0,0,0-2-.11,1.51,1.51,0,0,0-.62.7l.74.52A.87.87,0,0,1,6,10.28a.51.51,0,0,1,.35.12.42.42,0,0,1,.13.33.55.55,0,0,1-.21.4,3,3,0,0,1-.5.38c-.19.13-.39.27-.58.42a2,2,0,0,0-.5.6,1.63,1.63,0,0,0-.21.81,3.89,3.89,0,0,0,.05.48h3.2V12.44Zm12.45,2.82a.27.27,0,0,0-.08-.19.28.28,0,0,0-.21-.08H9.1a.32.32,0,0,0-.21.08.24.24,0,0,0-.08.2V17a.27.27,0,0,0,.08.19.3.3,0,0,0,.21.08H19.83a.32.32,0,0,0,.21-.08.25.25,0,0,0,.08-.19V15.26ZM7.69,7.32h-1V3.76H5.8L4.6,4.88l.63.68a1.85,1.85,0,0,0,.43-.48h0l0,2.24H4.74V8.2h3V7.32Zm12.43,3.42a.27.27,0,0,0-.08-.19.28.28,0,0,0-.21-.08H9.1a.32.32,0,0,0-.21.08.24.24,0,0,0-.08.2v1.71a.27.27,0,0,0,.08.19.3.3,0,0,0,.21.08H19.83a.32.32,0,0,0,.21-.08.25.25,0,0,0,.08-.19V10.74Zm0-4.52A.27.27,0,0,0,20,6,.28.28,0,0,0,19.83,6H9.1A.32.32,0,0,0,8.89,6a.24.24,0,0,0-.08.19V7.93a.27.27,0,0,0,.08.19.32.32,0,0,0,.21.08H19.83A.32.32,0,0,0,20,8.12a.26.26,0,0,0,.08-.2V6.22Z" transform="translate(-4.43 -3.76)"/></g></svg>',
  table: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M4.41,8.05V3.76H8.7V8.05H4.41Zm5.71,0V3.76h4.3V8.05h-4.3Zm5.74-4.29h4.29V8.05H15.86V3.76Zm-11.45,10V9.48H8.7v4.3H4.41Zm5.71,0V9.48h4.3v4.3h-4.3Zm5.74,0V9.48h4.29v4.3H15.86ZM4.41,19.5V15.21H8.7V19.5H4.41Zm5.71,0V15.21h4.3V19.5h-4.3Zm5.74,0V15.21h4.29V19.5H15.86Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  horizontal_rule: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 2.24"><g><path d="M20.15,12.75V10.51H4.41v2.24H20.15Z" transform="translate(-4.41 -10.51)"/></g></svg>',
  show_blocks: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.66 15.67"><g><path d="M19.72,5.58a1.64,1.64,0,0,0-1.64-1.64H6.23a1.62,1.62,0,0,0-1.16.48,1.63,1.63,0,0,0-.48,1.16V9.63a1.6,1.6,0,0,0,.48,1.16,1.62,1.62,0,0,0,1.16.47H18.09a1.67,1.67,0,0,0,1.16-.47,1.62,1.62,0,0,0,.48-1.16V5.58Zm-.94,4.05a.68.68,0,0,1-.7.7H6.23a.66.66,0,0,1-.48-.2.74.74,0,0,1-.21-.5V5.58a.66.66,0,0,1,.2-.48.71.71,0,0,1,.48-.21H18.08a.74.74,0,0,1,.5.21.66.66,0,0,1,.2.48ZM6.48,7.72a.21.21,0,0,0,.17-.07.22.22,0,0,0,.07-.17V7.06a1.27,1.27,0,0,1,.11-.52.37.37,0,0,1,.36-.23H8.77A.25.25,0,0,0,9,6.17a.19.19,0,0,0,0-.23.27.27,0,0,0-.2-.12H7.19a.88.88,0,0,0-.72.39,1.51,1.51,0,0,0-.23.85v.42a.24.24,0,0,0,.24.24Zm-.19.81a.21.21,0,0,0,.17-.07.26.26,0,0,0,.07-.17.24.24,0,0,0-.24-.24.2.2,0,0,0-.16.09.2.2,0,0,0-.07.16.22.22,0,0,0,.07.17.23.23,0,0,0,.16.06Zm8.46,5.1a1.63,1.63,0,0,0-.47-1.16A1.61,1.61,0,0,0,13.12,12H6.23a1.6,1.6,0,0,0-1.16.46,1.62,1.62,0,0,0-.48,1.16v4.05a1.64,1.64,0,0,0,1.64,1.64h6.89a1.6,1.6,0,0,0,1.16-.48,1.62,1.62,0,0,0,.47-1.16Zm-.94,4a.7.7,0,0,1-.2.49.65.65,0,0,1-.5.2H6.23a.66.66,0,0,1-.48-.2.75.75,0,0,1-.21-.49v-4a.74.74,0,0,1,.21-.5.66.66,0,0,1,.48-.2h6.89a.68.68,0,0,1,.7.7v4Zm6.15,0v-4a1.6,1.6,0,0,0-.48-1.16A1.67,1.67,0,0,0,18.32,12H17.1a1.63,1.63,0,0,0-1.16.47,1.61,1.61,0,0,0-.47,1.16v4a1.67,1.67,0,0,0,.47,1.16,1.62,1.62,0,0,0,1.16.48h1.22A1.64,1.64,0,0,0,20,17.68Zm-.94-4v4a.75.75,0,0,1-.21.49.62.62,0,0,1-.48.2H17.11a.69.69,0,0,1-.5-.2.7.7,0,0,1-.2-.49v-4a.68.68,0,0,1,.7-.7h1.22a.66.66,0,0,1,.48.2.72.72,0,0,1,.21.5Z" transform="translate(-4.44 -3.79)"/></g></svg>',
  cancel: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M14.15,11.63l5.61,5.61a1.29,1.29,0,0,1,.38.93,1.27,1.27,0,0,1-.4.93,1.25,1.25,0,0,1-.92.4,1.31,1.31,0,0,1-.94-.4l-5.61-5.61L6.67,19.1a1.31,1.31,0,0,1-.94.4,1.24,1.24,0,0,1-.92-.4,1.27,1.27,0,0,1-.4-.93,1.33,1.33,0,0,1,.38-.93l5.61-5.63L4.79,6a1.26,1.26,0,0,1-.38-.93,1.22,1.22,0,0,1,.4-.92,1.28,1.28,0,0,1,.92-.39,1.38,1.38,0,0,1,.94.38l5.61,5.61,5.61-5.61a1.33,1.33,0,0,1,.94-.38,1.26,1.26,0,0,1,.92.39,1.24,1.24,0,0,1,.4.92,1.29,1.29,0,0,1-.39.93L17,8.81l-2.8,2.82Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  image: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.77"><g><path d="M8.77,8.72a.88.88,0,0,1-.61-.27.82.82,0,0,1-.25-.61.89.89,0,0,1,.25-.62A.82.82,0,0,1,8.77,7a.81.81,0,0,1,.61.25.83.83,0,0,1,.27.62.81.81,0,0,1-.25.61.91.91,0,0,1-.63.27Zm9.62-5a1.74,1.74,0,0,1,1.76,1.76V17.76a1.74,1.74,0,0,1-1.76,1.76H6.16A1.74,1.74,0,0,1,4.4,17.76V5.51A1.74,1.74,0,0,1,6.16,3.75H18.39Zm0,1.75H6.16v8L8.53,11.8a.94.94,0,0,1,.54-.17.86.86,0,0,1,.54.2L11.09,13l3.64-4.55a.78.78,0,0,1,.34-.25.85.85,0,0,1,.42-.07.89.89,0,0,1,.39.12.78.78,0,0,1,.28.29l2.24,3.67V5.51Zm0,12.24V15.6L15.3,10.53,11.89,14.8a.89.89,0,0,1-.59.32.82.82,0,0,1-.64-.18L9,13.62,6.16,15.74v2Z" transform="translate(-4.4 -3.75)"/></g></svg>',
  video: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.55"><g><path d="M20.15,10.26V18.9l-3.94-1.57v1.2H4.41V10.66H16.22v1.23l2-.81,2-.82ZM14.64,17h0V12.54h0v-.31H6V17h8.67Zm3.94-.37v-4l-2.37,1v2l1.18.48,1.19.48ZM7.94,9.86A2.77,2.77,0,0,1,5.19,7.11a2.76,2.76,0,0,1,5.51,0A2.78,2.78,0,0,1,7.94,9.86Zm0-3.93a1.21,1.21,0,0,0-.83.35,1.15,1.15,0,0,0-.34.84A1.09,1.09,0,0,0,7.11,8,1.15,1.15,0,0,0,8,8.28,1.13,1.13,0,0,0,9.11,7.12,1.16,1.16,0,0,0,7.94,5.93Zm5.9,3.93a2.34,2.34,0,0,1-1.67-.68,2.3,2.3,0,0,1-.68-1.67,2.35,2.35,0,0,1,4-1.67,2.37,2.37,0,0,1,0,3.34,2.33,2.33,0,0,1-1.68.68Zm0-3.14a.75.75,0,1,0,.55.22.73.73,0,0,0-.55-.22Z" transform="translate(-4.41 -4.35)"/></g></svg>',
  link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.72"><g><path d="M13.05,13.63a.24.24,0,0,1,.15.22L13.42,16a.19.19,0,0,1-.08.18l-2.12,2.14a4.08,4.08,0,0,1-1.29.85A4,4,0,0,1,4.71,17a3.92,3.92,0,0,1-.3-1.52A4,4,0,0,1,4.71,14a3.91,3.91,0,0,1,.87-1.3L7.7,10.56a.25.25,0,0,1,.2-.06l2.17.22a.21.21,0,0,1,.19.15.24.24,0,0,1,0,.25L7.12,14.23a1.81,1.81,0,0,0,0,2.58,1.78,1.78,0,0,0,1.29.52,1.74,1.74,0,0,0,1.28-.52L12.8,13.7a.24.24,0,0,1,.25-.07ZM19,4.92a4,4,0,0,1,0,5.66L16.86,12.7a.25.25,0,0,1-.17.08l-2.2-.23a.21.21,0,0,1-.19-.15.22.22,0,0,1,0-.25L17.44,9a1.81,1.81,0,0,0,0-2.58,1.78,1.78,0,0,0-1.29-.52,1.74,1.74,0,0,0-1.28.52L11.76,9.57a.21.21,0,0,1-.25,0,.24.24,0,0,1-.16-.21l-.22-2.17a.19.19,0,0,1,.08-.18l2.12-2.14a4.08,4.08,0,0,1,1.29-.85,4.05,4.05,0,0,1,3.06,0,3.85,3.85,0,0,1,1.3.85ZM5.84,9.82a.25.25,0,0,1-.18-.08.19.19,0,0,1-.07-.19l.11-.77a.2.2,0,0,1,.11-.17.24.24,0,0,1,.2,0l2.5.72a.25.25,0,0,1,.15.27.22.22,0,0,1-.23.21l-2.59,0Zm4.12-2-.73-2.5a.27.27,0,0,1,0-.2A.21.21,0,0,1,9.41,5L10.19,5a.25.25,0,0,1,.19,0,.23.23,0,0,1,.08.18l-.05,2.61a.2.2,0,0,1-.19.23h0A.22.22,0,0,1,10,7.85Zm8.76,5.58a.25.25,0,0,1,.18.08.23.23,0,0,1,.06.2l-.11.77a.25.25,0,0,1-.11.17.21.21,0,0,1-.12,0l-.08,0L16,14a.25.25,0,0,1-.15-.27.22.22,0,0,1,.22-.21l1.29,0,1.33,0Zm-4.12,2,.74,2.51a.28.28,0,0,1,0,.2.23.23,0,0,1-.18.11l-.8.11a.23.23,0,0,1-.17-.07.25.25,0,0,1-.08-.18l0-2.61a.22.22,0,0,1,.22-.22.21.21,0,0,1,.26.15Z" transform="translate(-4.41 -3.77)"/></g></svg>',
  math: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.81 15.73"><g><path d="M17.19,5.73a1,1,0,0,0,.71-.29,1,1,0,0,0,.28-.7,1,1,0,0,0-1-1H7.35a1,1,0,0,0-1,1,.77.77,0,0,0,.13.47h0l4.58,6.43L6.68,17.81a1.25,1.25,0,0,0-.29.71.94.94,0,0,0,.28.7.92.92,0,0,0,.69.28H17.2a1,1,0,0,0,.71-.28,1,1,0,0,0,0-1.39.92.92,0,0,0-.71-.29H9.26l3.87-5.43a.86.86,0,0,0,0-.95L9.26,5.73h7.93Z" transform="translate(-6.38 -3.77)"/></g></svg>',
  unlink: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.72"><g><path d="M19,18.32a4,4,0,0,0,0-5.68L15.85,9.5l-1.17,1.55L17.57,14a2,2,0,0,1,.61,1.47,2.08,2.08,0,0,1-2.09,2.09,2,2,0,0,1-1.47-.61l-.38-.37-1.74,1,.8.78a4,4,0,0,0,5.68,0ZM8,9.77a2,2,0,0,1-1.27-1,1.89,1.89,0,0,1-.21-1.57A2.1,2.1,0,0,1,7.45,6,2,2,0,0,1,9,5.76L12.27,7.2l.49-2L9.48,3.9a4,4,0,0,0-3.06.41A3.82,3.82,0,0,0,4.56,6.73a3.8,3.8,0,0,0,.4,3A3.78,3.78,0,0,0,7.39,11.6l5.38,2,.49-2-2.64-.94L8,9.77Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  table_header: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.74"><g><path d="M17,19.5v-.78H15.5v.78H17Zm-3,0v-.78H12.5v.78H14Zm-3,0v-.78H9.53v.78H11Zm-3,0v-.78H6.53v.78H8Zm10.55,0a1.73,1.73,0,0,0,.85-.35,1.67,1.67,0,0,0,.56-.76l-.71-.31a1.21,1.21,0,0,1-.35.4,1.34,1.34,0,0,1-.53.23l.08.38c.06.24.09.38.1.41Zm-13.7-.63.55-.55A.77.77,0,0,1,5.25,18a1.31,1.31,0,0,1-.06-.38v-.38H4.41v.38a2,2,0,0,0,.12.68,1.6,1.6,0,0,0,.35.57Zm15.27-2.12V15.26h-.78v1.49h.78Zm-15-1V14.23H4.41v1.49h.78Zm15-2V12.26h-.78v1.49h.78Zm-15-1V11.22H4.41v1.51h.78Zm15-2V9.26h-.78v1.51h.78Zm-15-1V8.17H4.41V9.74h.78Zm15-2V6.28h-.78V7.77h.78Zm-15-1.11V5.33L4.48,5.1a.77.77,0,0,0-.07.27,2.72,2.72,0,0,0,0,.28v1h.79ZM19.21,5l.63-.4A1.62,1.62,0,0,0,19.16,4a1.94,1.94,0,0,0-.91-.22v.78a1.31,1.31,0,0,1,.56.12.88.88,0,0,1,.4.36ZM6,4.54H7.78V3.76H6a.82.82,0,0,0-.28.06l.12.35c.07.21.1.33.11.36Zm10.8,0V3.76H15.28v.78h1.49Zm-3,0V3.76H12.28v.78h1.49Zm-3,0V3.76H9.28v.78h1.51ZM6,10.84h12.6V6.91H6Z" transform="translate(-4.4 -3.76)"/></g></svg>',
  merge_cell: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 15.74"><g><path d="M18.92,13.5h1.23v4.15A1.84,1.84,0,0,1,18.3,19.5H14V18.27H18.3a.6.6,0,0,0,.44-.18.59.59,0,0,0,.18-.44V13.5ZM18.3,3.76a1.84,1.84,0,0,1,1.85,1.85V9.82H18.92V5.6a.6.6,0,0,0-.18-.44A.59.59,0,0,0,18.3,5H14V3.76H18.3Zm1.85,8.51H15.6L17.26,14l-.86.86-3.14-3.17L16.4,8.51l.86.86L15.62,11h4.54v1.24Zm-13.9,6h4.27V19.5H6.25A1.84,1.84,0,0,1,4.4,17.65V13.5H5.63v4.15a.61.61,0,0,0,.62.62Zm0-14.51h4.27V5H6.25a.6.6,0,0,0-.44.18.57.57,0,0,0-.17.43V9.81H4.41V5.6A1.83,1.83,0,0,1,6.25,3.76Zm5,7.9L8.15,14.83,7.3,14,9,12.27H4.41V11H8.94L7.3,9.38,7.73,9l.43-.43Z" transform="translate(-4.4 -3.76)"/></g></svg>',
  split_cell: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.74"><g><path d="M10.37,12.25H6.74L8.4,13.94l-.87.86L4.41,11.63,7.53,8.5l.87.86L6.74,11h3.62v1.23Zm9.78-.61L17,14.81,16.13,14l1.66-1.69H14.16V11h3.63L16.13,9.37l.43-.43A5.24,5.24,0,0,1,17,8.51ZM18.9,8.22V5.61a.57.57,0,0,0-.18-.43A.65.65,0,0,0,18.29,5H12.88V18.28h5.41a.7.7,0,0,0,.44-.18.57.57,0,0,0,.18-.43V15h1.23v2.64a1.84,1.84,0,0,1-1.85,1.83h-12A1.84,1.84,0,0,1,4.94,19a1.81,1.81,0,0,1-.54-1.29V15H5.63v2.64a.57.57,0,0,0,.18.43.67.67,0,0,0,.44.18h5.41V5H6.25a.7.7,0,0,0-.44.18.56.56,0,0,0-.17.43V8.22H4.41V5.61A1.8,1.8,0,0,1,5,4.31a1.91,1.91,0,0,1,1.31-.55h12a1.89,1.89,0,0,1,1.31.55,1.8,1.8,0,0,1,.54,1.3V8.23H18.9Z" transform="translate(-4.4 -3.76)"/></g></svg>',
  caption: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.79"><g><path d="M4.41,18.52H20.15v-2H4.41ZM20,4.73H18.07V6h.65v.65H20V4.73ZM17,6V4.73H14.55V6H17ZM13.49,6V4.73H11V6h2.47ZM10,6V4.73H7.5V6H10ZM5.79,6h.65V4.73H4.5V6.67H5.8V6ZM4.5,11.34H5.79V8.48H4.5ZM6.44,13.8H5.79v-.65H4.5v1.94H6.44ZM17,15.09V13.8H14.55v1.29H17Zm-3.52,0V13.8H11v1.29h2.47Zm-3.53,0V13.8H7.5v1.29H10ZM20,13.16H18.72v.65h-.65V15.1H20Zm-1.29-1.82H20V8.48h-1.3v2.86Z" transform="translate(-4.41 -4.73)"/></g></svg>',
  edit: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.73"><g><path d="M7.51,5.68h6l1.52-1.57H6.94a2.4,2.4,0,0,0-1.79.82A2.8,2.8,0,0,0,4.41,6.8V17a2.55,2.55,0,0,0,.75,1.8A2.48,2.48,0,0,0,7,19.5H17.22a2.57,2.57,0,0,0,1.83-.74,2.52,2.52,0,0,0,.77-1.8V8.83l-1.58,1.54v6a1.54,1.54,0,0,1-1.53,1.53H7.51A1.54,1.54,0,0,1,6,16.41V7.21A1.52,1.52,0,0,1,7.51,5.68Zm5.63,7.47h0L10.7,10.74l-1,3.38,1.71-.48,1.7-.49Zm.34-.34h0l5.36-5.32L16.4,5.08,11,10.4l1.23,1.21,1.21,1.2ZM19.93,6.4a.82.82,0,0,0,.22-.48A.54.54,0,0,0,20,5.47L18.45,4A.67.67,0,0,0,18,3.77a.7.7,0,0,0-.48.21l-.74.72,2.44,2.43.37-.37.35-.36Z" transform="translate(-4.41 -3.77)"/></g></svg>',
  delete: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 15.74"><g><path d="M19.16,6.71a.94.94,0,0,0,.69-.28.91.91,0,0,0,.29-.68A1,1,0,0,0,19.85,5a.93.93,0,0,0-.69-.3H14.24A.94.94,0,0,0,14,4.06a.92.92,0,0,0-.7-.3h-2a1,1,0,0,0-.7.3.93.93,0,0,0-.28.68H5.39A.92.92,0,0,0,4.7,5a1,1,0,0,0-.29.71.91.91,0,0,0,.29.68,1,1,0,0,0,.69.28H19.16Zm-12.79,1a1,1,0,0,0-.7.3.94.94,0,0,0-.28.69v8.85A1.88,1.88,0,0,0,6,18.93a1.9,1.9,0,0,0,1.39.57H17.2a1.87,1.87,0,0,0,1.39-.58,1.91,1.91,0,0,0,.58-1.39V8.68A1,1,0,0,0,18.88,8a.89.89,0,0,0-.7-.29,1,1,0,0,0-.69.29.92.92,0,0,0-.29.68v7.87a1,1,0,0,1-1,1H8.34a.94.94,0,0,1-.69-.28,1,1,0,0,1-.29-.71V8.68a1,1,0,0,0-1-1Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  modify: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.74"><g><path d="M19.79,15.23a.66.66,0,0,1,.3.38.59.59,0,0,1-.07.48l-.8,1.38a.66.66,0,0,1-.38.3.59.59,0,0,1-.48-.07l-.68-.38a4.55,4.55,0,0,1-1.34.77v.78a.64.64,0,0,1-.18.45.61.61,0,0,1-.45.18h-1.6a.6.6,0,0,1-.44-.18.66.66,0,0,1-.19-.45v-.78a4.36,4.36,0,0,1-1.32-.77l-.69.38a.58.58,0,0,1-.48.07.66.66,0,0,1-.38-.3l-.38-.66h.83a1.77,1.77,0,0,0,1.23-.52,1.72,1.72,0,0,0,.51-1.23v-.18a3,3,0,0,0,.49-.28l.15.09a1.83,1.83,0,0,0,.88.23A1.75,1.75,0,0,0,15.84,14l.88-1.52a1.7,1.7,0,0,0,.17-1.32,1.66,1.66,0,0,0-.3-.61,1.84,1.84,0,0,0-.51-.45l-.15-.09,0-.29,0-.28.15-.09a1,1,0,0,0,.26-.18l0,.06v.78a4.34,4.34,0,0,1,1.34.77l.68-.38a.68.68,0,0,1,.48-.06.64.64,0,0,1,.38.29l.8,1.38a.58.58,0,0,1,.07.48.63.63,0,0,1-.3.38l-.68.4a3.84,3.84,0,0,1,.08.76,4.13,4.13,0,0,1-.08.78l.34.18.32.2ZM10.17,7.86a1.9,1.9,0,0,1,1.35,3.23,1.85,1.85,0,0,1-1.35.55A1.9,1.9,0,0,1,8.83,8.41a1.92,1.92,0,0,1,1.34-.55Zm1.58,7.2a.73.73,0,0,1-.21.49.66.66,0,0,1-.48.2H9.29a.68.68,0,0,1-.69-.69V14.2a4.75,4.75,0,0,1-1.48-.86l-.75.45a.73.73,0,0,1-.7,0,.63.63,0,0,1-.25-.26L4.54,12a.67.67,0,0,1-.08-.53.71.71,0,0,1,.32-.42l.75-.43a4.8,4.8,0,0,1-.08-.85,4.71,4.71,0,0,1,.08-.85l-.74-.44a.71.71,0,0,1-.32-.42.65.65,0,0,1,.07-.54L5.42,6a.66.66,0,0,1,.42-.32l.18,0a.73.73,0,0,1,.35.09l.75.43A4.68,4.68,0,0,1,8.6,5.33V4.45a.68.68,0,0,1,.69-.69h1.77a.64.64,0,0,1,.48.2.73.73,0,0,1,.21.49v.88a4.75,4.75,0,0,1,1.48.85L14,5.75a.67.67,0,0,1,.34-.09l.18,0a.71.71,0,0,1,.42.32l.89,1.54a.67.67,0,0,1,.06.52.73.73,0,0,1-.32.43l-.75.42a4.8,4.8,0,0,1,.08.85,4.71,4.71,0,0,1-.08.85l.75.43a.66.66,0,0,1,.32.42.73.73,0,0,1-.06.54l-.89,1.52a.69.69,0,0,1-.25.26.7.7,0,0,1-.35.09.64.64,0,0,1-.34-.09l-.75-.45a4.87,4.87,0,0,1-1.48.86v.87ZM7.23,9.75a3,3,0,0,0,.86,2.08,2.94,2.94,0,1,0,4.16-4.16,3,3,0,0,0-2.08-.85A2.94,2.94,0,0,0,7.23,9.75Z" transform="translate(-4.44 -3.76)"/></g></svg>',
  revert: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 14.69"><g><path d="M18.26,15V12.3l1.89-2V15a2.58,2.58,0,0,1-.24,1c-.2.58-.75.92-1.65,1H7.56v2L4.41,15.63,7.56,13v2h10.7ZM6.3,8.28V11L4.41,13V8.28a2.58,2.58,0,0,1,.24-1c.2-.58.75-.92,1.65-1H17v-2l3.15,3.34L17,10.3v-2H6.3Z" transform="translate(-4.4 -4.28)"/></g></svg>',
  auto_size: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M6.71,17.19,6.89,16l1.21-.15A6,6,0,0,1,6.81,13.9a5.78,5.78,0,0,1-.45-2.27A6,6,0,0,1,8.1,7.45a5.83,5.83,0,0,1,4.17-1.73l1-1-1-1A7.89,7.89,0,0,0,5,14.64a7.73,7.73,0,0,0,1.71,2.55Zm5.57,2.31h0A7.86,7.86,0,0,0,17.85,6.07L17.67,7.3l-1.21.15a5.9,5.9,0,0,1,1.29,1.92,5.81,5.81,0,0,1,.45,2.26,5.91,5.91,0,0,1-5.9,5.9l-1,1,.49.49.47.5Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  insert_row_below: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M15.7,1.3c-0.1-0.1-0.1-0.2-0.2-0.2L15.3,1H0.4L0.3,1.1c0,0-0.1,0.1-0.1,0.1c0,0-0.1,0.1-0.1,0.1L0,1.4v7.7l0.1,0.1c0,0.1,0.1,0.1,0.2,0.2l0.1,0.1h2.3V9.3l0.1-0.5L3,8.5l0.1-0.2c-0.1,0-0.2,0-0.3,0H1.2v-6h13.3v6h-1.6c-0.1,0-0.2,0-0.3,0l0.1,0.2l0.2,0.4C12.9,9,13,9.2,13,9.3v0.1h2.3l0.2-0.1c0.1,0,0.1-0.1,0.2-0.2l0.1-0.1V1.4L15.7,1.3z"/><path d="M10.5,7.5C9.9,7.1,9.3,6.8,8.6,6.7c-0.2,0-0.5-0.1-0.7,0c-0.2,0-0.5,0-0.7,0C6.6,6.7,6.1,6.9,5.6,7.3C5.2,7.6,4.7,8,4.4,8.4C4.3,8.6,4.2,8.8,4.2,8.9C4.1,9.1,4,9.3,3.9,9.4C3.9,9.6,3.8,9.7,3.8,9.9c0,0.2-0.1,0.3-0.1,0.5v-0.1c-0.1,0.8,0.1,1.6,0.5,2.4c0.4,0.7,1,1.3,1.7,1.7c0.3,0.2,0.6,0.3,0.9,0.3c0.3,0.1,0.7,0.1,1,0.1c0.3,0,0.7,0,1-0.1c0.3-0.1,0.6-0.2,0.9-0.3c0.5-0.3,0.9-0.6,1.3-1c0.3-0.4,0.6-0.8,0.8-1.3c0.1-0.4,0.2-0.9,0.2-1.4c0-0.5-0.1-1-0.3-1.4C11.5,8.6,11.1,8,10.5,7.5z M10.1,11.3H8.5v1.6H8H7.9H7.3v0v-0.1v-1.4H5.7v-0.4v-0.2v-0.6h0h1.5V8.5h1.2v1.6h1.6V11.3z"/></g></svg>',
  insert_row_above: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M0.1,14.5c0.1,0.1,0.1,0.2,0.2,0.2l0.1,0.1h14.9l0.1-0.1c0,0,0.1-0.1,0.1-0.1c0,0,0.1-0.1,0.1-0.1l0.1-0.1V6.7l-0.1-0.1c0-0.1-0.1-0.1-0.2-0.2l-0.1-0.1h-2.3v0.1l-0.1,0.5l-0.2,0.4l-0.1,0.2c0.1,0,0.2,0,0.3,0h1.6v6H1.3v-6h1.6c0.1,0,0.2,0,0.3,0L3.1,7.3L2.9,6.9C2.8,6.8,2.8,6.6,2.7,6.5V6.3H0.4L0.3,6.4c-0.1,0-0.1,0.1-0.2,0.2L0,6.7v7.7L0.1,14.5z"/><path d="M5.3,8.3c0.6,0.5,1.2,0.8,1.9,0.9c0.2,0,0.5,0.1,0.7,0c0.2,0,0.5,0,0.7,0c0.6-0.1,1.1-0.3,1.6-0.6c0.5-0.3,0.9-0.7,1.2-1.2c0.1-0.2,0.2-0.3,0.3-0.5c0.1-0.2,0.2-0.4,0.2-0.5c0.1-0.1,0.1-0.3,0.1-0.4C12,5.8,12,5.6,12,5.4v0.1c0.1-0.8-0.1-1.6-0.5-2.4c-0.4-0.7-1-1.3-1.7-1.7C9.5,1.3,9.2,1.2,8.9,1.1C8.5,1,8.2,1,7.9,1c-0.3,0-0.7,0-1,0.1C6.6,1.2,6.3,1.3,6,1.4C5.5,1.7,5.1,2,4.7,2.4C4.4,2.8,4.1,3.3,3.9,3.8C3.8,4.2,3.7,4.7,3.7,5.2c0,0.5,0.1,1,0.3,1.4C4.3,7.2,4.7,7.8,5.3,8.3z M5.7,4.5h1.6V2.9h0.5h0.1h0.6v0v0.1v1.4H10v0.4v0.2v0.6h0H8.5v1.6H7.3V5.7H5.7V4.5z"/></g></svg>',
  insert_column_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M14.5,15.7c0.1-0.1,0.2-0.1,0.2-0.2l0.1-0.1V0.4l-0.1-0.1c0,0-0.1-0.1-0.1-0.1c0,0-0.1-0.1-0.1-0.1L14.4,0H6.7L6.6,0.1c-0.1,0-0.1,0.1-0.2,0.2L6.3,0.4v2.3h0.1l0.5,0.1L7.3,3l0.2,0.1c0-0.1,0-0.2,0-0.3V1.2h6v13.3h-6v-1.6c0-0.1,0-0.2,0-0.3l-0.2,0.1l-0.4,0.2C6.7,12.9,6.6,13,6.4,13H6.3v2.3l0.1,0.2c0,0.1,0.1,0.1,0.2,0.2l0.1,0.1h7.7L14.5,15.7z"/><path d="M8.3,10.5C8.7,10,9,9.3,9.1,8.6c0-0.2,0.1-0.5,0-0.7c0-0.2,0-0.5,0-0.7C9,6.7,8.8,6.1,8.5,5.7C8.2,5.2,7.8,4.8,7.3,4.5C7.2,4.4,7,4.3,6.9,4.2C6.7,4.1,6.5,4,6.4,4C6.2,3.9,6.1,3.9,5.9,3.8c-0.2,0-0.3-0.1-0.5-0.1h0.1C4.7,3.7,3.8,3.9,3.1,4.3C2.4,4.7,1.8,5.3,1.4,6C1.3,6.3,1.2,6.6,1.1,6.9C1,7.2,1,7.6,1,7.9c0,0.3,0,0.7,0.1,1c0.1,0.3,0.2,0.6,0.3,0.9c0.3,0.5,0.6,0.9,1,1.3c0.4,0.3,0.8,0.6,1.3,0.8C4.2,12,4.7,12.1,5.1,12c0.5,0,1-0.1,1.4-0.3C7.2,11.5,7.8,11.1,8.3,10.5zM4.5,10.1V8.5H2.9V8V7.9V7.3h0H3h1.4V5.7h0.4h0.2h0.6v0v1.5h1.6v1.2H5.7v1.6H4.5z"/></g></svg>',
  insert_column_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M1.3,0.1C1.2,0.2,1.1,0.2,1.1,0.3L1,0.4v14.9l0.1,0.1c0,0,0.1,0.1,0.1,0.1c0,0,0.1,0.1,0.1,0.1l0.1,0.1h7.7l0.1-0.1c0.1,0,0.1-0.1,0.2-0.2l0.1-0.1v-2.3H9.3l-0.5-0.1l-0.4-0.2l-0.2-0.1c0,0.1,0,0.2,0,0.3v1.6h-6V1.3h6v1.6c0,0.1,0,0.2,0,0.3l0.2-0.1l0.4-0.2C9,2.9,9.2,2.8,9.3,2.8h0.1V0.5L9.4,0.3c0-0.1-0.1-0.1-0.2-0.2L9.1,0H1.4L1.3,0.1z"/><path d="M7.5,5.3C7,5.8,6.7,6.5,6.6,7.2c0,0.2-0.1,0.5,0,0.7c0,0.2,0,0.5,0,0.7c0.1,0.6,0.3,1.1,0.6,1.6c0.3,0.5,0.7,0.9,1.2,1.2c0.2,0.1,0.3,0.2,0.5,0.3c0.2,0.1,0.4,0.2,0.5,0.2c0.1,0.1,0.3,0.1,0.4,0.1c0.2,0,0.3,0.1,0.5,0.1h-0.1c0.8,0.1,1.6-0.1,2.4-0.5c0.7-0.4,1.3-1,1.7-1.7c0.2-0.3,0.3-0.6,0.3-0.9c0.1-0.3,0.1-0.7,0.1-1c0-0.3,0-0.7-0.1-1c-0.1-0.3-0.2-0.6-0.3-0.9c-0.3-0.5-0.6-0.9-1-1.3C13,4.4,12.5,4.2,12,4c-0.4-0.1-0.9-0.2-1.4-0.2c-0.5,0-1,0.1-1.4,0.2C8.5,4.3,7.9,4.7,7.5,5.3z M11.3,5.7v1.6h1.6v0.5v0.1v0.6h0h-0.1h-1.4v1.6h-0.4h-0.2h-0.6v0V8.5H8.5V7.3h1.6V5.7H11.3z"/></g></svg>',
  delete_row: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 13.83"><g><path d="M4.7,18.46l.12.08H19.73l.12-.08a.58.58,0,0,0,.22-.22l.08-.12,0-7.69-.08-.11a.77.77,0,0,0-.18-.18l-.11-.08-2.31,0-.08.28-.1.29a1.58,1.58,0,0,1-.12.29l-.14.34s0,0,.18,0H18.9v6H5.64v-6H7.35c.14,0,.2,0,.18,0l-.14-.34a2.85,2.85,0,0,1-.12-.29l-.1-.29-.07-.27-2.31,0-.11.08a.77.77,0,0,0-.18.18l-.08.11,0,7.69.08.12a.47.47,0,0,0,.09.12l.13.09ZM12.11,13a4,4,0,0,0,1.46-.21,4.51,4.51,0,0,0,1.31-.71A4,4,0,0,0,16.26,10a4.32,4.32,0,0,0-.08-2.54,4.34,4.34,0,0,0-1-1.52,4.15,4.15,0,0,0-1.54-1,4.34,4.34,0,0,0-1.35-.22A4.07,4.07,0,0,0,11,4.93,3.94,3.94,0,0,0,9.24,6.07,3.92,3.92,0,0,0,8.15,8.88a3.91,3.91,0,0,0,.12.95A4.16,4.16,0,0,0,12.11,13Zm2.35-4.14v.58H10.09V8.27h4.37v.58Z" transform="translate(-4.4 -4.71)"/></g></svg>',
  delete_column: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.81 15.74"><g><path d="M5.66,19.42l.12.08,7.69,0,.11-.08a.77.77,0,0,0,.18-.18l.08-.11,0-2.32-.15,0-.45-.15-.42-.18-.17-.07a1,1,0,0,0,0,.27v1.63h-6V5h6V6.62a.9.9,0,0,0,0,.26l.17-.07.42-.17a3.91,3.91,0,0,1,.45-.15l.15,0,0-2.32L13.75,4a.77.77,0,0,0-.18-.18l-.11-.08H5.79l-.13.07a.63.63,0,0,0-.21.22l-.08.12V19.08l.08.12a.47.47,0,0,0,.09.12.35.35,0,0,0,.12.1Zm9-3.67a4.16,4.16,0,0,0,2.36-.51,4.08,4.08,0,0,0,1.67-1.72,4,4,0,0,0,.35-.91,3.79,3.79,0,0,0,.1-1,4.71,4.71,0,0,0-.11-1,5,5,0,0,0-.3-.87,4.25,4.25,0,0,0-1-1.25,4.49,4.49,0,0,0-1.34-.81A4.26,4.26,0,0,0,15,7.48a3.88,3.88,0,0,0-1.41.25A4.32,4.32,0,0,0,11.86,9,4,4,0,0,0,11,10.94a4.4,4.4,0,0,0-.05.68,4.5,4.5,0,0,0,.05.68,3.93,3.93,0,0,0,.61,1.57,4.22,4.22,0,0,0,1.18,1.2,4.59,4.59,0,0,0,.48.27c.2.1.37.17.5.22a2.44,2.44,0,0,0,.45.12,4.61,4.61,0,0,0,.5.07Zm2.54-4.12v.58H12.87V11h4.37v.59Z" transform="translate(-5.37 -3.76)"/></g></svg>',
  fixed_column_width: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6,5H18A1,1 0 0,1 19,6A1,1 0 0,1 18,7H6A1,1 0 0,1 5,6A1,1 0 0,1 6,5M21,2V4H3V2H21M15,8H17V22H15V8M7,8H9V22H7V8M11,8H13V22H11V8Z" /></svg>',
  rotate_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M0.5,10.2c0,0.1,0,0.2,0,0.3v0.2l0,0c0.1,0.3,0.3,0.6,0.4,0.9l0,0C1,11.8,1.3,12,1.5,11.9h0.1h0.2h0.1c0.1-0.1,0.3-0.3,0.4-0.5v-0.2c0-0.1,0-0.2-0.1-0.3l0,0c-0.2-0.2-0.3-0.4-0.3-0.7l0,0C1.8,10,1.7,9.9,1.5,9.8c-0.1,0-0.2,0-0.3,0H0.9C0.7,9.9,0.6,10,0.5,10.2L0.5,10.2z"/><path d="M2.2,11.5L2.2,11.5L2.2,11.5z"/><path d="M5.9,3.6L5.9,3.6L5.9,3.6z"/><path d="M0.1,7.9c0,0.3,0,0.6,0,0.9l0,0l0,0l0,0l0,0c0,0.2,0.1,0.3,0.2,0.4l0,0c0.2,0.1,0.3,0.2,0.5,0.2l0,0l0,0c0.2,0,0.4-0.1,0.5-0.3l0,0c0-0.1,0.1-0.3,0.1-0.4V8.6l0,0c0-0.2,0-0.5,0-0.7l0,0c0-0.2-0.1-0.4-0.2-0.5C1.1,7.3,0.9,7.2,0.7,7.2S0.3,7.3,0.2,7.4C0.1,7.5,0,7.7,0.1,7.9z"/><path d="M1.9,12.7L1.9,12.7c0,0.2,0,0.4,0.2,0.5l0,0l0.2,0.3l0,0c0.2,0.1,0.3,0.2,0.5,0.4l0,0l0,0l0,0l0,0C2.9,14,3,14.1,3.2,14.1s0.4-0.1,0.5-0.2c0.1-0.2,0.2-0.3,0.2-0.5v-0.1c0-0.2-0.1-0.4-0.2-0.5l0,0l-0.4-0.4l-0.2-0.2l0,0C3,12.1,2.8,12,2.6,12l0,0c-0.2,0-0.4,0.1-0.5,0.2l0,0C2,12.3,1.9,12.5,1.9,12.7z"/><path d="M6.6,15c0,0.2,0.1,0.4,0.2,0.5c0.1,0.1,0.2,0.2,0.4,0.3l0,0c0.3,0,0.5,0,0.7,0h0.3l0,0c0.2,0,0.4-0.1,0.5-0.2c0.1-0.2,0.2-0.3,0.2-0.5l0,0l0,0c0-0.2-0.1-0.4-0.2-0.5l0,0c-0.1-0.1-0.3-0.2-0.5-0.2l0,0H7.9c-0.1,0-0.3,0-0.5,0l0,0H7.3c-0.2-0.1-0.3,0-0.5,0.1l0,0C6.7,14.6,6.6,14.8,6.6,15L6.6,15L6.6,15L6.6,15z"/><path d="M4.2,7.4C4,7.5,4,7.7,4,7.9c0,0.2,0,0.4,0.2,0.5l0,0l3.2,3.2l0,0c0.1,0.1,0.3,0.2,0.5,0.2s0.3-0.1,0.5-0.2l0,0l3.2-3.2l0,0c0.1-0.1,0.2-0.3,0.2-0.5c0-0.2-0.1-0.4-0.2-0.5l0,0C11.5,7.3,11,6.7,10,5.8l0,0L8.4,4.2l0,0C8.3,4.1,8.1,4,7.9,4S7.5,4.1,7.4,4.2L4.2,7.4L4.2,7.4z M6.8,9L5.7,7.9l2.2-2.2l2.3,2.2l-2.3,2.2C7.7,9.9,7.3,9.5,6.8,9L6.8,9z"/><path d="M4.1,14.1C4,14.2,4,14.3,4,14.4v0.2l0,0c0.1,0.1,0.2,0.3,0.4,0.4l0,0c0.3,0.1,0.6,0.2,0.9,0.4h0.1h0.1l0,0c0.2,0,0.3-0.1,0.5-0.1l0,0c0.2-0.1,0.3-0.3,0.3-0.4l0,0l0,0l0,0l0,0v-0.2c0-0.1-0.1-0.2-0.1-0.3l0,0C6.1,14.2,6,14.1,5.8,14l0,0c-0.3-0.1-0.5-0.2-0.8-0.2l0,0c-0.1-0.1-0.2-0.1-0.3-0.1H4.5C4.3,13.7,4.2,13.9,4.1,14.1z"/><path d="M9.3,14.4c0,0.1-0.1,0.3,0,0.4V15l0,0c0,0.1,0.1,0.3,0.5,0.4c0.1,0.1,0.3,0.1,0.4,0.1l0,0h0.1l0,0c0.3-0.1,0.6-0.2,0.9-0.3l0,0c0.1-0.1,0.2-0.2,0.3-0.4l0.1-0.3c0-0.1-0.1-0.2-0.1-0.3l0,0c-0.1-0.2-0.2-0.3-0.4-0.4l0,0h-0.3c-0.1,0-0.2,0-0.3,0l0,0c-0.2,0.1-0.5,0.2-0.8,0.3l0,0C9.5,14.1,9.4,14.2,9.3,14.4L9.3,14.4z"/><path d="M11.4,14.7L11.4,14.7L11.4,14.7z"/><path d="M9.5,15.3L9.5,15.3L9.5,15.3z"/><path d="M15.9,7.9c0-1-0.2-2-0.6-3l0,0c-0.4-1-1-1.9-1.7-2.6C12.8,1.6,12,1,11,0.6l0,0C10.1,0.2,9,0,8,0C7.3,0,6.5,0.1,5.8,0.3l0,0C5.2,0.5,4.6,0.8,4,1.1L3.1,0.2l0,0C2.9,0.1,2.8,0,2.6,0H2.4l0,0C2.2,0,2,0.2,1.9,0.4l0,0L0.1,4.9l0,0C0,5,0,5.1,0,5.2c0,0.2,0.1,0.4,0.2,0.5l0,0c0.2,0.1,0.3,0.2,0.5,0.2h0.1H1l0,0l4.7-1.8l0,0C5.9,4,6.1,3.8,6.1,3.6V3.4C6.1,3.2,6,3,5.9,2.9l0,0L5.1,2.1c0.4-0.2,0.8-0.4,1.3-0.5c0.5-0.1,1.1-0.2,1.7-0.2c0.9,0,1.7,0.2,2.5,0.5l0,0c0.8,0.3,1.5,0.8,2.1,1.4c0.6,0.6,1.1,1.3,1.4,2.1l0,0c0.3,0.8,0.5,1.6,0.5,2.5s-0.2,1.7-0.5,2.5l0,0c-0.3,0.8-0.8,1.5-1.4,2.1c-0.2,0.2-0.4,0.3-0.6,0.5l0,0c-0.2,0.1-0.3,0.3-0.3,0.5v0.1c0,0.1,0,0.3,0.1,0.4l0,0c0.1,0.2,0.3,0.3,0.5,0.3l0,0c0.1,0,0.3-0.1,0.4-0.2l0,0l0,0l0,0l0,0c0.2-0.2,0.5-0.4,0.7-0.6l0,0l0,0l0,0l0,0c0.7-0.8,1.3-1.6,1.7-2.6C15.6,10,15.8,9,15.9,7.9z M1.9,4C2,3.8,2.1,3.5,2.3,3.1l0,0L2.7,2l1.2,1.2L1.9,4z"/><path d="M6.8,15.5L6.8,15.5L6.8,15.5z"/></g></svg>',
  rotate_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M9.9,15.3L9.9,15.3L9.9,15.3z"/><path d="M6.9,15.1L6.9,15.1c0,0.1,0.1,0.3,0.2,0.4l0,0c0.1,0.2,0.3,0.3,0.5,0.3l0,0h0.3c0.2,0,0.4,0,0.7,0l0,0c0.2-0.1,0.3-0.2,0.4-0.3c0.1-0.1,0.2-0.2,0.2-0.4V15c0-0.2-0.1-0.4-0.2-0.4c-0.2-0.1-0.3-0.2-0.5-0.2H8.4l0,0c-0.1,0-0.3,0-0.5,0H7.6l0,0c-0.2,0-0.4,0.1-0.5,0.2C7,14.7,6.9,14.9,6.9,15.1z"/><path d="M6.5,14.4L6.5,14.4L6.5,14.4z"/><path d="M5.8,5.8L5.8,5.8c-1,0.9-1.5,1.5-1.7,1.6l0,0C4,7.5,4,7.7,4,7.9c0,0.2,0,0.4,0.2,0.5l0,0l3.2,3.2l0,0c0.2,0.1,0.3,0.2,0.5,0.2s0.4-0.1,0.5-0.2l0,0l3.2-3.2l0,0c0.1-0.1,0.2-0.3,0.2-0.5c0-0.2-0.1-0.4-0.2-0.5l0,0L8.4,4.2C8.3,4.1,8.1,4,7.9,4C7.7,4,7.5,4.1,7.4,4.2l0,0L5.8,5.8z M5.6,7.9l2.3-2.2l2.2,2.2L9,9l0,0l0,0l0,0l0,0c-0.5,0.6-0.9,0.9-1.1,1.1L5.6,7.9z"/><path d="M9,15.5L9,15.5L9,15.5z"/><path d="M9.6,14.7v0.2l0,0l0,0l0,0l0,0c0.1,0.2,0.1,0.3,0.3,0.3c0.1,0.1,0.3,0.1,0.4,0.1l0,0h0.1h0.1c0.3-0.1,0.6-0.3,0.9-0.4l0,0c0.1-0.1,0.2-0.2,0.3-0.4l0,0v-0.2c0-0.1,0-0.2-0.1-0.3c-0.1-0.2-0.2-0.3-0.4-0.4H11c-0.1,0-0.2,0.1-0.3,0.1l0,0c-0.2,0.1-0.4,0.2-0.7,0.3l0,0l0,0c-0.1,0.1-0.3,0.2-0.4,0.4C9.6,14.5,9.6,14.6,9.6,14.7z"/><path d="M9,14.5L9,14.5L9,14.5z"/><path d="M9.6,14.4L9.6,14.4L9.6,14.4z"/><path d="M11.7,14L11.7,14L11.7,14z"/><path d="M15.6,7.4L15.6,7.4L15.6,7.4z"/><path d="M15,9.4c0.2,0,0.4,0,0.6-0.2l0,0c0.1-0.1,0.2-0.2,0.2-0.4l0,0l0,0l0,0l0,0c0-0.3,0-0.6,0-0.9c0-0.2-0.1-0.4-0.2-0.5c-0.1-0.1-0.3-0.2-0.5-0.2s-0.4,0.1-0.5,0.2c-0.1,0.1-0.2,0.3-0.2,0.5l0,0c0,0.2,0,0.4,0,0.7l0,0v0.1c0,0.1,0,0.3,0.1,0.4l0,0C14.6,9.3,14.8,9.4,15,9.4L15,9.4L15,9.4z"/><path d="M14,12h0.1h0.2h0.1c0.2,0,0.5-0.2,0.6-0.4l0,0c0.2-0.3,0.3-0.6,0.4-0.9l0,0v-0.2c0-0.1-0.1-0.2-0.1-0.3c-0.1-0.2-0.2-0.3-0.4-0.4h-0.3c-0.1,0-0.2,0-0.3,0C14.2,9.9,14,10,14,10.3l0,0c-0.1,0.2-0.2,0.5-0.3,0.7l0,0c-0.1,0.1-0.1,0.2-0.1,0.3v0.2l0,0l0,0C13.6,11.6,13.8,11.8,14,12z"/><path d="M14.6,7.4L14.6,7.4L14.6,7.4z"/><path d="M4.4,14.2c-0.1,0.1-0.1,0.2-0.1,0.3l0.1,0.2c0,0.2,0.2,0.3,0.3,0.4l0,0c0.3,0.1,0.6,0.3,1.1,0.4l0,0h0.1l0,0c0.1,0,0.2-0.1,0.4-0.2c0.1,0,0.2-0.2,0.3-0.3l0,0v-0.2c0-0.1-0.1-0.3-0.2-0.4c-0.1-0.1-0.2-0.2-0.4-0.3l0,0c-0.2-0.1-0.5-0.2-0.7-0.3l0,0c-0.1,0-0.2,0-0.3,0H4.7l0,0C4.6,13.9,4.4,14,4.4,14.2L4.4,14.2z"/><path d="M11.9,13.3c0,0.2,0.1,0.4,0.2,0.6c0.1,0.1,0.3,0.2,0.5,0.2s0.4-0.1,0.5-0.2l0,0l0,0l0,0l0,0c0.1-0.1,0.3-0.3,0.4-0.4l0,0l0.2-0.3l0,0c0.1-0.2,0.2-0.3,0.2-0.5l0,0c0-0.2-0.1-0.4-0.2-0.5l0,0c-0.1-0.1-0.3-0.2-0.5-0.2l0,0c-0.2,0-0.4,0.1-0.5,0.2l0,0l-0.2,0.2l-0.4,0.4l0,0C12,13,11.9,13.1,11.9,13.3L11.9,13.3z"/><path d="M12.1,13.8L12.1,13.8L12.1,13.8z"/><path d="M11.9,13.3L11.9,13.3L11.9,13.3z"/><path d="M15.9,5.2c0-0.1-0.1-0.2-0.1-0.3l0,0L14,0.4l0,0C13.9,0.2,13.7,0,13.5,0l0,0l0,0h-0.2c-0.2,0-0.4,0.1-0.5,0.2l0,0l-0.9,0.9c-0.5-0.3-1.1-0.6-1.8-0.8l0,0C9.4,0.1,8.7,0,7.9,0c-1,0-2,0.2-3,0.6S3,1.6,2.3,2.3C1.6,3.1,1,3.9,0.6,4.9l0,0C0.2,5.8,0,6.8,0,7.9c0,1,0.2,2,0.6,3s0.9,1.8,1.7,2.6l0,0l0,0l0,0l0,0c0.2,0.2,0.5,0.4,0.7,0.6l0,0l0,0l0,0l0,0c0.2,0.1,0.3,0.2,0.5,0.2l0,0c0.2,0,0.4-0.1,0.6-0.3l0,0c0.1-0.1,0.1-0.3,0.1-0.4v-0.1l0,0C4.1,13.3,4,13.1,3.9,13l0,0c-0.2-0.1-0.4-0.3-0.6-0.5c-0.6-0.6-1.1-1.3-1.4-2.1l0,0C1.6,9.6,1.4,8.8,1.4,7.9s0.2-1.7,0.5-2.5l0,0c0.3-0.8,0.8-1.5,1.4-2.1c0.6-0.6,1.3-1.1,2.1-1.4l0,0C6.2,1.6,7,1.4,7.9,1.4c0.6,0,1.1,0.1,1.7,0.2c0.5,0.1,0.9,0.3,1.3,0.5l-0.8,0.8l0,0C10,3.1,9.9,3.2,9.9,3.4v0.2l0,0l0,0c0,0.2,0.2,0.4,0.4,0.5l0,0l4.5,1.8l0,0H15h0.1c0.2,0,0.4-0.1,0.5-0.2l0,0C15.7,5.6,15.8,5.4,15.9,5.2z M11.8,3.2L13,2l0.4,1.1l0,0c0.2,0.4,0.3,0.7,0.4,0.9L11.8,3.2z"/></g></svg>',
  mirror_horizontal: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.75 15.74"><g><path d="M13.75,3.76l5.9,15.74h-5.9V3.76ZM4.9,19.5,10.8,3.76V19.5H4.9Z" transform="translate(-4.9 -3.76)"/></g></svg>',
  mirror_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.75"><g><path d="M20.15,13.1,4.41,19V13.1H20.15ZM4.41,4.25l15.74,5.9H4.41V4.25Z" transform="translate(-4.41 -4.25)"/></g></svg>',
  checked: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 12.1"><g><path d="M4.59,12.23l.12.18L9.43,17.5a.58.58,0,0,0,.84,0L20,7.45h0a.58.58,0,0,0,0-.84l-.85-.85a.58.58,0,0,0-.84,0H18.2l-8.12,8.41a.29.29,0,0,1-.42,0l-3.4-3.63a.58.58,0,0,0-.84,0l-.85.85a.6.6,0,0,0-.14.21.51.51,0,0,0,0,.44c.05.06.1.13.16.19Z" transform="translate(-4.38 -5.58)"/></g></svg>',
  line_break: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19,6a1,1,0,0,0-1,1v4a1,1,0,0,1-1,1H7.41l1.3-1.29A1,1,0,0,0,7.29,9.29l-3,3a1,1,0,0,0-.21.33,1,1,0,0,0,0,.76,1,1,0,0,0,.21.33l3,3a1,1,0,0,0,1.42,0,1,1,0,0,0,0-1.42L7.41,14H17a3,3,0,0,0,3-3V7A1,1,0,0,0,19,6Z"/></svg>',
  audio: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z" /></svg>',
  image_gallery: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="30 30 150 150"><g><path d="M152.775,120.548V51.651c0-12.271-9.984-22.254-22.254-22.254H43.727c-12.271,0-22.254,9.983-22.254,22.254v68.896c0,12.27,9.983,22.254,22.254,22.254h86.795C142.791,142.802,152.775,132.817,152.775,120.548z M36.394,51.651c0-4.042,3.291-7.333,7.333-7.333h86.795c4.042,0,7.332,3.291,7.332,7.333v23.917l-14.938-17.767c-1.41-1.678-3.487-2.649-5.68-2.658h-0.029c-2.184,0-4.255,0.954-5.674,2.613L76.709,98.519l-9.096-9.398c-1.427-1.474-3.392-2.291-5.448-2.273c-2.052,0.025-4.004,0.893-5.396,2.4L36.394,111.32V51.651z M41.684,127.585l20.697-22.416l9.312,9.622c1.461,1.511,3.489,2.334,5.592,2.27c2.101-0.066,4.075-1.013,5.44-2.612l34.436-40.308l20.693,24.613v21.794c0,4.042-3.29,7.332-7.332,7.332H43.727C43.018,127.88,42.334,127.775,41.684,127.585z M182.616,152.5V75.657c0-4.12-3.34-7.46-7.461-7.46c-4.119,0-7.46,3.34-7.46,7.46V152.5c0,4.112-3.347,7.46-7.461,7.46h-94c-4.119,0-7.46,3.339-7.46,7.459c0,4.123,3.341,7.462,7.46,7.462h94C172.576,174.881,182.616,164.841,182.616,152.5z"/></g></svg>',
  bookmark: '<svg viewBox="0 0 24 24"><path d="M17,3H7A2,2 0 0,0 5,5V21L12,18L19,21V5C19,3.89 18.1,3 17,3Z" /></svg>',
  download: '<svg viewBox="0 0 24 24"><path d="M2 12H4V17H20V12H22V17C22 18.11 21.11 19 20 19H4C2.9 19 2 18.11 2 17V12M12 15L17.55 9.54L16.13 8.13L13 11.25V2H11V11.25L7.88 8.13L6.46 9.55L12 15Z" /></svg>',
  dir_ltr: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M9 4v4c-1.1 0-2-.9-2-2s.9-2 2-2m8-2H9C6.79 2 5 3.79 5 6s1.79 4 4 4v5h2V4h2v11h2V4h2V2zm0 12v3H5v2h12v3l4-4-4-4z"/></svg>',
  dir_rtl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M10 4v4c-1.1 0-2-.9-2-2s.9-2 2-2m8-2h-8C7.79 2 6 3.79 6 6s1.79 4 4 4v5h2V4h2v11h2V4h2V2zM8 14l-4 4 4 4v-3h12v-2H8v-3z"/></svg>',
  // Error
  alert_outline: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11,15H13V17H11V15M11,7H13V13H11V7M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z" /></svg>',
  // More icons
  more_text: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="10 10 180 180"><g><path d="M49.711,142.188h49.027c2.328,0.002,4.394,1.492,5.129,3.699l9.742,29.252c0.363,1.092,1.385,1.828,2.537,1.83l15.883,0.01c0.859,0,1.667-0.412,2.17-1.109s0.641-1.594,0.37-2.41l-16.625-50.045L86.503,28.953c-0.36-1.097-1.383-1.839-2.537-1.842H64.532c-1.153-0.001-2.178,0.736-2.542,1.831L13.847,173.457c-0.271,0.816-0.135,1.713,0.369,2.412c0.503,0.697,1.311,1.109,2.171,1.109h15.872c1.151,0,2.173-0.736,2.537-1.828l9.793-29.287C45.325,143.66,47.39,142.18,49.711,142.188L49.711,142.188z M53.493,119.098l15.607-46.9c0.744-2.196,2.806-3.674,5.125-3.674s4.381,1.478,5.125,3.674l15.607,46.904c0.537,1.621,0.263,3.402-0.736,4.789c-1.018,1.408-2.649,2.24-4.386,2.24H58.615c-1.736,0-3.368-0.832-4.386-2.24C53.23,122.504,52.956,120.721,53.493,119.098L53.493,119.098z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.633,190.465,66.178,190.465,63.32L190.465,63.32z M190.465,101.994c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.887,1.026,5.352,3.056,7.395c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.994L190.465,101.994z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
  more_paragraph: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="10 10 180 180"><g><path d="M128.39,28.499H63.493c-25.558,0-46.354,20.796-46.354,46.354c0,25.559,20.796,46.353,46.354,46.353h9.271v55.625h18.542V47.04h9.271V176.83h18.543V47.04h9.271V28.499z M72.764,102.664h-9.271c-15.337,0-27.813-12.475-27.813-27.812c0-15.336,12.476-27.813,27.813-27.813h9.271V102.664z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.633,190.465,66.178,190.465,63.32L190.465,63.32z M190.465,101.994c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.887,1.026,5.352,3.056,7.395c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.994L190.465,101.994z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
  more_plus: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="35 30 140 140"><g><path d="M137.215,102.045c0,3.498-2.835,6.332-6.333,6.332H24.549c-3.498,0-6.334-2.834-6.334-6.332l0,0c0-3.498,2.836-6.333,6.334-6.333h106.333C134.38,95.711,137.215,98.547,137.215,102.045L137.215,102.045z M77.715,161.545c-3.498,0-6.333-2.836-6.333-6.334V48.878c0-3.498,2.836-6.333,6.333-6.333l0,0c3.498,0,6.334,2.835,6.334,6.333v106.333C84.049,158.709,81.213,161.545,77.715,161.545L77.715,161.545z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.632,190.465,66.177,190.465,63.32L190.465,63.32z M190.465,101.993c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.888,1.026,5.353,3.056,7.396c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.993L190.465,101.993z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
  more_horizontal: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 3.58"><g><path d="M4.64,10.73a1.84,1.84,0,0,1,.65-.65,1.76,1.76,0,0,1,1.79,0A1.79,1.79,0,0,1,8,11.63a1.84,1.84,0,0,1-.25.9,1.69,1.69,0,0,1-.65.65,1.8,1.8,0,0,1-2.69-1.55A2.08,2.08,0,0,1,4.64,10.73Zm6.09,0a1.84,1.84,0,0,1,.65-.65,1.78,1.78,0,0,1,2.67,1.55,1.73,1.73,0,0,1-.24.9,1.84,1.84,0,0,1-.65.65,1.76,1.76,0,0,1-1.79,0,1.79,1.79,0,0,1-.64-2.44Zm6.08,0a1.69,1.69,0,0,1,.65-.65,1.76,1.76,0,0,1,1.79,0,1.79,1.79,0,0,1,.9,1.54,1.73,1.73,0,0,1-.24.9,1.84,1.84,0,0,1-.65.65,1.8,1.8,0,0,1-2.69-1.55A2,2,0,0,1,16.81,10.73Z" transform="translate(-4.39 -9.84)"/></g></svg>',
  more_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 3.94 15.75"><g><path d="M12.28,7.69a1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39,1.92,1.92,0,0,1,.58-1.39,2,2,0,0,1,1.39-.58,1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39,1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58Zm0,2a1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39A1.92,1.92,0,0,1,13.67,13a2,2,0,0,1-1.39.58A1.92,1.92,0,0,1,10.89,13a2,2,0,0,1-.58-1.39,2,2,0,0,1,2-2Zm0,5.9a1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39,1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58,1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39,1.92,1.92,0,0,1,.58-1.39,1.94,1.94,0,0,1,1.39-.58Z" transform="translate(-10.31 -3.75)"/></g></svg>',
  // Not currently used
  attachment: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8.38 15.68"><g><path d="M15.23,6h1v9.78a3.88,3.88,0,0,1-1.31,2.45,4,4,0,0,1-6.57-2.45V7A3,3,0,0,1,9.2,4.89a3,3,0,0,1,5,2.09v8.31a1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58,1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39V8h1v7.32a1,1,0,0,0,.29.69,1,1,0,0,0,.69.28A.9.9,0,0,0,13,16a1,1,0,0,0,.29-.69V7a1.92,1.92,0,0,0-.58-1.39A2,2,0,0,0,11.27,5a1.92,1.92,0,0,0-1.39.58A2,2,0,0,0,9.33,7v8.31a3,3,0,1,0,5.9,0V6Z" transform="translate(-8.08 -3.78)"/></g></svg>',
  map: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.7 15.62"><g><path d="M12.05,12.42a2.93,2.93,0,1,1,2.07-5A2.88,2.88,0,0,1,15,9.49a3,3,0,0,1-.86,2.07,2.89,2.89,0,0,1-2.07.86Zm0-5.36a2.43,2.43,0,0,0-1.72,4.16,2.48,2.48,0,0,0,1.72.72,2.44,2.44,0,0,0,0-4.88Zm0-3.3A5.84,5.84,0,0,1,17.9,9.62a9.94,9.94,0,0,1-1.73,5A33.59,33.59,0,0,1,12.84,19a1.52,1.52,0,0,1-.23.2,1,1,0,0,1-.55.2h0a1,1,0,0,1-.55-.2,1.52,1.52,0,0,1-.23-.2,33.59,33.59,0,0,1-3.33-4.32,9.93,9.93,0,0,1-1.72-5,5.84,5.84,0,0,1,5.85-5.86ZM12,18.34l.08.05.06-.06a35.58,35.58,0,0,0,3.06-3.93,9.35,9.35,0,0,0,1.74-4.77,4.88,4.88,0,0,0-4.88-4.88A4.79,4.79,0,0,0,8.6,6.17,4.84,4.84,0,0,0,7.17,9.62,9.29,9.29,0,0,0,8.91,14.4,36,36,0,0,0,12,18.34Z" transform="translate(-6.2 -3.76)"/></g></svg>',
  magic_stick: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 15.75"><g><path d="M19.86,19.21a1,1,0,0,0,.28-.68,1,1,0,0,0-.28-.7L13,10.93a1,1,0,0,0-.7-.28,1,1,0,0,0-.68,1.65l6.9,6.9a1,1,0,0,0,.69.29.93.93,0,0,0,.69-.28ZM9.19,8.55a3,3,0,0,0,1.68,0,14.12,14.12,0,0,0,1.41-.32A11.26,11.26,0,0,0,10.8,7.06c-.56-.36-.86-.56-.91-.58S10,5.91,10,5.11s0-1.26-.15-1.37a4.35,4.35,0,0,0-1.19.71c-.53.4-.81.62-.87.68a9,9,0,0,0-2-.6,6.84,6.84,0,0,0-.76-.09s0,.27.08.77a8.6,8.6,0,0,0,.61,2q-.09.09-.69.87a3.59,3.59,0,0,0-.68,1.17c.12.17.57.23,1.36.15S7,9.26,7.15,9.23s.21.36.57.91a10.49,10.49,0,0,0,1.14,1.48c0-.1.14-.57.31-1.4a3,3,0,0,0,0-1.67Z" transform="translate(-4.41 -3.74)"/></g></svg>',
  empty_file: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12.78 15.75"><g><path d="M14.73,3.76,18.67,7.7v9.84a2,2,0,0,1-2,2H7.84a1.89,1.89,0,0,1-1.38-.58,2,2,0,0,1-.57-1.39V5.73a1.93,1.93,0,0,1,.57-1.38,2,2,0,0,1,1.38-.58h6.62l.26,0v0Zm2.95,4.92h-2a1.93,1.93,0,0,1-1.38-.57,2,2,0,0,1-.58-1.4V6.17c0-.36,0-.84,0-1.43H7.85a1,1,0,0,0-.7.29,1,1,0,0,0-.29.7V17.54a1,1,0,0,0,.29.69,1,1,0,0,0,.69.29h8.85a1,1,0,0,0,.71-.29.92.92,0,0,0,.28-.69Zm0-1L14.73,4.74v2A1,1,0,0,0,15,7.4a1,1,0,0,0,.69.29Z" transform="translate(-5.89 -3.76)"/></g></svg>'
}, Te = {
  code: "en",
  toolbar: {
    default: "Default",
    save: "Save",
    font: "Font",
    formats: "Formats",
    fontSize: "Size",
    bold: "Bold",
    underline: "Underline",
    italic: "Italic",
    strike: "Strike",
    subscript: "Subscript",
    superscript: "Superscript",
    removeFormat: "Remove Format",
    fontColor: "Font Color",
    hiliteColor: "Highlight Color",
    indent: "Indent",
    outdent: "Outdent",
    align: "Align",
    alignLeft: "Align left",
    alignRight: "Align right",
    alignCenter: "Align center",
    alignJustify: "Align justify",
    list: "List",
    orderList: "Ordered list",
    unorderList: "Unordered list",
    horizontalRule: "Horizontal line",
    hr_solid: "Solid",
    hr_dotted: "Dotted",
    hr_dashed: "Dashed",
    table: "Table",
    link: "Link",
    math: "Math",
    image: "Image",
    video: "Video",
    audio: "Audio",
    fullScreen: "Full screen",
    showBlocks: "Show blocks",
    codeView: "Code view",
    undo: "Undo",
    redo: "Redo",
    preview: "Preview",
    print: "print",
    tag_p: "Paragraph",
    tag_div: "Normal (DIV)",
    tag_h: "Header",
    tag_blockquote: "Quote",
    tag_pre: "Code",
    template: "Template",
    lineHeight: "Line height",
    paragraphStyle: "Paragraph style",
    textStyle: "Text style",
    imageGallery: "Image gallery",
    dir_ltr: "Left to right",
    dir_rtl: "Right to left",
    mention: "Mention"
  },
  dialogBox: {
    linkBox: {
      title: "Insert Link",
      url: "URL to link",
      text: "Text to display",
      newWindowCheck: "Open in new window",
      downloadLinkCheck: "Download link",
      bookmark: "Bookmark"
    },
    mathBox: {
      title: "Math",
      inputLabel: "Mathematical Notation",
      fontSizeLabel: "Font Size",
      previewLabel: "Preview"
    },
    imageBox: {
      title: "Insert image",
      file: "Select from files",
      url: "Image URL",
      altText: "Alternative text"
    },
    videoBox: {
      title: "Insert Video",
      file: "Select from files",
      url: "Media embed URL, YouTube/Vimeo"
    },
    audioBox: {
      title: "Insert Audio",
      file: "Select from files",
      url: "Audio URL"
    },
    browser: {
      tags: "Tags",
      search: "Search"
    },
    caption: "Insert description",
    close: "Close",
    submitButton: "Submit",
    revertButton: "Revert",
    proportion: "Constrain proportions",
    basic: "Basic",
    left: "Left",
    right: "Right",
    center: "Center",
    width: "Width",
    height: "Height",
    size: "Size",
    ratio: "Ratio"
  },
  controller: {
    edit: "Edit",
    unlink: "Unlink",
    remove: "Remove",
    insertRowAbove: "Insert row above",
    insertRowBelow: "Insert row below",
    deleteRow: "Delete row",
    insertColumnBefore: "Insert column before",
    insertColumnAfter: "Insert column after",
    deleteColumn: "Delete column",
    fixedColumnWidth: "Fixed column width",
    resize100: "Resize 100%",
    resize75: "Resize 75%",
    resize50: "Resize 50%",
    resize25: "Resize 25%",
    autoSize: "Auto size",
    mirrorHorizontal: "Mirror, Horizontal",
    mirrorVertical: "Mirror, Vertical",
    rotateLeft: "Rotate left",
    rotateRight: "Rotate right",
    maxSize: "Max size",
    minSize: "Min size",
    tableHeader: "Table header",
    mergeCells: "Merge cells",
    splitCells: "Split Cells",
    HorizontalSplit: "Horizontal split",
    VerticalSplit: "Vertical split"
  },
  menu: {
    spaced: "Spaced",
    bordered: "Bordered",
    neon: "Neon",
    translucent: "Translucent",
    shadow: "Shadow",
    code: "Code"
  }
}, q = {
  _d: null,
  _w: null,
  isIE: null,
  isIE_Edge: null,
  isOSX_IOS: null,
  isChromium: null,
  isResizeObserverSupported: null,
  _propertiesInit: function() {
    this._d || (this._d = document, this._w = window, this.isIE = navigator.userAgent.indexOf("Trident") > -1, this.isIE_Edge = navigator.userAgent.indexOf("Trident") > -1 || navigator.appVersion.indexOf("Edge") > -1, this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform), this.isChromium = !!window.chrome, this.isResizeObserverSupported = typeof ResizeObserver == "function");
  },
  _allowedEmptyNodeList: ".se-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas",
  /**
   * @description HTML Reserved Word Converter.
   * @param {String} contents 
   * @returns {String} HTML string
   * @private
   */
  _HTMLConvertor: function(n) {
    const l = { "&": "&amp;", " ": "&nbsp;", "'": "&apos;", '"': "&quot;", "<": "&lt;", ">": "&gt;" };
    return n.replace(/&|\u00A0|'|"|<|>/g, function(m) {
      return typeof l[m] == "string" ? l[m] : m;
    });
  },
  /**
   * @description Unicode Character 'ZERO WIDTH SPACE' (\u200B)
   */
  zeroWidthSpace: String.fromCharCode(8203),
  /**
   * @description Regular expression to find 'zero width space' (/\u200B/g)
   */
  zeroWidthRegExp: new RegExp(String.fromCharCode(8203), "g"),
  /**
   * @description Regular expression to find only 'zero width space' (/^\u200B+$/)
   */
  onlyZeroWidthRegExp: new RegExp("^" + String.fromCharCode(8203) + "+$"),
  fontValueMap: {
    "xx-small": 1,
    "x-small": 2,
    small: 3,
    medium: 4,
    large: 5,
    "x-large": 6,
    "xx-large": 7
  },
  /**
   * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)
   * @param {String|Node} text String value or Node
   * @returns {Boolean}
   */
  onlyZeroWidthSpace: function(n) {
    return n == null ? !1 : (typeof n != "string" && (n = n.textContent), n === "" || this.onlyZeroWidthRegExp.test(n));
  },
  /**
   * @description Gets XMLHttpRequest object
   * @returns {XMLHttpRequest|ActiveXObject}
   */
  getXMLHttpRequest: function() {
    if (this._w.ActiveXObject)
      try {
        return new ActiveXObject("Msxml2.XMLHTTP");
      } catch {
        try {
          return new ActiveXObject("Microsoft.XMLHTTP");
        } catch {
          return null;
        }
      }
    else
      return this._w.XMLHttpRequest ? new XMLHttpRequest() : null;
  },
  /**
   * @description Object.values
   * @param {Object|null} obj Object parameter.
   * @returns {Array}
   */
  getValues: function(n) {
    return n ? this._w.Object.keys(n).map(function(l) {
      return n[l];
    }) : [];
  },
  /**
   * @description Convert the CamelCase To the KebabCase.
   * @param {String|Array} param [Camel string]
   * @returns {String|Array}
   */
  camelToKebabCase: function(n) {
    return typeof n == "string" ? n.replace(/[A-Z]/g, function(l) {
      return "-" + l.toLowerCase();
    }) : n.map(function(l) {
      return q.camelToKebabCase(l);
    });
  },
  /**
   * @description Convert the KebabCase To the CamelCase.
   * @param {String|Array} param [KebabCase string]
   * @returns {String|Array}
   */
  kebabToCamelCase: function(n) {
    return typeof n == "string" ? n.replace(/-[a-zA-Z]/g, function(l) {
      return l.replace("-", "").toUpperCase();
    }) : n.map(function(l) {
      return q.camelToKebabCase(l);
    });
  },
  /**
   * @description Create Element node
   * @param {String} elementName Element name
   * @returns {Element}
   */
  createElement: function(n) {
    return this._d.createElement(n);
  },
  /**
   * @description Create text node
   * @param {String} text text contents
   * @returns {Node}
   */
  createTextNode: function(n) {
    return this._d.createTextNode(n || "");
  },
  /**
   * @description The editor checks tags by string.
   * If there is "<" or ">" in the attribute of tag, HTML is broken when checking the tag.
   * When using an attribute with "<" or ">", use "HTMLEncoder" to save. (ex: math(katex))
   * @param {String} contents HTML or Text string
   * @returns {String}
   */
  HTMLEncoder: function(n) {
    const l = { "<": "$lt;", ">": "$gt;" };
    return n.replace(/<|>/g, function(m) {
      return typeof l[m] == "string" ? l[m] : m;
    });
  },
  /**
   * @description The editor checks tags by string.
   * If there is "<" or ">" in the attribute of tag, HTML is broken when checking the tag.
   * Decoder of data stored as "HTMLEncoder" (ex: math(katex))
   * @param {String} contents HTML or Text string
   * @returns {String}
   */
  HTMLDecoder: function(n) {
    const l = { "$lt;": "<", "$gt;": ">" };
    return n.replace(/\$lt;|\$gt;/g, function(m) {
      return typeof l[m] == "string" ? l[m] : m;
    });
  },
  /**
   * @description This method run Object.prototype.hasOwnProperty.call(obj, key)
   * @param {Object} obj Object
   * @param {String} key obj.key
   * @returns {Boolean}
   */
  hasOwn: function(n, l) {
    return this._hasOwn.call(n, l);
  },
  _hasOwn: Object.prototype.hasOwnProperty,
  /**
   * @deprecated
   * @description Get the the tag path of the arguments value
   * If not found, return the first found value
   * @param {Array} nameArray File name array
   * @param {String} extension js, css
   * @returns {String}
   */
  getIncludePath: function(n, l) {
    let m = "";
    const C = [], c = l === "js" ? "script" : "link", v = l === "js" ? "src" : "href";
    let E = "(?:";
    for (let F = 0, a = n.length; F < a; F++)
      E += n[F] + (F < a - 1 ? "|" : ")");
    const w = new this._w.RegExp("(^|.*[\\/])" + E + "(\\.[^\\/]+)?." + l + "(?:\\?.*|;.*)?$", "i"), t = new this._w.RegExp(".+\\." + l + "(?:\\?.*|;.*)?$", "i");
    for (let F = this._d.getElementsByTagName(c), a = 0; a < F.length; a++)
      t.test(F[a][v]) && C.push(F[a]);
    for (let F = 0; F < C.length; F++) {
      let a = C[F][v].match(w);
      if (a) {
        m = a[0];
        break;
      }
    }
    if (m === "" && (m = C.length > 0 ? C[0][v] : ""), m.indexOf(":/") === -1 && m.slice(0, 2) !== "//" && (m = m.indexOf("/") === 0 ? location.href.match(/^.*?:\/\/[^\/]*/)[0] + m : location.href.match(/^[^\?]*\/(?:)/)[0] + m), !m)
      throw "[SUNEDITOR.util.getIncludePath.fail] The SUNEDITOR installation path could not be automatically detected. (name: +" + name + ", extension: " + l + ")";
    return m;
  },
  /**
   * @deprecated
   * @description Returns the CSS text that has been applied to the current page.
   * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.
   * @returns {String} Styles string
   */
  getPageStyle: function(n) {
    let l = "";
    const m = (n || this._d).styleSheets;
    for (let C = 0, c = m.length, v; C < c; C++) {
      try {
        v = m[C].cssRules;
      } catch {
        continue;
      }
      if (v)
        for (let E = 0, w = v.length; E < w; E++)
          l += v[E].cssText;
    }
    return l;
  },
  /**
   * @description Get the argument iframe's document object
   * @param {Element} iframe Iframe element (context.element.wysiwygFrame)
   * @returns {Document}
   */
  getIframeDocument: function(n) {
    let l = n.contentWindow || n.contentDocument;
    return l.document && (l = l.document), l;
  },
  /**
   * @description Get attributes of argument element to string ('class="---" name="---" ')
   * @param {Element} element Element object
   * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result
   * @returns {String}
   */
  getAttributesToString: function(n, l) {
    if (!n.attributes)
      return "";
    const m = n.attributes;
    let C = "";
    for (let c = 0, v = m.length; c < v; c++)
      l && l.indexOf(m[c].name) > -1 || (C += m[c].name + '="' + m[c].value + '" ');
    return C;
  },
  /**
   * @descriptionGets Get the length in bytes of a string.
   * referencing code: "https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11"
   * @param {String} text String text
   * @returns {Number}
   */
  getByteLength: function(n) {
    if (!n || !n.toString)
      return 0;
    n = n.toString();
    const l = this._w.encodeURIComponent;
    let m, C;
    return this.isIE_Edge ? (C = this._w.unescape(l(n)).length, m = 0, l(n).match(/(%0A|%0D)/gi) !== null && (m = l(n).match(/(%0A|%0D)/gi).length), C + m) : (C = new this._w.TextEncoder("utf-8").encode(n).length, m = 0, l(n).match(/(%0A|%0D)/gi) !== null && (m = l(n).match(/(%0A|%0D)/gi).length), C + m);
  },
  /**
   * @description It is judged whether it is the edit region top div element or iframe's body tag.
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isWysiwygDiv: function(n) {
    return n && n.nodeType === 1 && (this.hasClass(n, "se-wrapper-wysiwyg") || /^BODY$/i.test(n.nodeName));
  },
  /**
   * @description It is judged whether it is the contenteditable property is false.
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isNonEditable: function(n) {
    return n && n.nodeType === 1 && n.getAttribute("contenteditable") === "false";
  },
  /**
   * @description It is judged whether it is a node related to the text style.
   * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isTextStyleElement: function(n) {
    return n && n.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)$/i.test(n.nodeName);
  },
  /**
   * @description It is judged whether it is the input element (INPUT, TEXTAREA)
   * @param {Node} element The node to check
   * @returns 
   */
  isInputElement: function(n) {
    return n && n.nodeType === 1 && /^(INPUT|TEXTAREA)$/i.test(n.nodeName);
  },
  /**
   * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class="__se__format__replace_xxx")
   * Format element also contain "free format Element"
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isFormatElement: function(n) {
    return n && n.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD|DETAILS)$/i.test(n.nodeName) || this.hasClass(n, "(\\s|^)__se__format__replace_.+(\\s|$)|(\\s|^)__se__format__free_.+(\\s|$)")) && !this.isComponent(n) && !this.isWysiwygDiv(n);
  },
  /**
   * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class="__se__format__range_xxx")
   * Range format element is wrap the "format element" and "component"
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isRangeFormatElement: function(n) {
    return n && n.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD|DETAILS)$/i.test(n.nodeName) || this.hasClass(n, "(\\s|^)__se__format__range_.+(\\s|$)"));
  },
  /**
   * @description It is judged whether it is the closure range format element. (TH, TD | class="__se__format__range__closure_xxx")
   * Closure range format elements is included in the range format element.
   *  - Closure range format element is wrap the "format element" and "component"
   * ※ You cannot exit this format with the Enter key or Backspace key.
   * ※ Use it only in special cases. ([ex] format of table cells)
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isClosureRangeFormatElement: function(n) {
    return n && n.nodeType === 1 && (/^(TH|TD)$/i.test(n.nodeName) || this.hasClass(n, "(\\s|^)__se__format__range__closure_.+(\\s|$)"));
  },
  /**
   * @description It is judged whether it is the free format element. (PRE | class="__se__format__free_xxx")
   * Free format elements is included in the format element.
   * Free format elements's line break is "BR" tag.
   * ※ Entering the Enter key in the space on the last line ends "Free Format" and appends "Format".
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isFreeFormatElement: function(n) {
    return n && n.nodeType === 1 && (/^PRE$/i.test(n.nodeName) || this.hasClass(n, "(\\s|^)__se__format__free_.+(\\s|$)")) && !this.isComponent(n) && !this.isWysiwygDiv(n);
  },
  /**
   * @description It is judged whether it is the closure free format element. (class="__se__format__free__closure_xxx")
   * Closure free format elements is included in the free format element.
   *  - Closure free format elements's line break is "BR" tag.
   * ※ You cannot exit this format with the Enter key or Backspace key.
   * ※ Use it only in special cases. ([ex] format of table cells)
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isClosureFreeFormatElement: function(n) {
    return n && n.nodeType === 1 && this.hasClass(n, "(\\s|^)__se__format__free__closure_.+(\\s|$)");
  },
  /**
   * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class="se-component") and table, hr
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isComponent: function(n) {
    return n && (/se-component/.test(n.className) || /^(TABLE|HR)$/.test(n.nodeName));
  },
  /**
   * @description Checks for "__se__uneditable" in the class list.
   * Components with class "__se__uneditable" cannot be modified.
   * @param {Element} element The element to check
   * @returns {Boolean}
   */
  isUneditableComponent: function(n) {
    return n && this.hasClass(n, "__se__uneditable");
  },
  /**
   * @description It is judged whether it is the component [img, iframe] cover(class="se-component")
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isMediaComponent: function(n) {
    return n && /se-component/.test(n.className);
  },
  /**
   * @description It is judged whether it is the not checking node. (class="katex", "__se__tag")
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isNotCheckingNode: function(n) {
    return n && /katex|__se__tag/.test(n.className);
  },
  /**
   * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.
   * @param {Node} element Reference node.
   * @param {Function|null} validation Additional validation function.
   * @returns {Element|null}
   */
  getFormatElement: function(n, l) {
    if (!n)
      return null;
    for (l || (l = function() {
      return !0;
    }); n; ) {
      if (this.isWysiwygDiv(n))
        return null;
      if (this.isRangeFormatElement(n) && n.firstElementChild, this.isFormatElement(n) && l(n))
        return n;
      n = n.parentNode;
    }
    return null;
  },
  /**
   * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.
   * @param {Node} element Reference node.
   * @param {Function|null} validation Additional validation function.
   * @returns {Element|null}
   */
  getRangeFormatElement: function(n, l) {
    if (!n)
      return null;
    for (l || (l = function() {
      return !0;
    }); n; ) {
      if (this.isWysiwygDiv(n))
        return null;
      if (this.isRangeFormatElement(n) && !/^(THEAD|TBODY|TR)$/i.test(n.nodeName) && l(n))
        return n;
      n = n.parentNode;
    }
    return null;
  },
  /**
   * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.
   * @param {Node} element Reference node.
   * @param {Function|null} validation Additional validation function.
   * @returns {Element|null}
   */
  getFreeFormatElement: function(n, l) {
    if (!n)
      return null;
    for (l || (l = function() {
      return !0;
    }); n; ) {
      if (this.isWysiwygDiv(n))
        return null;
      if (this.isFreeFormatElement(n) && l(n))
        return n;
      n = n.parentNode;
    }
    return null;
  },
  /**
   * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.
   * @param {Node} element Reference node.
   * @param {Function|null} validation Additional validation function.
   * @returns {Element|null}
   */
  getClosureFreeFormatElement: function(n, l) {
    if (!n)
      return null;
    for (l || (l = function() {
      return !0;
    }); n; ) {
      if (this.isWysiwygDiv(n))
        return null;
      if (this.isClosureFreeFormatElement(n) && l(n))
        return n;
      n = n.parentNode;
    }
    return null;
  },
  /**
   * @description Add style and className of copyEl to originEl
   * @param {Element} originEl Origin element
   * @param {Element} copyEl Element to copy
   * @param {Array|null} blacklist Blacklist array(LowerCase)
   */
  copyTagAttributes: function(n, l, m) {
    if (l.style.cssText) {
      const c = l.style;
      for (let v = 0, E = c.length; v < E; v++)
        n.style[c[v]] = c[c[v]];
    }
    const C = l.attributes;
    for (let c = 0, v = C.length, E; c < v; c++)
      E = C[c].name.toLowerCase(), m && m.indexOf(E) > -1 || !C[c].value ? n.removeAttribute(E) : E !== "style" && n.setAttribute(C[c].name, C[c].value);
  },
  /**
   * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore "__se__format__" class
   * @param {Element} originEl Origin element
   * @param {Element} copyEl Element to copy
   */
  copyFormatAttributes: function(n, l) {
    l = l.cloneNode(!1), l.className = l.className.replace(/(\s|^)__se__format__[^\s]+/g, ""), this.copyTagAttributes(n, l);
  },
  /**
   * @description Get the item from the array that matches the condition.
   * @param {Array|HTMLCollection|NodeList} array Array to get item
   * @param {Function|null} validation Conditional function
   * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.
   * If false, returns only one item that meet the criteria otherwise return null.
   * @returns {Array|Node|null}
   */
  getArrayItem: function(n, l, m) {
    if (!n || n.length === 0)
      return null;
    l = l || function() {
      return !0;
    };
    const C = [];
    for (let c = 0, v = n.length, E; c < v; c++)
      if (E = n[c], l(E))
        if (m)
          C.push(E);
        else
          return E;
    return m ? C : null;
  },
  /**
   * @description Check if an array contains an element 
   * @param {Array|HTMLCollection|NodeList} array element array
   * @param {Node} element The element to check for
   * @returns {Boolean}
   */
  arrayIncludes: function(n, l) {
    for (let m = 0; m < n.length; m++)
      if (n[m] === l)
        return !0;
    return !1;
  },
  /**
   * @description Get the index of the argument value in the element array
   * @param {Array|HTMLCollection|NodeList} array element array
   * @param {Node} element The element to find index
   * @returns {Number}
   */
  getArrayIndex: function(n, l) {
    let m = -1;
    for (let C = 0, c = n.length; C < c; C++)
      if (n[C] === l) {
        m = C;
        break;
      }
    return m;
  },
  /**
   * @description Get the next index of the argument value in the element array
   * @param {Array|HTMLCollection|NodeList} array element array
   * @param {Node} item The element to find index
   * @returns {Number}
   */
  nextIdx: function(n, l) {
    let m = this.getArrayIndex(n, l);
    return m === -1 ? -1 : m + 1;
  },
  /**
   * @description Get the previous index of the argument value in the element array
   * @param {Array|HTMLCollection|NodeList} array Element array
   * @param {Node} item The element to find index
   * @returns {Number}
   */
  prevIdx: function(n, l) {
    let m = this.getArrayIndex(n, l);
    return m === -1 ? -1 : m - 1;
  },
  /**
   * @description Returns the index compared to other sibling nodes.
   * @param {Node} node The Node to find index
   * @returns {Number}
   */
  getPositionIndex: function(n) {
    let l = 0;
    for (; n = n.previousSibling; )
      l += 1;
    return l;
  },
  /**
   * @description Returns the position of the "node" in the "parentNode" in a numerical array.
   * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: "bb", parentNode: "<P>") -> [1, 0]
   * @param {Node} node The Node to find position path
   * @param {Node|null} parentNode Parent node. If null, wysiwyg div area
   * @param {Object|null} _newOffsets If you send an object of the form "{s: 0, e: 0}", the text nodes that are attached together are merged into one, centered on the "node" argument.
   * "_newOffsets.s" stores the length of the combined characters after "node" and "_newOffsets.e" stores the length of the combined characters before "node".
   * Do not use unless absolutely necessary.
   * @returns {Array}
   */
  getNodePath: function(n, l, m) {
    const C = [];
    let c = !0;
    return this.getParentElement(n, (function(v) {
      if (v === l && (c = !1), c && !this.isWysiwygDiv(v)) {
        if (m && v.nodeType === 3) {
          let E = null, w = null;
          m.s = m.e = 0;
          let t = v.previousSibling;
          for (; t && t.nodeType === 3; )
            w = t.textContent.replace(this.zeroWidthRegExp, ""), m.s += w.length, v.textContent = w + v.textContent, E = t, t = t.previousSibling, this.removeItem(E);
          let F = v.nextSibling;
          for (; F && F.nodeType === 3; )
            w = F.textContent.replace(this.zeroWidthRegExp, ""), m.e += w.length, v.textContent += w, E = F, F = F.nextSibling, this.removeItem(E);
        }
        C.push(v);
      }
      return !1;
    }).bind(this)), C.map(this.getPositionIndex).reverse();
  },
  /**
   * @description Returns the node in the location of the path array obtained from "util.getNodePath".
   * @param {Array} offsets Position array, array obtained from "util.getNodePath"
   * @param {Node} parentNode Base parent element
   * @returns {Node}
   */
  getNodeFromPath: function(n, l) {
    let m = l, C;
    for (let c = 0, v = n.length; c < v && (C = m.childNodes, C.length !== 0); c++)
      C.length <= n[c] ? m = C[C.length - 1] : m = C[n[c]];
    return m;
  },
  /**
   * @description Compares the style and class for equal values.
   * Returns true if both are text nodes.
   * @param {Node} a Node to compare
   * @param {Node} b Node to compare
   * @returns {Boolean}
   */
  isSameAttributes: function(n, l) {
    if (n.nodeType === 3 && l.nodeType === 3)
      return !0;
    if (n.nodeType === 3 || l.nodeType === 3)
      return !1;
    const m = n.style, C = l.style;
    let c = 0;
    for (let F = 0, a = m.length; F < a; F++)
      m[m[F]] === C[m[F]] && c++;
    const v = n.classList, E = l.classList, w = this._w.RegExp;
    let t = 0;
    for (let F = 0, a = v.length; F < a; F++)
      w("(s|^)" + v[F] + "(s|$)").test(E.value) && t++;
    return c === C.length && c === m.length && t === E.length && t === v.length;
  },
  /**
   * @description Check the line element(util.isFormatElement) is empty.
   * @param {Element} element Format element node
   * @returns {Boolean}
   */
  isEmptyLine: function(n) {
    return !n || !n.parentNode || !n.querySelector("IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE") && n.children.length === 0 && this.onlyZeroWidthSpace(n.textContent);
  },
  /**
   * @description Check the span's attributes are empty.
   * @param {Element|null} element Element node
   * @returns {Boolean}
   */
  isSpanWithoutAttr: function(n) {
    return !!n && n.nodeType === 1 && /^SPAN$/i.test(n.nodeName) && !n.className && !n.style.cssText;
  },
  /**
   * @description Check the node is a list (ol, ul)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isList: function(n) {
    return n && /^(OL|UL)$/i.test(typeof n == "string" ? n : n.nodeName);
  },
  /**
   * @description Check the node is a list cell (li)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isListCell: function(n) {
    return n && /^LI$/i.test(typeof n == "string" ? n : n.nodeName);
  },
  /**
   * @description Check the node is a table (table, thead, tbody, tr, th, td)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isTable: function(n) {
    return n && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof n == "string" ? n : n.nodeName);
  },
  /**
   * @description Check the node is a table cell (td, th)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isCell: function(n) {
    return n && /^(TD|TH)$/i.test(typeof n == "string" ? n : n.nodeName);
  },
  /**
   * @description Check the node is a break node (BR)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isBreak: function(n) {
    return n && /^BR$/i.test(typeof n == "string" ? n : n.nodeName);
  },
  /**
   * @description Check the node is a anchor node (A)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isAnchor: function(n) {
    return n && /^A$/i.test(typeof n == "string" ? n : n.nodeName);
  },
  /**
   * @description Check the node is a media node (img, iframe, audio, video, canvas)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isMedia: function(n) {
    return n && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof n == "string" ? n : n.nodeName);
  },
  /**
   * @description Check the node is a figure tag or util.isMedia()
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isFigures: function(n) {
    return n && (this.isMedia(n) || /^(FIGURE)$/i.test(typeof n == "string" ? n : n.nodeName));
  },
  /**
   * @description Checks for numeric (with decimal point).
   * @param {String|Number} text Text string or number
   * @returns {Boolean}
   */
  isNumber: function(n) {
    return !!n && /^-?\d+(\.\d+)?$/.test(n + "");
  },
  /**
   * @description Get a number.
   * @param {String|Number} text Text string or number
   * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)
   * @returns {Number}
   */
  getNumber: function(n, l) {
    if (!n)
      return 0;
    let m = (n + "").match(/-?\d+(\.\d+)?/);
    return !m || !m[0] ? 0 : (m = m[0], l < 0 ? m * 1 : l === 0 ? this._w.Math.round(m * 1) : (m * 1).toFixed(l) * 1);
  },
  /**
   * @description Get all "children" of the argument value element (Without text nodes)
   * @param {Element} element element to get child node
   * @param {Function|null} validation Conditional function
   * @returns {Array}
   */
  getListChildren: function(n, l) {
    const m = [];
    return !n || !n.children || n.children.length === 0 || (l = l || function() {
      return !0;
    }, function C(c) {
      if (n !== c && l(c) && m.push(c), c.children)
        for (let v = 0, E = c.children.length; v < E; v++)
          C(c.children[v]);
    }(n)), m;
  },
  /**
   * @description Get all "childNodes" of the argument value element (Include text nodes)
   * @param {Node} element element to get child node
   * @param {Function|null} validation Conditional function
   * @returns {Array}
   */
  getListChildNodes: function(n, l) {
    const m = [];
    return !n || n.childNodes.length === 0 || (l = l || function() {
      return !0;
    }, function C(c) {
      n !== c && l(c) && m.push(c);
      for (let v = 0, E = c.childNodes.length; v < E; v++)
        C(c.childNodes[v]);
    }(n)), m;
  },
  /**
   * @description Returns the number of parents nodes.
   * "0" when the parent node is the WYSIWYG area.
   * "-1" when the element argument is the WYSIWYG area.
   * @param {Node} element The element to check
   * @returns {Number}
   */
  getElementDepth: function(n) {
    if (!n || this.isWysiwygDiv(n))
      return -1;
    let l = 0;
    for (n = n.parentNode; n && !this.isWysiwygDiv(n); )
      l += 1, n = n.parentNode;
    return l;
  },
  /**
   * @description Compares two elements to find a common ancestor, and returns the order of the two elements.
   * @param {Node} a Node to compare.
   * @param {Node} b Node to compare.
   * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };
   */
  compareElements: function(n, l) {
    let m = n, C = l;
    for (; m && C && m.parentNode !== C.parentNode; )
      m = m.parentNode, C = C.parentNode;
    if (!m || !C)
      return { ancestor: null, a: n, b: l, result: 0 };
    const c = m.parentNode.childNodes, v = this.getArrayIndex(c, m), E = this.getArrayIndex(c, C);
    return {
      ancestor: m.parentNode,
      a: m,
      b: C,
      result: v > E ? 1 : v < E ? -1 : 0
    };
  },
  /**
   * @description Get the parent element of the argument value.
   * A tag that satisfies the query condition is imported.
   * Returns null if not found.
   * @param {Node} element Reference element
   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.
   * Not use it like jquery.
   * Only one condition can be entered at a time.
   * @returns {Element|null}
   */
  getParentElement: function(n, l) {
    let m;
    if (typeof l == "function")
      m = l;
    else {
      let C;
      /^\./.test(l) ? (C = "className", l = l.split(".")[1]) : /^#/.test(l) ? (C = "id", l = "^" + l.split("#")[1] + "$") : /^:/.test(l) ? (C = "name", l = "^" + l.split(":")[1] + "$") : (C = "nodeName", l = "^" + l + "$");
      const c = new this._w.RegExp(l, "i");
      m = function(v) {
        return c.test(v[C]);
      };
    }
    for (; n && !m(n); ) {
      if (this.isWysiwygDiv(n))
        return null;
      n = n.parentNode;
    }
    return n;
  },
  /**
   * @description Get the child element of the argument value.
   * A tag that satisfies the query condition is imported.
   * Returns null if not found.
   * @param {Node} element Reference element
   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.
   * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)
   * Not use it like jquery.
   * Only one condition can be entered at a time.
   * @returns {Element|null}
   */
  getChildElement: function(n, l, m) {
    let C;
    if (typeof l == "function")
      C = l;
    else {
      let v;
      /^\./.test(l) ? (v = "className", l = l.split(".")[1]) : /^#/.test(l) ? (v = "id", l = "^" + l.split("#")[1] + "$") : /^:/.test(l) ? (v = "name", l = "^" + l.split(":")[1] + "$") : (v = "nodeName", l = "^" + (l === "text" ? "#" + l : l) + "$");
      const E = new this._w.RegExp(l, "i");
      C = function(w) {
        return E.test(w[v]);
      };
    }
    const c = this.getListChildNodes(n, function(v) {
      return C(v);
    });
    return c[m ? c.length - 1 : 0];
  },
  /**
   * @description 1. The first node of all the child nodes of the "first" element is returned.
   * 2. The last node of all the child nodes of the "last" element is returned.
   * 3. When there is no "last" element, the first and last nodes of all the children of the "first" element are returned.
   * { sc: "first", ec: "last" }
   * @param {Node} first First element
   * @param {Node|null} last Last element
   * @returns {Object}
   */
  getEdgeChildNodes: function(n, l) {
    if (n) {
      for (l || (l = n); n && n.nodeType === 1 && n.childNodes.length > 0 && !this.isBreak(n); )
        n = n.firstChild;
      for (; l && l.nodeType === 1 && l.childNodes.length > 0 && !this.isBreak(l); )
        l = l.lastChild;
      return {
        sc: n,
        ec: l || n
      };
    }
  },
  /**
   * @description Returns the position of the left and top of argument. {left:0, top:0}
   * @param {Node} element Target node
   * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)
   * @returns {Object}
   */
  getOffset: function(n, l) {
    let m = 0, C = 0, c = n.nodeType === 3 ? n.parentElement : n;
    const v = this.getParentElement(n, this.isWysiwygDiv.bind(this));
    for (; c && !this.hasClass(c, "se-container") && c !== v; )
      m += c.offsetLeft, C += c.offsetTop, c = c.offsetParent;
    const E = l && /iframe/i.test(l.nodeName);
    return {
      left: m + (E ? l.parentElement.offsetLeft : 0),
      top: C - (v ? v.scrollTop : 0) + (E ? l.parentElement.offsetTop : 0)
    };
  },
  /**
   * @description It compares the start and end indexes of "a" and "b" and returns the number of overlapping indexes in the range.
   * ex) 1, 5, 4, 6 => "2" (4 ~ 5)
   * @param {Number} aStart Start index of "a"
   * @param {Number} aEnd End index of "a"
   * @param {Number} bStart Start index of "b"
   * @param {Number} bEnd Start index of "b"
   * @returns {Number}
   */
  getOverlapRangeAtIndex: function(n, l, m, C) {
    if (n <= C ? l < m : l > m)
      return 0;
    const c = (n > m ? n : m) - (l < C ? l : C);
    return (c < 0 ? c * -1 : c) + 1;
  },
  /**
   * @description Set the text content value of the argument value element
   * @param {Node} element Element to replace text content
   * @param {String} txt Text to be applied
   */
  changeTxt: function(n, l) {
    !n || !l || (n.textContent = l);
  },
  /**
   * @description Replace element
   * @param {Element} element Target element
   * @param {String|Element} newElement String or element of the new element to apply
   */
  changeElement: function(n, l) {
    if (typeof l == "string")
      if (n.outerHTML)
        n.outerHTML = l;
      else {
        const m = this.createElement("DIV");
        m.innerHTML = l, l = m.firstChild, n.parentNode.replaceChild(l, n);
      }
    else
      l.nodeType === 1 && n.parentNode.replaceChild(l, n);
  },
  /**
   * @description Set style, if all styles are deleted, the style properties are deleted.
   * @param {Element} element Element to set style
   * @param {String} styleName Style attribute name (marginLeft, textAlign...)
   * @param {String|Number} value Style value
   */
  setStyle: function(n, l, m) {
    n.style[l] = m, !m && !n.style.cssText && n.removeAttribute("style");
  },
  /**
   * @description Determine whether any of the matched elements are assigned the given class
   * @param {Element} element Elements to search class name
   * @param {String} className Class name to search for
   * @returns {Boolean}
   */
  hasClass: function(n, l) {
    if (n)
      return new this._w.RegExp(l).test(n.className);
  },
  /**
   * @description Append the className value of the argument value element
   * @param {Element} element Elements to add class name
   * @param {String} className Class name to be add
   */
  addClass: function(n, l) {
    !n || new this._w.RegExp("(\\s|^)" + l + "(\\s|$)").test(n.className) || (n.className += (n.className.length > 0 ? " " : "") + l);
  },
  /**
   * @description Delete the className value of the argument value element
   * @param {Element} element Elements to remove class name
   * @param {String} className Class name to be remove
   */
  removeClass: function(n, l) {
    if (!n)
      return;
    const m = new this._w.RegExp("(\\s|^)" + l + "(\\s|$)");
    n.className = n.className.replace(m, " ").trim(), n.className.trim() || n.removeAttribute("class");
  },
  /**
   * @description Argument value If there is no class name, insert it and delete the class name if it exists
   * @param {Element} element Elements to replace class name
   * @param {String} className Class name to be change
   * @returns {Boolean|undefined}
   */
  toggleClass: function(n, l) {
    if (!n)
      return;
    let m = !1;
    const C = new this._w.RegExp("(\\s|^)" + l + "(\\s|$)");
    return C.test(n.className) ? n.className = n.className.replace(C, " ").trim() : (n.className += " " + l, m = !0), n.className.trim() || n.removeAttribute("class"), m;
  },
  /**
   * @description Checks if element can't be easily enabled
   * @param {Element} element Element to check for
   */
  isImportantDisabled: function(n) {
    return n.hasAttribute("data-important-disabled");
  },
  /**
   * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.
   * core.codeViewDisabledButtons (An array of buttons whose class name is not "se-code-view-enabled")
   * core.resizingDisabledButtons (An array of buttons whose class name is not "se-resizing-enabled")
   * @param {Boolean} disabled Disabled value
   * @param {Array|HTMLCollection|NodeList} buttonList Button array
   * @param {Boolean} important If priveleged mode should be used (Necessary to switch importantDisabled buttons)
   */
  setDisabledButtons: function(n, l, m) {
    for (let C = 0, c = l.length; C < c; C++) {
      let v = l[C];
      (m || !this.isImportantDisabled(v)) && (v.disabled = n), m && (n ? v.setAttribute("data-important-disabled", "") : v.removeAttribute("data-important-disabled"));
    }
  },
  /**
   * @description Delete argumenu value element
   * @param {Node} item Node to be remove
   */
  removeItem: function(n) {
    n && (typeof n.remove == "function" ? n.remove() : n.parentNode && n.parentNode.removeChild(n));
  },
  /**
   * @description Delete all parent nodes that match the condition.
   * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.
   * @param {Node} item Node to be remove
   * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)
   * @param {Element|null} stopParent Stop when the parent node reaches stopParent
   * @returns {Object|null} {sc: previousSibling, ec: nextSibling}
   */
  removeItemAllParents: function(n, l, m) {
    if (!n)
      return null;
    let C = null;
    return l || (l = (function(c) {
      if (c === m || this.isComponent(c))
        return !1;
      const v = c.textContent.trim();
      return v.length === 0 || /^(\n|\u200B)+$/.test(v);
    }).bind(this)), function c(v) {
      if (!q.isWysiwygDiv(v)) {
        const E = v.parentNode;
        E && l(v) && (C = {
          sc: v.previousElementSibling,
          ec: v.nextElementSibling
        }, q.removeItem(v), c(E));
      }
    }(n), C;
  },
  /**
   * @description Detach Nested all nested lists under the "baseNode".
   * Returns a list with nested removed.
   * @param {Node} baseNode Element on which to base.
   * @param {Boolean} all If true, it also detach all nested lists of a returned list.
   * @returns {Element}
   */
  detachNestedList: function(n, l) {
    const m = this._deleteNestedList(n);
    let C, c;
    if (m) {
      C = m.cloneNode(!1), c = m.childNodes;
      const E = this.getPositionIndex(n);
      for (; c[E]; )
        C.appendChild(c[E]);
    } else
      C = n;
    let v;
    if (l)
      v = this.getListChildren(C, (function(E) {
        return this.isListCell(E) && !E.previousElementSibling;
      }).bind(this));
    else {
      const E = this.getElementDepth(n) + 2;
      v = this.getListChildren(n, (function(w) {
        return this.isListCell(w) && !w.previousElementSibling && this.getElementDepth(w) === E;
      }).bind(this));
    }
    for (let E = 0, w = v.length; E < w; E++)
      this._deleteNestedList(v[E]);
    return m && (m.parentNode.insertBefore(C, m.nextSibling), c && c.length === 0 && this.removeItem(m)), C === n ? C.parentNode : C;
  },
  /**
   * @description Sub function of util.detachNestedList method.
   * @private
   */
  _deleteNestedList: function(n) {
    const l = n.parentNode;
    let m = l, C = m.parentNode, c, v, E, w, t;
    for (; this.isListCell(C); ) {
      for (w = this.getPositionIndex(n), c = C.nextElementSibling, v = C.parentNode, E = m; E; ) {
        if (m = m.nextSibling, this.isList(E)) {
          for (t = E.childNodes; t[w]; )
            v.insertBefore(t[w], c);
          t.length === 0 && this.removeItem(E);
        } else
          v.appendChild(E);
        E = m;
      }
      m = v, C = v.parentNode;
    }
    return l.children.length === 0 && this.removeItem(l), v;
  },
  /**
   * @description Split all tags based on "baseNode"
   * Returns the last element of the splited tag.
   * @param {Node} baseNode Element or text node on which to base
   * @param {Number|Node|null} offset Text offset of "baseNode" (Only valid when "baseNode" is a text node)
   * @param {Number} depth The nesting depth of the element being split. (default: 0)
   * @returns {Element}
   */
  splitElement: function(n, l, m) {
    if (this.isWysiwygDiv(n))
      return n;
    if (l && !this.isNumber(l)) {
      const O = n.childNodes;
      let z = this.getPositionIndex(l);
      const K = n.cloneNode(!1), G = n.cloneNode(!1);
      for (let e = 0, i = O.length; e < i; e++) {
        if (e < z)
          K.appendChild(O[e]);
        else if (e > z)
          G.appendChild(O[e]);
        else
          continue;
        e--, i--, z--;
      }
      return K.childNodes.length > 0 && n.parentNode.insertBefore(K, n), G.childNodes.length > 0 && n.parentNode.insertBefore(G, n.nextElementSibling), n;
    }
    const C = n.parentNode;
    let c = 0, v = 1, E = !0, w, t, F;
    if ((!m || m < 0) && (m = 0), n.nodeType === 3) {
      if (c = this.getPositionIndex(n), l >= 0 && n.length !== l) {
        n.splitText(l);
        const O = this.getNodeFromPath([c + 1], C);
        this.onlyZeroWidthSpace(O) && (O.data = this.zeroWidthSpace);
      }
    } else if (n.nodeType === 1) {
      if (l === 0) {
        for (; n.firstChild; )
          n = n.firstChild;
        if (n.nodeType === 3) {
          const O = this.createTextNode(this.zeroWidthSpace);
          n.parentNode.insertBefore(O, n), n = O;
        }
      }
      n.previousSibling ? n = n.previousSibling : this.getElementDepth(n) === m && (E = !1);
    }
    n.nodeType === 1 && (v = 0);
    let a = n;
    for (; this.getElementDepth(a) > m; )
      for (c = this.getPositionIndex(a) + v, a = a.parentNode, F = w, w = a.cloneNode(!1), t = a.childNodes, F && (this.isListCell(w) && this.isList(F) && F.firstElementChild ? (w.innerHTML = F.firstElementChild.innerHTML, q.removeItem(F.firstElementChild), F.children.length > 0 && w.appendChild(F)) : w.appendChild(F)); t[c]; )
        w.appendChild(t[c]);
    a.childNodes.length <= 1 && (!a.firstChild || a.firstChild.textContent.length === 0) && (a.innerHTML = "<br>");
    const p = a.parentNode;
    return E && (a = a.nextSibling), w ? (this.mergeSameTags(w, null, !1), this.mergeNestedTags(w, (function(O) {
      return this.isList(O);
    }).bind(this)), w.childNodes.length > 0 ? p.insertBefore(w, a) : w = a, this.isListCell(w) && w.children && this.isList(w.children[0]) && w.insertBefore(this.createElement("BR"), w.children[0]), C.childNodes.length === 0 && this.removeItem(C), w) : a;
  },
  /**
   * @description Use with "npdePath (util.getNodePath)" to merge the same attributes and tags if they are present and modify the nodepath.
   * If "offset" has been changed, it will return as much "offset" as it has been modified.
   * An array containing change offsets is returned in the order of the "nodePathArray" array.
   * @param {Element} element Element
   * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])
   * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.
   * @returns {Array} [offset, ..]
   */
  mergeSameTags: function(n, l, m) {
    const C = this, c = l ? l.length : 0;
    let v = null;
    return c && (v = this._w.Array.apply(null, new this._w.Array(c)).map(this._w.Number.prototype.valueOf, 0)), function E(w, t, F) {
      const a = w.childNodes;
      for (let p = 0, O = a.length, z, K; p < O && (z = a[p], K = a[p + 1], !!z); p++) {
        if (m && C._isIgnoreNodeChange(z) || !m && (C.isTable(z) || C.isListCell(z) || C.isFormatElement(z) && !C.isFreeFormatElement(z))) {
          (C.isTable(z) || C.isListCell(z)) && E(z, t + 1, p);
          continue;
        }
        if (O === 1 && w.nodeName === z.nodeName && w.parentNode) {
          if (c) {
            let G, e, i, s, r;
            for (let f = 0; f < c; f++)
              if (G = l[f], G && G[t] === p) {
                for (e = z, i = w, s = t, r = !0; s >= 0; ) {
                  if (C.getArrayIndex(i.childNodes, e) !== G[s]) {
                    r = !1;
                    break;
                  }
                  e = z.parentNode, i = e.parentNode, s--;
                }
                r && (G.splice(t, 1), G[t] = p);
              }
          }
          C.copyTagAttributes(z, w), w.parentNode.insertBefore(z, w), C.removeItem(w);
        }
        if (!K) {
          z.nodeType === 1 && E(z, t + 1, p);
          break;
        }
        if (z.nodeName === K.nodeName && C.isSameAttributes(z, K) && z.href === K.href) {
          const G = z.childNodes;
          let e = 0;
          for (let f = 0, d = G.length; f < d; f++)
            G[f].textContent.length > 0 && e++;
          const i = z.lastChild, s = K.firstChild;
          let r = 0;
          if (i && s) {
            const f = i.nodeType === 3 && s.nodeType === 3;
            r = i.textContent.length;
            let d = i.previousSibling;
            for (; d && d.nodeType === 3; )
              r += d.textContent.length, d = d.previousSibling;
            if (e > 0 && i.nodeType === 3 && s.nodeType === 3 && (i.textContent.length > 0 || s.textContent.length > 0) && e--, c) {
              let o = null;
              for (let g = 0; g < c; g++)
                if (o = l[g], o && o[t] > p) {
                  if (t > 0 && o[t - 1] !== F)
                    continue;
                  o[t] -= 1, o[t + 1] >= 0 && o[t] === p && (o[t + 1] += e, f && i && i.nodeType === 3 && s && s.nodeType === 3 && (v[g] += r));
                }
            }
          }
          if (z.nodeType === 3) {
            if (r = z.textContent.length, z.textContent += K.textContent, c) {
              let f = null;
              for (let d = 0; d < c; d++)
                if (f = l[d], f && f[t] > p) {
                  if (t > 0 && f[t - 1] !== F)
                    continue;
                  f[t] -= 1, f[t + 1] >= 0 && f[t] === p && (f[t + 1] += e, v[d] += r);
                }
            }
          } else
            z.innerHTML += K.innerHTML;
          C.removeItem(K), p--;
        } else
          z.nodeType === 1 && E(z, t + 1, p);
      }
    }(n, 0, 0), v;
  },
  /**
   * @description Remove nested tags without other child nodes.
   * @param {Element} element Element object
   * @param {Function|String|null} validation Validation function / String("tag1|tag2..") / If null, all tags are applicable.
   */
  mergeNestedTags: function(n, l) {
    typeof l == "string" ? l = (function(m) {
      return this.test(m.tagName);
    }).bind(new this._w.RegExp("^(" + (l || ".+") + ")$", "i")) : typeof l != "function" && (l = function() {
      return !0;
    }), function m(C) {
      let c = C.children;
      if (c.length === 1 && c[0].nodeName === C.nodeName && l(C)) {
        const v = c[0];
        for (c = v.children; c[0]; )
          C.appendChild(c[0]);
        C.removeChild(v);
      }
      for (let v = 0, E = C.children.length; v < E; v++)
        m(C.children[v]);
    }(n);
  },
  /**
   * @description Delete a empty child node of argument element.
   * @param {Element} element Element node
   * @param {Node|null} notRemoveNode Do not remove node
   * @param {boolean} forceDelete When all child nodes are deleted, the parent node is also deleted.
   */
  removeEmptyNode: function(n, l, m) {
    const C = this;
    l && (l = C.getParentElement(l, function(c) {
      return n === c.parentElement;
    })), function c(v) {
      if (C._notTextNode(v) || v === l || C.isNonEditable(v))
        return 0;
      if (v !== n && C.onlyZeroWidthSpace(v.textContent) && (!v.firstChild || !C.isBreak(v.firstChild)) && !v.querySelector(C._allowedEmptyNodeList)) {
        if (v.parentNode)
          return v.parentNode.removeChild(v), -1;
      } else {
        const E = v.children;
        for (let w = 0, t = E.length, F = 0; w < t; w++)
          !E[w + F] || C.isComponent(E[w + F]) || (F += c(E[w + F]));
      }
      return 0;
    }(n), n.childNodes.length === 0 && (m ? this.removeItem(n) : n.innerHTML = "<br>");
  },
  /**
   * @description Remove whitespace between tags in HTML string.
   * @param {String} html HTML string
   * @returns {String}
   */
  htmlRemoveWhiteSpace: function(n) {
    return n ? n.trim().replace(/<\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)[^>^<]+>\s+(?=<)/ig, function(l) {
      return l.replace(/\n/g, "").replace(/\s+/, " ");
    }) : "";
  },
  /**
  * @description HTML code compression
  * @param {string} html HTML string
  * @returns {string} HTML string
  */
  htmlCompress: function(n) {
    return n.replace(/\n/g, "").replace(/(>)(?:\s+)(<)/g, "$1$2");
  },
  /**
   * @description Sort a element array by depth of element.
   * @param {Array} array Array object
   * @param {Boolean} des true: descending order / false: ascending order
   */
  sortByDepth: function(n, l) {
    const m = l ? 1 : -1, C = m * -1;
    n.sort((function(c, v) {
      return !this.isListCell(c) || !this.isListCell(v) ? 0 : (c = this.getElementDepth(c), v = this.getElementDepth(v), c > v ? m : c < v ? C : 0);
    }).bind(this));
  },
  _isExcludeSelectionElement: function(n) {
    return !/FIGCAPTION/i.test(n.nodeName) && (this.isComponent(n) || /FIGURE/i.test(n.nodeName));
  },
  /**
   * @description Nodes that need to be added without modification when changing text nodes
   * @param {Node} element Element to check
   * @returns {Boolean}
   * @private
   */
  _isIgnoreNodeChange: function(n) {
    return n && n.nodeType !== 3 && (this.isNonEditable(n) || !this.isTextStyleElement(n));
  },
  /**
   * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)
   * @param {Node|String} element Element to check
   * @returns {Boolean}
   * @private
   */
  _isMaintainedNode: function(n) {
    return n && n.nodeType !== 3 && /^(a|label|code|summary)$/i.test(typeof n == "string" ? n : n.nodeName);
  },
  /**
   * @description Node with font-size style
   * @param {Node} element Element to check
   * @returns {Boolean}
   * @private
   */
  _isSizeNode: function(n) {
    return n && n.nodeType !== 3 && this.isTextStyleElement(n) && !!n.style.fontSize;
  },
  /**
   * @description Nodes without text
   * @param {Node} element Element to check
   * @returns {Boolean}
   * @private
   */
  _notTextNode: function(n) {
    return n && n.nodeType !== 3 && (this.isComponent(n) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof n == "string" ? n : n.nodeName));
  },
  /**
   * @deprecated
   * @description Check disallowed tags
   * @param {Node} element Element to check
   * @returns {Boolean}
   * @private
   */
  _disallowedTags: function(n) {
    return /^(meta|script|link|style|[a-z]+\:[a-z]+)$/i.test(n.nodeName);
  },
  /**
   * @description Create whitelist RegExp object.
   * Return RegExp format: new RegExp("<\\/?\\b(?!" + list + ")\\b[^>^<]*+>", "gi")
   * @param {String} list Tags list ("br|p|div|pre...")
   * @returns {RegExp}
   */
  createTagsWhitelist: function(n) {
    return new RegExp("<\\/?\\b(?!\\b" + (n || "").replace(/\|/g, "\\b|\\b") + "\\b)[^>]*>", "gi");
  },
  /**
   * @description Create blacklist RegExp object.
   * Return RegExp format: new RegExp("<\\/?\\b(?:" + list + ")\\b[^>^<]*+>", "gi")
   * @param {String} list Tags list ("br|p|div|pre...")
   * @returns {RegExp}
   */
  createTagsBlacklist: function(n) {
    return new RegExp("<\\/?\\b(?:\\b" + (n || "^").replace(/\|/g, "\\b|\\b") + "\\b)[^>]*>", "gi");
  },
  /**
   * @description Fix tags that do not fit the editor format.
   * @param {Element} documentFragment Document fragment "DOCUMENT_FRAGMENT_NODE" (nodeType === 11)
   * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)
   * @param {RegExp} htmlCheckBlacklistRegExp Editor tags blacklist (core._htmlCheckBlacklistRegExp)
   * @param {Function} classNameFilter Class name filter function
   * @private
   */
  _consistencyCheckOfHTML: function(n, l, m, C) {
    const c = [], v = [], E = [], w = [], t = this.getListChildNodes(n, (function(a) {
      if (a.nodeType !== 1)
        return this.isList(a.parentElement) && c.push(a), !1;
      if (m.test(a.nodeName) || !l.test(a.nodeName) && a.childNodes.length === 0 && this.isNotCheckingNode(a))
        return c.push(a), !1;
      const p = !this.getParentElement(a, this.isNotCheckingNode);
      if (!this.isTable(a) && !this.isListCell(a) && !this.isAnchor(a) && (this.isFormatElement(a) || this.isRangeFormatElement(a) || this.isTextStyleElement(a)) && a.childNodes.length === 0 && p)
        return v.push(a), !1;
      if (this.isList(a.parentNode) && !this.isList(a) && !this.isListCell(a))
        return E.push(a), !1;
      if (this.isCell(a)) {
        const z = a.firstElementChild;
        if (!this.isFormatElement(z) && !this.isRangeFormatElement(z) && !this.isComponent(z))
          return w.push(a), !1;
      }
      if (p && a.className) {
        const z = new this._w.Array(a.classList).map(C).join(" ").trim();
        z ? a.className = z : a.removeAttribute("class");
      }
      return a.parentNode !== n && p && (this.isListCell(a) && !this.isList(a.parentNode) || (this.isFormatElement(a) || this.isComponent(a)) && !this.isRangeFormatElement(a.parentNode) && !this.getParentElement(a, this.isComponent));
    }).bind(this));
    for (let a = 0, p = c.length; a < p; a++)
      this.removeItem(c[a]);
    const F = [];
    for (let a = 0, p = t.length, O, z; a < p; a++)
      if (O = t[a], z = O.parentNode, !(!z || !z.parentNode))
        if (this.getParentElement(O, this.isListCell)) {
          const K = O.childNodes;
          for (let G = K.length - 1; p >= 0; G--)
            z.insertBefore(O, K[G]);
          F.push(O);
        } else
          z.parentNode.insertBefore(O, z), F.push(z);
    for (let a = 0, p = F.length, O; a < p; a++)
      O = F[a], this.onlyZeroWidthSpace(O.textContent.trim()) && this.removeItem(O);
    for (let a = 0, p = v.length; a < p; a++)
      this.removeItem(v[a]);
    for (let a = 0, p = E.length, O, z, K, G; a < p; a++)
      if (O = E[a], G = O.parentNode, !!G)
        if (z = this.createElement("LI"), this.isFormatElement(O)) {
          for (K = O.childNodes; K[0]; )
            z.appendChild(K[0]);
          G.insertBefore(z, O), this.removeItem(O);
        } else
          O = O.nextSibling, z.appendChild(E[a]), G.insertBefore(z, O);
    for (let a = 0, p = w.length, O, z; a < p; a++)
      O = w[a], z = this.createElement("DIV"), z.innerHTML = O.textContent.trim().length === 0 && O.children.length === 0 ? "<br>" : O.innerHTML, O.innerHTML = z.outerHTML;
  },
  _setDefaultOptionStyle: function(n, l) {
    let m = "";
    n.height && (m += "height:" + n.height + ";"), n.minHeight && (m += "min-height:" + n.minHeight + ";"), n.maxHeight && (m += "max-height:" + n.maxHeight + ";"), n.position && (m += "position:" + n.position + ";"), n.width && (m += "width:" + n.width + ";"), n.minWidth && (m += "min-width:" + n.minWidth + ";"), n.maxWidth && (m += "max-width:" + n.maxWidth + ";");
    let C = "", c = "", v = "";
    l = m + l;
    const E = l.split(";");
    for (let w = 0, t = E.length, F; w < t; w++)
      if (F = E[w].trim(), !!F) {
        if (/^(min-|max-)?width\s*:/.test(F) || /^(z-index|position)\s*:/.test(F)) {
          C += F + ";";
          continue;
        }
        if (/^(min-|max-)?height\s*:/.test(F)) {
          /^height/.test(F) && F.split(":")[1].trim() === "auto" && (n.height = "auto"), c += F + ";";
          continue;
        }
        v += F + ";";
      }
    return {
      top: C,
      frame: c,
      editor: v
    };
  },
  _setIframeDocument: function(n, l) {
    n.setAttribute("scrolling", "auto"), n.contentDocument.head.innerHTML = '<meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">' + this._setIframeCssTags(l), n.contentDocument.body.className = l._editableClass, n.contentDocument.body.setAttribute("contenteditable", !0);
  },
  _setIframeCssTags: function(n) {
    const l = n.iframeCSSFileName, m = this._w.RegExp;
    let C = "";
    for (let c = 0, v = l.length, E; c < v; c++) {
      if (E = [], /(^https?:\/\/)|(^data:text\/css,)/.test(l[c]))
        E.push(l[c]);
      else {
        const w = new m("(^|.*[\\/])" + l[c] + "(\\..+)?\\.css(?:\\?.*|;.*)?$", "i");
        for (let t = document.getElementsByTagName("link"), F = 0, a = t.length, p; F < a; F++)
          p = t[F].href.match(w), p && E.push(p[0]);
      }
      if (!E || E.length === 0)
        throw '[SUNEDITOR.constructor.iframe.fail] The suneditor CSS files installation path could not be automatically detected. Please set the option property "iframeCSSFileName" before creating editor instances.';
      for (let w = 0, t = E.length; w < t; w++)
        C += '<link href="' + E[w] + '" rel="stylesheet">';
    }
    return C + (n.height === "auto" ? `<style>
/** Iframe height auto */
body{height: min-content; overflow: hidden;}
</style>` : "");
  }
}, Ce = {
  /**
   * @description document create
   * @param {Element} element Textarea
   * @param {Object} options Options
   * @returns {Object}
   */
  init: function(n, l) {
    typeof l != "object" && (l = {});
    const m = document;
    this._initOptions(n, l);
    const C = m.createElement("DIV");
    C.className = "sun-editor" + (l.rtl ? " se-rtl" : ""), n.id && (C.id = "suneditor_" + n.id);
    const c = m.createElement("DIV");
    c.className = "se-container";
    const v = this._createToolBar(m, l.buttonList, l.plugins, l), E = v.element.cloneNode(!1);
    E.className += " se-toolbar-shadow", v.element.style.visibility = "hidden", v.pluginCallButtons.math && this._checkKatexMath(l.katex);
    const w = m.createElement("DIV");
    w.className = "se-arrow";
    const t = m.createElement("DIV");
    t.className = "se-toolbar-sticky-dummy";
    const F = m.createElement("DIV");
    F.className = "se-wrapper";
    const a = this._initElements(l, C, v.element, w), p = a.bottomBar, O = a.wysiwygFrame, z = a.placeholder;
    let K = a.codeView;
    const G = new MutationObserver(() => {
      let L = document.querySelector(".se-container"), k = document.querySelector(".se-toolbox"), N = L.offsetWidth, V = L.offsetHeight, M = 0;
      k == null ? M = 0 : M = k.offsetHeight;
      let D = document.querySelector(".se-wrapper-wysiwyg");
      D.style.height = (V - M).toString() + "px", D.style.width = N.toString() + "px";
    }), e = {
      attriblutes: !0,
      attributeFilter: ["style"]
    };
    G.observe(C, e);
    const i = p.resizingBar, s = p.navigation, r = p.charWrapper, f = p.charCounter, d = m.createElement("DIV");
    d.className = "se-loading-box sun-editor-common", d.innerHTML = '<div class="se-loading-effect"></div>';
    const o = m.createElement("DIV");
    o.className = "se-line-breaker", o.innerHTML = '<button class="se-btn">' + l.icons.line_break + "</button>";
    const g = m.createElement("DIV");
    g.className += "se-line-breaker-component";
    const u = g.cloneNode(!0);
    g.innerHTML = u.innerHTML = l.icons.line_break;
    const h = m.createElement("DIV");
    h.className = "se-resizing-back";
    const y = l.toolbarContainer;
    y && (y.appendChild(v.element), y.appendChild(E));
    const T = l.resizingBarContainer;
    return i && T && T.appendChild(i), F.appendChild(K), z && F.appendChild(z), y || (c.appendChild(v.element), c.appendChild(E)), c.appendChild(t), c.appendChild(F), c.appendChild(h), c.appendChild(d), c.appendChild(o), c.appendChild(g), c.appendChild(u), i && !T && c.appendChild(i), C.appendChild(c), K = this._checkCodeMirror(l, K), {
      constructed: {
        _top: C,
        _relative: c,
        _toolBar: v.element,
        _toolbarShadow: E,
        _menuTray: v._menuTray,
        _editorArea: F,
        _wysiwygArea: O,
        _codeArea: K,
        _placeholder: z,
        _resizingBar: i,
        _navigation: s,
        _charWrapper: r,
        _charCounter: f,
        _loading: d,
        _lineBreaker: o,
        _lineBreaker_t: g,
        _lineBreaker_b: u,
        _resizeBack: h,
        _stickyDummy: t,
        _arrow: w
      },
      options: l,
      plugins: v.plugins,
      pluginCallButtons: v.pluginCallButtons,
      _responsiveButtons: v.responsiveButtons
    };
  },
  /**
   * @description Check the CodeMirror option to apply the CodeMirror and return the CodeMirror element.
   * @param {Object} options options
   * @param {Element} textarea textarea element
   * @private
   */
  _checkCodeMirror: function(n, l) {
    if (n.codeMirror) {
      const m = [{
        mode: "htmlmixed",
        htmlMode: !0,
        lineNumbers: !0,
        lineWrapping: !0
      }, n.codeMirror.options || {}].reduce(function(c, v) {
        for (let E in v)
          q.hasOwn(v, E) && (c[E] = v[E]);
        return c;
      }, {});
      n.height === "auto" && (m.viewportMargin = 1 / 0, m.height = "auto");
      const C = n.codeMirror.src.fromTextArea(l, m);
      C.display.wrapper.style.cssText = l.style.cssText, n.codeMirrorEditor = C, l = C.display.wrapper, l.className += " se-wrapper-code-mirror";
    }
    return l;
  },
  /**
   * @description Check for a katex object.
   * @param {Object} katex katex object
   * @private
   */
  _checkKatexMath: function(n) {
    if (!n)
      throw Error('[SUNEDITOR.create.fail] To use the math button you need to add a "katex" object to the options.');
    const l = [{
      throwOnError: !1
    }, n.options || {}].reduce(function(m, C) {
      for (let c in C)
        q.hasOwn(C, c) && (m[c] = C[c]);
      return m;
    }, {});
    n.options = l;
  },
  /**
   * @description Add or reset options
   * @param {Object} mergeOptions New options property
   * @param {Object} context Context object of core
   * @param {Object} originOptions Origin options
   * @returns {Object} pluginCallButtons
   * @private
   */
  _setOptions: function(n, l, m) {
    this._initOptions(l.element.originElement, n);
    const C = l.element, c = C.relative, v = C.editorArea, E = n.toolbarContainer && n.toolbarContainer !== m.toolbarContainer, w = n.lang !== m.lang || n.buttonList !== m.buttonList || n.mode !== m.mode || E, t = this._createToolBar(document, w ? n.buttonList : m.buttonList, n.plugins, n);
    t.pluginCallButtons.math && this._checkKatexMath(n.katex);
    const F = document.createElement("DIV");
    F.className = "se-arrow", w && (t.element.style.visibility = "hidden", E ? (n.toolbarContainer.appendChild(t.element), C.toolbar.parentElement.removeChild(C.toolbar)) : C.toolbar.parentElement.replaceChild(t.element, C.toolbar), C.toolbar = t.element, C._menuTray = t._menuTray, C._arrow = F);
    const a = this._initElements(n, C.topArea, w ? t.element : C.toolbar, F), p = a.bottomBar, O = a.wysiwygFrame, z = a.placeholder;
    let K = a.codeView;
    return C.resizingBar && q.removeItem(C.resizingBar), p.resizingBar && (n.resizingBarContainer && n.resizingBarContainer !== m.resizingBarContainer ? n.resizingBarContainer.appendChild(p.resizingBar) : c.appendChild(p.resizingBar)), v.innerHTML = "", v.appendChild(K), z && v.appendChild(z), K = this._checkCodeMirror(n, K), C.resizingBar = p.resizingBar, C.navigation = p.navigation, C.charWrapper = p.charWrapper, C.charCounter = p.charCounter, C.wysiwygFrame = O, C.code = K, C.placeholder = z, n.rtl ? q.addClass(C.topArea, "se-rtl") : q.removeClass(C.topArea, "se-rtl"), {
      callButtons: t.pluginCallButtons,
      plugins: t.plugins,
      toolbar: t
    };
  },
  /**
   * @description Initialize property of suneditor elements
   * @param {Object} options Options
   * @param {Element} topDiv Suneditor top div
   * @param {Element} toolBar Tool bar
   * @param {Element} toolBarArrow Tool bar arrow (balloon editor)
   * @returns {Object} Bottom bar elements (resizingBar, navigation, charWrapper, charCounter)
   * @private
   */
  _initElements: function(n, l, m, C) {
    l.style.cssText = n._editorStyles.top, /inline/i.test(n.mode) ? (m.className += " se-toolbar-inline", m.style.width = n.toolbarWidth) : /balloon/i.test(n.mode) && (m.className += " se-toolbar-balloon", m.style.width = n.toolbarWidth, m.appendChild(C));
    const c = document.createElement(n.iframe ? "IFRAME" : "DIV");
    if (c.className = "se-wrapper-inner se-wrapper-wysiwyg", n.iframe)
      c.allowFullscreen = !0, c.frameBorder = 0, c.style.cssText = n._editorStyles.frame, c.className += n.className;
    else {
      c.setAttribute("contenteditable", !0), c.setAttribute("scrolling", "auto");
      for (let p in n.iframeAttributes)
        c.setAttribute(p, n.iframeAttributes[p]);
      c.className += " " + n._editableClass, c.style.cssText = n._editorStyles.frame + n._editorStyles.editor, c.className += n.className;
    }
    const v = document.createElement("TEXTAREA");
    v.className = "se-wrapper-inner se-wrapper-code" + n.className, v.style.cssText = n._editorStyles.frame, v.style.display = "none", n.height === "auto" && (v.style.overflow = "hidden");
    let E = null, w = null, t = null, F = null;
    if (n.resizingBar && (E = document.createElement("DIV"), E.className = "se-resizing-bar sun-editor-common", w = document.createElement("DIV"), w.className = "se-navigation sun-editor-common", E.appendChild(w), n.charCounter)) {
      if (t = document.createElement("DIV"), t.className = "se-char-counter-wrapper", n.charCounterLabel) {
        const p = document.createElement("SPAN");
        p.className = "se-char-label", p.textContent = n.charCounterLabel, t.appendChild(p);
      }
      if (F = document.createElement("SPAN"), F.className = "se-char-counter", F.textContent = "0", t.appendChild(F), n.maxCharCount > 0) {
        const p = document.createElement("SPAN");
        p.textContent = " / " + n.maxCharCount, t.appendChild(p);
      }
      E.appendChild(t);
    }
    let a = null;
    return n.placeholder && (a = document.createElement("SPAN"), a.className = "se-placeholder", a.innerText = n.placeholder), {
      bottomBar: {
        resizingBar: E,
        navigation: w,
        charWrapper: t,
        charCounter: F
      },
      wysiwygFrame: c,
      codeView: v,
      placeholder: a
    };
  },
  /**
   * @description Initialize options
   * @param {Element} element Options object
   * @param {Object} options Options object
   * @private
   */
  _initOptions: function(n, l) {
    const m = {};
    if (l.plugins) {
      const v = l.plugins, E = v.length ? v : Object.keys(v).map(function(w) {
        return v[w];
      });
      for (let w = 0, t = E.length, F; w < t; w++)
        F = E[w].default || E[w], m[F.name] = F;
    }
    l.plugins = m, l.lang = l.lang || Te, l.value = typeof l.value == "string" ? l.value : null, l.allowedClassNames = new q._w.RegExp((l.allowedClassNames && typeof l.allowedClassNames == "string" ? l.allowedClassNames + "|" : "") + "^__se__|se-|katex"), l.historyStackDelayTime = typeof l.historyStackDelayTime == "number" ? l.historyStackDelayTime : 400, l.frameAttrbutes = l.frameAttrbutes || {}, l.defaultTag = typeof l.defaultTag == "string" && l.defaultTag.length > 0 ? l.defaultTag : "p";
    const C = l.textTags = [{ bold: "STRONG", underline: "U", italic: "EM", strike: "DEL", sub: "SUB", sup: "SUP" }, l.textTags || {}].reduce(function(v, E) {
      for (let w in E)
        v[w] = E[w];
      return v;
    }, {});
    l._textTagsMap = {
      strong: C.bold.toLowerCase(),
      b: C.bold.toLowerCase(),
      u: C.underline.toLowerCase(),
      ins: C.underline.toLowerCase(),
      em: C.italic.toLowerCase(),
      i: C.italic.toLowerCase(),
      del: C.strike.toLowerCase(),
      strike: C.strike.toLowerCase(),
      s: C.strike.toLowerCase(),
      sub: C.sub.toLowerCase(),
      sup: C.sup.toLowerCase()
    }, l._defaultCommand = {
      bold: l.textTags.bold,
      underline: l.textTags.underline,
      italic: l.textTags.italic,
      strike: l.textTags.strike,
      subscript: l.textTags.sub,
      superscript: l.textTags.sup
    }, l.__allowedScriptTag = l.__allowedScriptTag === !0;
    const c = "br|p|div|pre|blockquote|h1|h2|h3|h4|h5|h6|ol|ul|li|hr|figure|figcaption|img|iframe|audio|video|source|table|thead|tbody|tr|th|td|a|b|strong|var|i|em|u|ins|s|span|strike|del|sub|sup|code|svg|path|details|summary";
    l.tagsBlacklist = l.tagsBlacklist || "", l._defaultTagsWhitelist = (typeof l._defaultTagsWhitelist == "string" ? l._defaultTagsWhitelist : c) + (l.__allowedScriptTag ? "|script" : ""), l._editorTagsWhitelist = l.addTagsWhitelist === "*" ? "*" : this._setWhitelist(l._defaultTagsWhitelist + (typeof l.addTagsWhitelist == "string" && l.addTagsWhitelist.length > 0 ? "|" + l.addTagsWhitelist : ""), l.tagsBlacklist), l.pasteTagsBlacklist = l.tagsBlacklist + (l.tagsBlacklist && l.pasteTagsBlacklist ? "|" + l.pasteTagsBlacklist : l.pasteTagsBlacklist || ""), l.pasteTagsWhitelist = l.pasteTagsWhitelist === "*" ? "*" : this._setWhitelist(typeof l.pasteTagsWhitelist == "string" ? l.pasteTagsWhitelist : l._editorTagsWhitelist, l.pasteTagsBlacklist), l.attributesWhitelist = !l.attributesWhitelist || typeof l.attributesWhitelist != "object" ? null : l.attributesWhitelist, l.attributesBlacklist = !l.attributesBlacklist || typeof l.attributesBlacklist != "object" ? null : l.attributesBlacklist, l.mode = l.mode || "classic", l.rtl = !!l.rtl, l.lineAttrReset = ["id"].concat(l.lineAttrReset && typeof l.lineAttrReset == "string" ? l.lineAttrReset.toLowerCase().split("|") : []), l._editableClass = "sun-editor-editable" + (l.rtl ? " se-rtl" : ""), l._printClass = typeof l._printClass == "string" ? l._printClass : null, l.toolbarWidth = l.toolbarWidth ? q.isNumber(l.toolbarWidth) ? l.toolbarWidth + "px" : l.toolbarWidth : "auto", l.toolbarContainer = typeof l.toolbarContainer == "string" ? document.querySelector(l.toolbarContainer) : l.toolbarContainer, l.stickyToolbar = /balloon/i.test(l.mode) || l.toolbarContainer ? -1 : l.stickyToolbar === void 0 ? 0 : /^\d+/.test(l.stickyToolbar) ? q.getNumber(l.stickyToolbar, 0) : -1, l.hideToolbar = !!l.hideToolbar, l.fullScreenOffset = l.fullScreenOffset === void 0 ? 0 : /^\d+/.test(l.fullScreenOffset) ? q.getNumber(l.fullScreenOffset, 0) : 0, l.fullPage = !!l.fullPage, l.iframe = l.fullPage || !!l.iframe, l.iframeAttributes = l.iframeAttributes || {}, l.iframeCSSFileName = l.iframe ? typeof l.iframeCSSFileName == "string" ? [l.iframeCSSFileName] : l.iframeCSSFileName || ["suneditor"] : null, l.previewTemplate = typeof l.previewTemplate == "string" ? l.previewTemplate : null, l.printTemplate = typeof l.printTemplate == "string" ? l.printTemplate : null, l.codeMirror = l.codeMirror ? l.codeMirror.src ? l.codeMirror : { src: l.codeMirror } : null, l.katex = l.katex ? l.katex.src ? l.katex : { src: l.katex } : null, l.mathFontSize = l.mathFontSize ? l.mathFontSize : [
      { text: "1", value: "1em" },
      { text: "1.5", value: "1.5em" },
      { text: "2", value: "2em" },
      { text: "2.5", value: "2.5em" }
    ], l.position = typeof l.position == "string" ? l.position : null, l.display = l.display || (n.style.display === "none" || !n.style.display ? "block" : n.style.display), l.popupDisplay = l.popupDisplay || "full", l.resizingBar = l.resizingBar === void 0 ? !/inline|balloon/i.test(l.mode) : l.resizingBar, l.showPathLabel = l.resizingBar ? typeof l.showPathLabel == "boolean" ? l.showPathLabel : !0 : !1, l.resizeEnable = l.resizeEnable === void 0 ? !0 : !!l.resizeEnable, l.resizingBarContainer = typeof l.resizingBarContainer == "string" ? document.querySelector(l.resizingBarContainer) : l.resizingBarContainer, l.charCounter = l.maxCharCount > 0 ? !0 : typeof l.charCounter == "boolean" ? l.charCounter : !1, l.charCounterType = typeof l.charCounterType == "string" ? l.charCounterType : "char", l.charCounterLabel = typeof l.charCounterLabel == "string" ? l.charCounterLabel.trim() : null, l.maxCharCount = q.isNumber(l.maxCharCount) && l.maxCharCount > -1 ? l.maxCharCount * 1 : null, l.width = l.width ? q.isNumber(l.width) ? l.width + "px" : l.width : n.clientWidth ? n.clientWidth + "px" : "100%", l.minWidth = (q.isNumber(l.minWidth) ? l.minWidth + "px" : l.minWidth) || "", l.maxWidth = (q.isNumber(l.maxWidth) ? l.maxWidth + "px" : l.maxWidth) || "", l.height = l.height ? q.isNumber(l.height) ? l.height + "px" : l.height : n.clientHeight ? n.clientHeight + "px" : "auto", l.minHeight = (q.isNumber(l.minHeight) ? l.minHeight + "px" : l.minHeight) || "", l.maxHeight = (q.isNumber(l.maxHeight) ? l.maxHeight + "px" : l.maxHeight) || "", l.className = typeof l.className == "string" && l.className.length > 0 ? " " + l.className : "", l.defaultStyle = typeof l.defaultStyle == "string" ? l.defaultStyle : "", l.font = l.font ? l.font : ["Arial", "Comic Sans MS", "Courier New", "Impact", "Georgia", "tahoma", "Trebuchet MS", "Verdana"], l.fontSize = l.fontSize ? l.fontSize : null, l.formats = l.formats ? l.formats : null, l.colorList = l.colorList ? l.colorList : null, l.lineHeights = l.lineHeights ? l.lineHeights : null, l.paragraphStyles = l.paragraphStyles ? l.paragraphStyles : null, l.textStyles = l.textStyles ? l.textStyles : null, l.fontSizeUnit = typeof l.fontSizeUnit == "string" && l.fontSizeUnit.trim().toLowerCase() || "px", l.alignItems = typeof l.alignItems == "object" ? l.alignItems : l.rtl ? ["right", "center", "left", "justify"] : ["left", "center", "right", "justify"], l.imageResizing = l.imageResizing === void 0 ? !0 : l.imageResizing, l.imageHeightShow = l.imageHeightShow === void 0 ? !0 : !!l.imageHeightShow, l.imageAlignShow = l.imageAlignShow === void 0 ? !0 : !!l.imageAlignShow, l.imageWidth = l.imageWidth ? q.isNumber(l.imageWidth) ? l.imageWidth + "px" : l.imageWidth : "auto", l.imageHeight = l.imageHeight ? q.isNumber(l.imageHeight) ? l.imageHeight + "px" : l.imageHeight : "auto", l.imageSizeOnlyPercentage = !!l.imageSizeOnlyPercentage, l._imageSizeUnit = l.imageSizeOnlyPercentage ? "%" : "px", l.imageRotation = l.imageRotation !== void 0 ? l.imageRotation : !(l.imageSizeOnlyPercentage || !l.imageHeightShow), l.imageFileInput = l.imageFileInput === void 0 ? !0 : l.imageFileInput, l.imageUrlInput = l.imageUrlInput === void 0 || !l.imageFileInput ? !0 : l.imageUrlInput, l.imageUploadHeader = l.imageUploadHeader || null, l.imageUploadUrl = typeof l.imageUploadUrl == "string" ? l.imageUploadUrl : null, l.imageUploadSizeLimit = /\d+/.test(l.imageUploadSizeLimit) ? q.getNumber(l.imageUploadSizeLimit, 0) : null, l.imageMultipleFile = !!l.imageMultipleFile, l.imageAccept = typeof l.imageAccept != "string" || l.imageAccept.trim() === "*" ? "image/*" : l.imageAccept.trim() || "image/*", l.imageGalleryUrl = typeof l.imageGalleryUrl == "string" ? l.imageGalleryUrl : null, l.imageGalleryHeader = l.imageGalleryHeader || null, l.videoResizing = l.videoResizing === void 0 ? !0 : l.videoResizing, l.videoHeightShow = l.videoHeightShow === void 0 ? !0 : !!l.videoHeightShow, l.videoAlignShow = l.videoAlignShow === void 0 ? !0 : !!l.videoAlignShow, l.videoRatioShow = l.videoRatioShow === void 0 ? !0 : !!l.videoRatioShow, l.videoWidth = !l.videoWidth || !q.getNumber(l.videoWidth, 0) ? "" : q.isNumber(l.videoWidth) ? l.videoWidth + "px" : l.videoWidth, l.videoHeight = !l.videoHeight || !q.getNumber(l.videoHeight, 0) ? "" : q.isNumber(l.videoHeight) ? l.videoHeight + "px" : l.videoHeight, l.videoSizeOnlyPercentage = !!l.videoSizeOnlyPercentage, l._videoSizeUnit = l.videoSizeOnlyPercentage ? "%" : "px", l.videoRotation = l.videoRotation !== void 0 ? l.videoRotation : !(l.videoSizeOnlyPercentage || !l.videoHeightShow), l.videoRatio = q.getNumber(l.videoRatio, 4) || 0.5625, l.videoRatioList = l.videoRatioList ? l.videoRatioList : null, l.youtubeQuery = (l.youtubeQuery || "").replace("?", ""), l.videoFileInput = !!l.videoFileInput, l.videoUrlInput = l.videoUrlInput === void 0 || !l.videoFileInput ? !0 : l.videoUrlInput, l.videoUploadHeader = l.videoUploadHeader || null, l.videoUploadUrl = typeof l.videoUploadUrl == "string" ? l.videoUploadUrl : null, l.videoUploadSizeLimit = /\d+/.test(l.videoUploadSizeLimit) ? q.getNumber(l.videoUploadSizeLimit, 0) : null, l.videoMultipleFile = !!l.videoMultipleFile, l.videoTagAttrs = l.videoTagAttrs || null, l.videoIframeAttrs = l.videoIframeAttrs || null, l.videoAccept = typeof l.videoAccept != "string" || l.videoAccept.trim() === "*" ? "video/*" : l.videoAccept.trim() || "video/*", l.audioWidth = l.audioWidth ? q.isNumber(l.audioWidth) ? l.audioWidth + "px" : l.audioWidth : "", l.audioHeight = l.audioHeight ? q.isNumber(l.audioHeight) ? l.audioHeight + "px" : l.audioHeight : "", l.audioFileInput = !!l.audioFileInput, l.audioUrlInput = l.audioUrlInput === void 0 || !l.audioFileInput ? !0 : l.audioUrlInput, l.audioUploadHeader = l.audioUploadHeader || null, l.audioUploadUrl = typeof l.audioUploadUrl == "string" ? l.audioUploadUrl : null, l.audioUploadSizeLimit = /\d+/.test(l.audioUploadSizeLimit) ? q.getNumber(l.audioUploadSizeLimit, 0) : null, l.audioMultipleFile = !!l.audioMultipleFile, l.audioTagAttrs = l.audioTagAttrs || null, l.audioAccept = typeof l.audioAccept != "string" || l.audioAccept.trim() === "*" ? "audio/*" : l.audioAccept.trim() || "audio/*", l.tableCellControllerPosition = typeof l.tableCellControllerPosition == "string" ? l.tableCellControllerPosition.toLowerCase() : "cell", l.linkTargetNewWindow = !!l.linkTargetNewWindow, l.linkProtocol = typeof l.linkProtocol == "string" ? l.linkProtocol : null, l.linkRel = Array.isArray(l.linkRel) ? l.linkRel : [], l.linkRelDefault = l.linkRelDefault || {}, l.tabDisable = !!l.tabDisable, l.shortcutsDisable = Array.isArray(l.shortcutsDisable) ? l.shortcutsDisable : [], l.shortcutsHint = l.shortcutsHint === void 0 ? !0 : !!l.shortcutsHint, l.callBackSave = l.callBackSave ? l.callBackSave : null, l.templates = l.templates ? l.templates : null, l.placeholder = typeof l.placeholder == "string" ? l.placeholder : null, l.mediaAutoSelect = l.mediaAutoSelect === void 0 ? !0 : !!l.mediaAutoSelect, l.buttonList = l.buttonList ? l.buttonList : [
      ["undo", "redo"],
      ["bold", "underline", "italic", "strike", "subscript", "superscript"],
      ["removeFormat"],
      ["outdent", "indent"],
      ["fullScreen", "showBlocks", "codeView"],
      ["preview", "print"]
    ], l.rtl && (l.buttonList = l.buttonList.reverse()), l.icons = !l.icons || typeof l.icons != "object" ? _e : [_e, l.icons].reduce(function(v, E) {
      for (let w in E)
        q.hasOwn(E, w) && (v[w] = E[w]);
      return v;
    }, {}), l.icons = l.rtl ? [l.icons, l.icons.rtl].reduce(function(v, E) {
      for (let w in E)
        q.hasOwn(E, w) && (v[w] = E[w]);
      return v;
    }, {}) : l.icons, l.__listCommonStyle = l.__listCommonStyle || ["fontSize", "color", "fontFamily", "fontWeight", "fontStyle"], l._editorStyles = q._setDefaultOptionStyle(l, l.defaultStyle);
  },
  _setWhitelist: function(n, l) {
    if (typeof l != "string")
      return n;
    l = l.split("|"), n = n.split("|");
    for (let m = 0, C = l.length, c; m < C; m++)
      c = n.indexOf(l[m]), c > -1 && n.splice(c, 1);
    return n.join("|");
  },
  /**
   * @description Suneditor's Default button list
   * @param {Object} options options
   * @private
   */
  _defaultButtons: function(n) {
    const l = n.icons, m = n.lang, C = q.isOSX_IOS ? "⌘" : "CTRL", c = q.isOSX_IOS ? "⇧" : "+SHIFT", v = n.shortcutsHint ? n.shortcutsDisable : ["bold", "strike", "underline", "italic", "undo", "indent", "save"], E = n.rtl ? ["[", "]"] : ["]", "["], w = n.rtl ? [l.outdent, l.indent] : [l.indent, l.outdent];
    return {
      /** default command */
      bold: ["", m.toolbar.bold + '<span class="se-shortcut">' + (v.indexOf("bold") > -1 ? "" : C + '+<span class="se-shortcut-key">B</span>') + "</span>", "bold", "", l.bold],
      underline: ["", m.toolbar.underline + '<span class="se-shortcut">' + (v.indexOf("underline") > -1 ? "" : C + '+<span class="se-shortcut-key">U</span>') + "</span>", "underline", "", l.underline],
      italic: ["", m.toolbar.italic + '<span class="se-shortcut">' + (v.indexOf("italic") > -1 ? "" : C + '+<span class="se-shortcut-key">I</span>') + "</span>", "italic", "", l.italic],
      strike: ["", m.toolbar.strike + '<span class="se-shortcut">' + (v.indexOf("strike") > -1 ? "" : C + c + '+<span class="se-shortcut-key">S</span>') + "</span>", "strike", "", l.strike],
      subscript: ["", m.toolbar.subscript, "SUB", "", l.subscript],
      superscript: ["", m.toolbar.superscript, "SUP", "", l.superscript],
      removeFormat: ["", m.toolbar.removeFormat, "removeFormat", "", l.erase],
      indent: ["", m.toolbar.indent + '<span class="se-shortcut">' + (v.indexOf("indent") > -1 ? "" : C + '+<span class="se-shortcut-key">' + E[0] + "</span>") + "</span>", "indent", "", w[0]],
      outdent: ["", m.toolbar.outdent + '<span class="se-shortcut">' + (v.indexOf("indent") > -1 ? "" : C + '+<span class="se-shortcut-key">' + E[1] + "</span>") + "</span>", "outdent", "", w[1]],
      fullScreen: ["se-code-view-enabled se-resizing-enabled", m.toolbar.fullScreen, "fullScreen", "", l.expansion],
      showBlocks: ["", m.toolbar.showBlocks, "showBlocks", "", l.show_blocks],
      codeView: ["se-code-view-enabled se-resizing-enabled", m.toolbar.codeView, "codeView", "", l.code_view],
      undo: ["", m.toolbar.undo + '<span class="se-shortcut">' + (v.indexOf("undo") > -1 ? "" : C + '+<span class="se-shortcut-key">Z</span>') + "</span>", "undo", "", l.undo],
      redo: ["", m.toolbar.redo + '<span class="se-shortcut">' + (v.indexOf("undo") > -1 ? "" : C + '+<span class="se-shortcut-key">Y</span> / ' + C + c + '+<span class="se-shortcut-key">Z</span>') + "</span>", "redo", "", l.redo],
      preview: ["se-resizing-enabled", m.toolbar.preview, "preview", "", l.preview],
      print: ["se-resizing-enabled", m.toolbar.print, "print", "", l.print],
      dir: ["", m.toolbar[n.rtl ? "dir_ltr" : "dir_rtl"], "dir", "", l[n.rtl ? "dir_ltr" : "dir_rtl"]],
      dir_ltr: ["", m.toolbar.dir_ltr, "dir_ltr", "", l.dir_ltr],
      dir_rtl: ["", m.toolbar.dir_rtl, "dir_rtl", "", l.dir_rtl],
      save: ["se-resizing-enabled", m.toolbar.save + '<span class="se-shortcut">' + (v.indexOf("save") > -1 ? "" : C + '+<span class="se-shortcut-key">S</span>') + "</span>", "save", "", l.save],
      /** plugins - command */
      blockquote: ["", m.toolbar.tag_blockquote, "blockquote", "command", l.blockquote],
      /** plugins - submenu */
      font: ["se-btn-select se-btn-tool-font", m.toolbar.font, "font", "submenu", '<span class="txt">' + m.toolbar.font + "</span>" + l.arrow_down],
      formatBlock: ["se-btn-select se-btn-tool-format", m.toolbar.formats, "formatBlock", "submenu", '<span class="txt">' + m.toolbar.formats + "</span>" + l.arrow_down],
      fontSize: ["se-btn-select se-btn-tool-size", m.toolbar.fontSize, "fontSize", "submenu", '<span class="txt">' + m.toolbar.fontSize + "</span>" + l.arrow_down],
      fontColor: ["", m.toolbar.fontColor, "fontColor", "submenu", l.font_color],
      hiliteColor: ["", m.toolbar.hiliteColor, "hiliteColor", "submenu", l.highlight_color],
      align: ["se-btn-align", m.toolbar.align, "align", "submenu", n.rtl ? l.align_right : l.align_left],
      list: ["", m.toolbar.list, "list", "submenu", l.list_number],
      horizontalRule: ["btn_line", m.toolbar.horizontalRule, "horizontalRule", "submenu", l.horizontal_rule],
      table: ["", m.toolbar.table, "table", "submenu", l.table],
      lineHeight: ["", m.toolbar.lineHeight, "lineHeight", "submenu", l.line_height],
      template: ["", m.toolbar.template, "template", "submenu", l.template],
      paragraphStyle: ["", m.toolbar.paragraphStyle, "paragraphStyle", "submenu", l.paragraph_style],
      textStyle: ["", m.toolbar.textStyle, "textStyle", "submenu", l.text_style],
      /** plugins - dialog */
      link: ["", m.toolbar.link, "link", "dialog", l.link],
      image: ["", m.toolbar.image, "image", "dialog", l.image],
      video: ["", m.toolbar.video, "video", "dialog", l.video],
      audio: ["", m.toolbar.audio, "audio", "dialog", l.audio],
      math: ["", m.toolbar.math, "math", "dialog", l.math],
      /** plugins - fileBrowser */
      imageGallery: ["", m.toolbar.imageGallery, "imageGallery", "fileBrowser", l.image_gallery]
    };
  },
  /**
   * @description Create a group div containing each module
   * @returns {Object}
   * @private
   */
  _createModuleGroup: function() {
    const n = q.createElement("DIV");
    n.className = "se-btn-module se-btn-module-border";
    const l = q.createElement("UL");
    return l.className = "se-menu-list", n.appendChild(l), {
      div: n,
      ul: l
    };
  },
  /**
   * @description Create a button element
   * @param {string} buttonClass className in button
   * @param {string} title Title in button
   * @param {string} dataCommand The data-command property of the button
   * @param {string} dataDisplay The data-display property of the button ('dialog', 'submenu', 'command')
   * @param {string} innerHTML Html in button
   * @param {string} _disabled Button disabled
   * @param {Object} _icons Icons
   * @returns {Object}
   * @private
   */
  _createButton: function(n, l, m, C, c, v, E) {
    const w = q.createElement("LI"), t = q.createElement("BUTTON"), F = l || m;
    return t.setAttribute("type", "button"), t.setAttribute("class", "se-btn" + (n ? " " + n : "") + " se-tooltip"), t.setAttribute("data-command", m), t.setAttribute("data-display", C), t.setAttribute("aria-label", F.replace(/<span .+<\/span>/, "")), t.setAttribute("tabindex", "-1"), c || (c = '<span class="se-icon-text">!</span>'), /^default\./i.test(c) && (c = E[c.replace(/^default\./i, "")]), /^text\./i.test(c) && (c = c.replace(/^text\./i, ""), t.className += " se-btn-more-text"), c += '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + F + "</span></span>", v && t.setAttribute("disabled", !0), t.innerHTML = c, w.appendChild(t), {
      li: w,
      button: t
    };
  },
  /**
   * @description Create editor HTML
   * @param {Array} doc document object
   * @param {Array} buttonList option.buttonList
   * @param {Object|null} plugins Plugins
   * @param {Array} options options
   * @returns {Object} { element: (Element) Toolbar element, plugins: (Array|null) Plugins Array, pluginCallButtons: (Object), responsiveButtons: (Array) }
   * @private
   */
  _createToolBar: function(n, l, m, C) {
    const c = n.createElement("DIV");
    c.className = "se-toolbar-separator-vertical";
    const v = n.createElement("DIV");
    v.className = "se-toolbar sun-editor-common";
    const E = n.createElement("DIV");
    E.className = "se-btn-tray", v.appendChild(E), l = JSON.parse(JSON.stringify(l));
    const w = C.icons, t = this._defaultButtons(C), F = {}, a = [];
    let p = null, O = null, z = null, K = null, G = "", e = !1;
    const i = q.createElement("DIV");
    i.className = "se-toolbar-more-layer";
    e:
      for (let f = 0, d, o, g, u, h; f < l.length; f++)
        if (d = !1, h = "", u = l[f], z = this._createModuleGroup(), typeof u == "object") {
          for (let y = 0, T; y < u.length; y++) {
            if (O = u[y], T = !1, /^\%\d+/.test(O) && y === 0) {
              u[0] = O.replace(/[^\d]/g, ""), a.push(u), l.splice(f--, 1);
              continue e;
            }
            if (typeof O == "object")
              typeof O.add == "function" ? (G = O.name, p = t[G], m[G] = O) : (G = O.name, p = [O.buttonClass, O.title, O.name, O.dataDisplay, O.innerHTML, O._disabled]);
            else {
              if (/^\-/.test(O)) {
                h = O.substr(1), z.div.className += " module-float-" + h;
                continue;
              }
              if (/^\#/.test(O)) {
                O.substr(1) === "fix" && (z.ul.className += " se-menu-dir-fix");
                continue;
              }
              if (/^\:/.test(O)) {
                T = !0;
                const L = O.match(/^\:([^\-]+)\-([^\-]+)\-([^\-]+)/);
                g = "__se__" + L[1].trim();
                const k = L[2].trim(), N = L[3].trim();
                p = ["se-btn-more", k, g, "MORE", N];
              } else
                p = t[O];
              if (G = O, !p) {
                const L = m[G];
                if (!L)
                  throw Error("[SUNEDITOR.create.toolbar.fail] The button name of a plugin that does not exist. [" + G + "]");
                p = [L.buttonClass, L.title, L.name, L.display, L.innerHTML, L._disabled];
              }
            }
            K = this._createButton(p[0], p[1], p[2], p[3], p[4], p[5], w), (d ? o : z.ul).appendChild(K.li), m[G] && (F[G] = K.button), T && (d = !0, o = q.createElement("DIV"), o.className = "se-more-layer " + g, o.innerHTML = '<div class="se-more-form"><ul class="se-menu-list"' + (h ? ' style="float: ' + h + ';"' : "") + "></ul></div>", i.appendChild(o), o = o.firstElementChild.firstElementChild);
          }
          if (e) {
            const y = c.cloneNode(!1);
            E.appendChild(y);
          }
          E.appendChild(z.div), e = !0;
        } else if (/^\/$/.test(u)) {
          const y = n.createElement("DIV");
          y.className = "se-btn-module-enter", E.appendChild(y), e = !1;
        }
    switch (E.children.length) {
      case 0:
        E.style.display = "none";
        break;
      case 1:
        q.removeClass(E.firstElementChild, "se-btn-module-border");
        break;
      default:
        if (C.rtl) {
          const f = c.cloneNode(!1);
          f.style.float = E.lastElementChild.style.float, E.appendChild(f);
        }
    }
    a.length > 0 && a.unshift(l), i.children.length > 0 && E.appendChild(i);
    const s = n.createElement("DIV");
    s.className = "se-menu-tray", v.appendChild(s);
    const r = n.createElement("DIV");
    return r.className = "se-toolbar-cover", v.appendChild(r), C.hideToolbar && (v.style.display = "none"), {
      element: v,
      plugins: m,
      pluginCallButtons: F,
      responsiveButtons: a,
      _menuTray: s,
      _buttonTray: E
    };
  }
}, be = function(n, l, m) {
  return {
    element: {
      originElement: n,
      topArea: l._top,
      relative: l._relative,
      toolbar: l._toolBar,
      _toolbarShadow: l._toolbarShadow,
      _buttonTray: l._toolBar.querySelector(".se-btn-tray"),
      _menuTray: l._menuTray,
      resizingBar: l._resizingBar,
      navigation: l._navigation,
      charWrapper: l._charWrapper,
      charCounter: l._charCounter,
      editorArea: l._editorArea,
      wysiwygFrame: l._wysiwygArea,
      wysiwyg: l._wysiwygArea,
      // if (options.iframe) cons._wysiwygArea.contentDocument.body
      code: l._codeArea,
      placeholder: l._placeholder,
      loading: l._loading,
      lineBreaker: l._lineBreaker,
      lineBreaker_t: l._lineBreaker_t,
      lineBreaker_b: l._lineBreaker_b,
      resizeBackground: l._resizeBack,
      _stickyDummy: l._stickyDummy,
      _arrow: l._arrow
    },
    tool: {
      cover: l._toolBar.querySelector(".se-toolbar-cover"),
      bold: l._toolBar.querySelector('[data-command="bold"]'),
      underline: l._toolBar.querySelector('[data-command="underline"]'),
      italic: l._toolBar.querySelector('[data-command="italic"]'),
      strike: l._toolBar.querySelector('[data-command="strike"]'),
      sub: l._toolBar.querySelector('[data-command="SUB"]'),
      sup: l._toolBar.querySelector('[data-command="SUP"]'),
      undo: l._toolBar.querySelector('[data-command="undo"]'),
      redo: l._toolBar.querySelector('[data-command="redo"]'),
      save: l._toolBar.querySelector('[data-command="save"]'),
      outdent: l._toolBar.querySelector('[data-command="outdent"]'),
      indent: l._toolBar.querySelector('[data-command="indent"]'),
      fullScreen: l._toolBar.querySelector('[data-command="fullScreen"]'),
      showBlocks: l._toolBar.querySelector('[data-command="showBlocks"]'),
      codeView: l._toolBar.querySelector('[data-command="codeView"]'),
      dir: l._toolBar.querySelector('[data-command="dir"]'),
      dir_ltr: l._toolBar.querySelector('[data-command="dir_ltr"]'),
      dir_rtl: l._toolBar.querySelector('[data-command="dir_rtl"]')
    },
    options: m,
    option: m
  };
};
function Ee(n, l) {
  const m = n._w, C = n.util, c = n.options.historyStackDelayTime;
  let v = n.context.element, E = n.context.tool.undo, w = n.context.tool.redo, t = null, F = 0, a = [];
  function p() {
    const z = a[F];
    v.wysiwyg.innerHTML = z.contents, n.setRange(C.getNodeFromPath(z.s.path, v.wysiwyg), z.s.offset, C.getNodeFromPath(z.e.path, v.wysiwyg), z.e.offset), n.focus(), a.length <= 1 ? (E && E.setAttribute("disabled", !0), w && w.setAttribute("disabled", !0)) : F === 0 ? (E && E.setAttribute("disabled", !0), w && w.removeAttribute("disabled")) : F === a.length - 1 ? (E && E.removeAttribute("disabled"), w && w.setAttribute("disabled", !0)) : (E && E.removeAttribute("disabled"), w && w.removeAttribute("disabled")), n.controllersOff(), n._checkComponents(), n._setCharCount(), n._resourcesStateChange(), l();
  }
  function O() {
    n._checkComponents();
    const z = v.wysiwyg.innerHTML;
    if (!z || a[F] && z === a[F].contents)
      return;
    F++;
    const K = n._variable._range;
    a.length > F && (a = a.slice(0, F), w && w.setAttribute("disabled", !0)), K ? a[F] = {
      contents: z,
      s: {
        path: C.getNodePath(K.startContainer, null, null),
        offset: K.startOffset
      },
      e: {
        path: C.getNodePath(K.endContainer, null, null),
        offset: K.endOffset
      }
    } : a[F] = {
      contents: z,
      s: { path: [0, 0], offset: [0, 0] },
      e: { path: 0, offset: 0 }
    }, F === 1 && E && E.removeAttribute("disabled"), n._setCharCount(), l();
  }
  return {
    /**
     * @description History stack
     */
    stack: a,
    /**
     * @description Saving the current status to the history object stack
     * If "delay" is true, it will be saved after (options.historyStackDelayTime || 400) miliseconds
     * If the function is called again with the "delay" argument true before it is saved, the delay time is renewal
     * You can specify the delay time by sending a number.
     * @param {Boolean|Number} delay If true, Add stack without delay time.
     */
    push: function(z) {
      m.setTimeout(n._resourcesStateChange.bind(n));
      const K = typeof z == "number" ? z > 0 ? z : 0 : z ? c : 0;
      if ((!K || t) && (m.clearTimeout(t), !K)) {
        O();
        return;
      }
      t = m.setTimeout(function() {
        m.clearTimeout(t), t = null, O();
      }, K);
    },
    /**
     * @description Undo function
     */
    undo: function() {
      F > 0 && (F--, p());
    },
    /**
     * @description Redo function
     */
    redo: function() {
      a.length - 1 > F && (F++, p());
    },
    /**
     * @description Go to the history stack for that index.
     * If "index" is -1, go to the last stack
     */
    go: function(z) {
      F = z < 0 ? a.length - 1 : z, p();
    },
    /**
     * @description Get the current history stack index.
     * @returns {Number} Current Stack index
     */
    getCurrentIndex: function() {
      return F;
    },
    /**
     * @description Reset the history object
     */
    reset: function(z) {
      E && E.setAttribute("disabled", !0), w && w.setAttribute("disabled", !0), n._variable.isChanged = !1, n.context.tool.save && n.context.tool.save.setAttribute("disabled", !0), a.splice(0), F = 0, a[F] = {
        contents: n.getContents(!0),
        s: {
          path: [0, 0],
          offset: 0
        },
        e: {
          path: [0, 0],
          offset: 0
        }
      }, z || l();
    },
    /**
     * @description Reset the disabled state of the buttons to fit the current stack.
     * @private
     */
    _resetCachingButton: function() {
      v = n.context.element, E = n.context.tool.undo, w = n.context.tool.redo, F === 0 ? (E && E.setAttribute("disabled", !0), w && F === a.length - 1 && w.setAttribute("disabled", !0), n._variable.isChanged = !1, n.context.tool.save && n.context.tool.save.setAttribute("disabled", !0)) : F === a.length - 1 && w && w.setAttribute("disabled", !0);
    },
    /**
     * @description Remove all stacks and remove the timeout function.
     * @private
     */
    _destroy: function() {
      t && m.clearTimeout(t), a = null;
    }
  };
}
const we = {
  name: "notice",
  /**
   * @description Constructor
   * @param {Object} core Core object 
   */
  add: function(n) {
    const l = n.context;
    l.notice = {};
    let m = n.util.createElement("DIV"), C = n.util.createElement("SPAN"), c = n.util.createElement("BUTTON");
    m.className = "se-notice", c.className = "close", c.setAttribute("aria-label", "Close"), c.setAttribute("title", n.lang.dialogBox.close), c.innerHTML = n.icons.cancel, m.appendChild(C), m.appendChild(c), l.notice.modal = m, l.notice.message = C, c.addEventListener("click", this.onClick_cancel.bind(n)), l.element.editorArea.appendChild(m), m = null;
  },
  /**
   * @description Event when clicking the cancel button
   * @param {MouseEvent} e Event object
   */
  onClick_cancel: function(n) {
    n.preventDefault(), n.stopPropagation(), this.plugins.notice.close.call(this);
  },
  /**
   * @description  Open the notice panel
   * @param {String} text Notice message
   */
  open: function(n) {
    this.context.notice.message.textContent = n, this.context.notice.modal.style.display = "block";
  },
  /**
   * @description  Open the notice panel
   */
  close: function() {
    this.context.notice.modal.style.display = "none";
  }
};
function Le(n, l, m, C, c, v) {
  const E = n.element.originElement.ownerDocument || document, w = E.defaultView || window, t = q, F = c.icons, a = {
    _d: E,
    _w: w,
    _parser: new w.DOMParser(),
    _prevRtl: c.rtl,
    _editorHeight: 0,
    _editorHeightPadding: 0,
    _listCamel: c.__listCommonStyle,
    _listKebab: t.camelToKebabCase(c.__listCommonStyle),
    /**
     * @description Document object of the iframe if created as an iframe || _d
     * @private
     */
    _wd: null,
    /**
     * @description Window object of the iframe if created as an iframe || _w
     * @private
     */
    _ww: null,
    /**
     * @description Closest ShadowRoot to editor if found
     * @private
     */
    _shadowRoot: null,
    /**
     * @description Block controller mousedown events in "shadowRoot" environment
     * @private
     */
    _shadowRootControllerEventTarget: null,
    /**
     * @description Util object
     */
    util: t,
    /**
     * @description Functions object
     */
    functions: null,
    /**
     * @description Editor options
     */
    options: null,
    /**
     * @description Computed style of the wysiwyg area (window.getComputedStyle(context.element.wysiwyg))
     */
    wwComputedStyle: null,
    /**
     * @description Notice object
     */
    notice: we,
    /**
     * @description Default icons object
     */
    icons: F,
    /**
     * @description History object for undo, redo
     */
    history: null,
    /**
     * @description Elements and user options parameters of the suneditor
     */
    context: n,
    /**
     * @description Plugin buttons
     */
    pluginCallButtons: l,
    /**
     * @description Loaded plugins
     */
    plugins: m || {},
    /**
     * @description Whether the plugin is initialized
     */
    initPlugins: {},
    /**
     * @description Object for managing submenu elements
     * @private
     */
    _targetPlugins: {},
    /**
     * @description Save rendered submenus and containers
     * @private
     */
    _menuTray: {},
    /**
     * @description loaded language
     */
    lang: C,
    /**
     * @description The selection node (core.getSelectionNode()) to which the effect was last applied
     */
    effectNode: null,
    /**
     * @description submenu element
     */
    submenu: null,
    /**
     * @description container element
     */
    container: null,
    /**
     * @description current subment name
     * @private
     */
    _submenuName: "",
    /**
     * @description binded submenuOff method
     * @private
     */
    _bindedSubmenuOff: null,
    /**
     * @description binded containerOff method
     * @private
     */
    _bindedContainerOff: null,
    /**
     * @description active button element in submenu
     */
    submenuActiveButton: null,
    /**
     * @description active button element in container
     */
    containerActiveButton: null,
    /**
     * @description The elements array to be processed unvisible when the controllersOff function is executed (resizing, link modified button, table controller)
     */
    controllerArray: [],
    /**
     * @description The name of the plugin that called the currently active controller
     */
    currentControllerName: "",
    /**
     * @description The target element of current controller
     */
    currentControllerTarget: null,
    /**
     * @description The file component object of current selected file tag (getFileComponent)
     */
    currentFileComponentInfo: null,
    /**
     * @description An array of buttons whose class name is not "se-code-view-enabled"
     */
    codeViewDisabledButtons: [],
    /**
     * @description An array of buttons whose class name is not "se-resizing-enabled"
     */
    resizingDisabledButtons: [],
    /**
     * @description active more layer element in submenu
     * @private
     */
    _moreLayerActiveButton: null,
    /**
     * @description Tag whitelist RegExp object used in "_consistencyCheckOfHTML" method
     * ^(options._editorTagsWhitelist)$
     * @private
     */
    _htmlCheckWhitelistRegExp: null,
    /**
     * @description Tag blacklist RegExp object used in "_consistencyCheckOfHTML" method
     * @private
     */
    _htmlCheckBlacklistRegExp: null,
    /**
     * @description RegExp when using check disallowd tags. (b, i, ins, strike, s)
     * @private
     */
    _disallowedTextTagsRegExp: null,
    /**
     * @description Editor tags whitelist (RegExp object)
     * util.createTagsWhitelist(options._editorTagsWhitelist)
     */
    editorTagsWhitelistRegExp: null,
    /**
     * @description Editor tags blacklist (RegExp object)
     * util.createTagsBlacklist(options.tagsBlacklist)
     */
    editorTagsBlacklistRegExp: null,
    /**
     * @description Tag whitelist when pasting (RegExp object)
     * util.createTagsWhitelist(options.pasteTagsWhitelist)
     */
    pasteTagsWhitelistRegExp: null,
    /**
     * @description Tag blacklist when pasting (RegExp object)
     * util.createTagsBlacklist(options.pasteTagsBlacklist)
     */
    pasteTagsBlacklistRegExp: null,
    /**
     * @description Boolean value of whether the editor has focus
     */
    hasFocus: !1,
    /**
     * @description Boolean value of whether the editor is disabled
     */
    isDisabled: !1,
    /**
     * @description Boolean value of whether the editor is readOnly
     */
    isReadOnly: !1,
    /**
     * @description Attributes whitelist used by the cleanHTML method
     * @private
     */
    _attributesWhitelistRegExp: null,
    _attributesWhitelistRegExp_all_data: null,
    /**
     * @description Attributes blacklist used by the cleanHTML method
     * @private
     */
    _attributesBlacklistRegExp: null,
    /**
     * @description Attributes of tags whitelist used by the cleanHTML method
     * @private
     */
    _attributesTagsWhitelist: null,
    /**
     * @description Attributes of tags blacklist used by the cleanHTML method
     * @private
     */
    _attributesTagsBlacklist: null,
    /**
     * @description binded controllersOff method
     * @private
     */
    _bindControllersOff: null,
    /**
     * @description Is inline mode?
     * @private
     */
    _isInline: null,
    /**
     * @description Is balloon|balloon-always mode?
     * @private
     */
    _isBalloon: null,
    /**
     * @description Is balloon-always mode?
     * @private
     */
    _isBalloonAlways: null,
    /**
     * @description Required value when using inline mode to sticky toolbar
     * @private
     */
    _inlineToolbarAttr: { top: "", width: "", isShow: !1 },
    /**
     * @description Variable that controls the "blur" event in the editor of inline or balloon mode when the focus is moved to submenu
     * @private
     */
    _notHideToolbar: !1,
    /**
     * @description Variable value that sticky toolbar mode
     * @private
     */
    _sticky: !1,
    /**
     * @description Variables for controlling focus and blur events
     * @private
     */
    _antiBlur: !1,
    /**
     * @description Component line breaker element
     * @private
     */
    _lineBreaker: null,
    _lineBreakerButton: null,
    /**
     * @description If true, (initialize, reset) all indexes of image, video information
     * @private
     */
    _componentsInfoInit: !0,
    _componentsInfoReset: !1,
    /**
     * @description Plugins array with "active" method.
     * "activePlugins" runs the "add" method when creating the editor.
     */
    activePlugins: null,
    /**
     * @description Information of tags that should maintain HTML structure, style, class name, etc. (In use by "math" plugin)
     * When inserting "html" such as paste, it is executed on the "html" to be inserted. (core.cleanHTML)
     * Basic Editor Actions:
     * 1. All classes not starting with "__se__" or "se-" in the editor are removed.
     * 2. The style of all tags except the "span" tag is removed from the editor.
     * "managedTagsInfo" structure ex:
     * managedTagsInfo: {
     *   query: '.__se__xxx, se-xxx'
     *   map: {
     *     '__se__xxx': method.bind(core),
     *     'se-xxx': method.bind(core),
     *   }
     * }
     * @example
     * Define in the following return format in the "managedTagInfo" function of the plugin.
     * managedTagInfo() => {
     *  return {
     *    className: 'string', // Class name to identify the tag. ("__se__xxx", "se-xxx")
     *    // Change the html of the "element". ("element" is the element found with "className".)
     *    // "method" is executed by binding "core".
     *    method: function (element) {
     *      // this === core
     *      element.innerHTML = // (rendered html);
     *    }
     *  }
     * }
     */
    managedTagsInfo: null,
    /**
     * @description cashing: options.charCounterType === 'byte-html'
     * @private
     */
    _charTypeHTML: !1,
    /**
     * @description Array of "checkFileInfo" functions with the core bound
     * (Plugins with "checkFileInfo" and "resetFileInfo" methods)
     * "fileInfoPlugins" runs the "add" method when creating the editor.
     * "checkFileInfo" method is always call just before the "change" event.
     * @private
     */
    _fileInfoPluginsCheck: null,
    /**
     * @description Array of "resetFileInfo" functions with the core bound
     * (Plugins with "checkFileInfo" and "resetFileInfo" methods)
     * "checkFileInfo" method is always call just before the "functions.setOptions" method.
     * @private
     */
    _fileInfoPluginsReset: null,
    /**
     * @description Variables for file component management
     * @private
     */
    _fileManager: {
      tags: null,
      regExp: null,
      queryString: null,
      pluginRegExp: null,
      pluginMap: null
    },
    /**
     * @description Elements that need to change text or className for each selection change
     * After creating the editor, "activePlugins" are added.
     * @property {Element} STRONG bold button
     * @property {Element} U underline button
     * @property {Element} EM italic button
     * @property {Element} DEL strike button
     * @property {Element} SUB subscript button
     * @property {Element} SUP superscript button
     * @property {Element} OUTDENT outdent button
     * @property {Element} INDENT indent button
     */
    commandMap: {},
    /**
     * @description CSS properties related to style tags 
     * @private
     */
    _commandMapStyles: {
      STRONG: ["font-weight"],
      U: ["text-decoration"],
      EM: ["font-style"],
      DEL: ["text-decoration"]
    },
    /**
     * @description Style button related to edit area
     * @property {Element} fullScreen fullScreen button element
     * @property {Element} showBlocks showBlocks button element
     * @property {Element} codeView codeView button element
     * @private
     */
    _styleCommandMap: null,
    /**
     * @private
     */
    _cleanStyleRegExp: {
      span: new w.RegExp("\\s*[^-a-zA-Z](font-family|font-size|color|background-color)\\s*:[^;]+(?!;)*", "ig"),
      format: new w.RegExp("\\s*[^-a-zA-Z](text-align|margin-left|margin-right)\\s*:[^;]+(?!;)*", "ig"),
      fontSizeUnit: new w.RegExp("\\d+" + c.fontSizeUnit + "$", "i")
    },
    /**
     * @description Variables used internally in editor operation
     * @property {Boolean} isCodeView State of code view
     * @property {Boolean} isFullScreen State of full screen
     * @property {Number} innerHeight_fullScreen InnerHeight in editor when in full screen
     * @property {Number} resizeClientY Remember the vertical size of the editor before resizing the editor (Used when calculating during resize operation)
     * @property {Number} tabSize Indent size of tab (4)
     * @property {Number} codeIndent Indent size of Code view mode (2)
     * @property {Number} minResizingSize Minimum size of editing area when resized {Number} (.se-wrapper-inner {min-height: 65px;} || 65)
     * @property {Array} currentNodes  An array of the current cursor's node structure
     * @private
     */
    _variable: {
      isChanged: !1,
      isCodeView: !1,
      isFullScreen: !1,
      innerHeight_fullScreen: 0,
      resizeClientY: 0,
      tabSize: 4,
      codeIndent: 2,
      minResizingSize: t.getNumber(n.element.wysiwygFrame.style.minHeight || "65", 0),
      currentNodes: [],
      currentNodesMap: [],
      _range: null,
      _selectionNode: null,
      _originCssText: n.element.topArea.style.cssText,
      _bodyOverflow: "",
      _editorAreaOriginCssText: "",
      _wysiwygOriginCssText: "",
      _codeOriginCssText: "",
      _fullScreenAttrs: { sticky: !1, balloon: !1, inline: !1 },
      _lineBreakComp: null,
      _lineBreakDir: ""
    },
    /**
     * @description Temp variable for set line attrs
     * @private
     */
    _formatAttrsTemp: null,
    /**
     * @description Save the current buttons states to "allCommandButtons" object
     * @private
     */
    _saveButtonStates: function() {
      this.allCommandButtons || (this.allCommandButtons = {});
      const e = this.context.element._buttonTray.querySelectorAll(".se-menu-list button[data-display]");
      for (let i = 0, s, r; i < e.length; i++)
        s = e[i], r = s.getAttribute("data-command"), this.allCommandButtons[r] = s;
    },
    /**
     * @description Recover the current buttons states from "allCommandButtons" object
     * @private
     */
    _recoverButtonStates: function() {
      if (this.allCommandButtons) {
        const e = this.context.element._buttonTray.querySelectorAll(".se-menu-list button[data-display]");
        for (let i = 0, s, r, f; i < e.length; i++)
          s = e[i], r = s.getAttribute("data-command"), f = this.allCommandButtons[r], f && (s.parentElement.replaceChild(f, s), this.context.tool[r] && (this.context.tool[r] = f));
      }
    },
    /**
     * @description If the plugin is not added, add the plugin and call the 'add' function.
     * If the plugin is added call callBack function.
     * @param {String} pluginName The name of the plugin to call
     * @param {function} callBackFunction Function to be executed immediately after module call
     * @param {Element|null} _target Plugin target button (This is not necessary if you have a button list when creating the editor)
     */
    callPlugin: function(e, i, s) {
      if (s = s || l[e], this.plugins[e])
        this.initPlugins[e] ? typeof this._targetPlugins[e] == "object" && s && this.initMenuTarget(e, s, this._targetPlugins[e]) : (this.plugins[e].add(this, s), this.initPlugins[e] = !0);
      else
        throw Error('[SUNEDITOR.core.callPlugin.fail] The called plugin does not exist or is in an invalid format. (pluginName:"' + e + '")');
      this.plugins[e].active && !this.commandMap[e] && s && (this.commandMap[e] = s, this.activePlugins.push(e)), typeof i == "function" && i();
    },
    /**
     * @description If the module is not added, add the module and call the 'add' function
     * @param {Array} moduleArray module object's Array [dialog, resizing]
     */
    addModule: function(e) {
      for (let i = 0, s = e.length, r; i < s; i++)
        r = e[i].name, this.plugins[r] || (this.plugins[r] = e[i]), this.initPlugins[r] || (this.initPlugins[r] = !0, typeof this.plugins[r].add == "function" && this.plugins[r].add(this));
    },
    /**
     * @description Gets the current editor-relative scroll offset.
     * @returns {Object} {top, left}
     */
    getGlobalScrollOffset: function() {
      let e = 0, i = 0, s = n.element.topArea;
      for (; s; )
        e += s.scrollTop, i += s.scrollLeft, s = s.parentElement;
      for (s = this._shadowRoot ? this._shadowRoot.host : null; s; )
        e += s.scrollTop, i += s.scrollLeft, s = s.parentElement;
      return {
        top: e,
        left: i
      };
    },
    /**
     * @description Method for managing submenu element.
     * You must add the "submenu" element using the this method at custom plugin.
     * @param {String} pluginName Plugin name
     * @param {Element|null} target Target button
     * @param {Element} menu Submenu element
     */
    initMenuTarget: function(e, i, s) {
      i ? (n.element._menuTray.appendChild(s), this._targetPlugins[e] = !0, this._menuTray[i.getAttribute("data-command")] = s) : this._targetPlugins[e] = s;
    },
    /**
     * @description Enable submenu
     * @param {Element} element Submenu's button element to call
     */
    submenuOn: function(e) {
      this._bindedSubmenuOff && this._bindedSubmenuOff(), this._bindControllersOff && this.controllersOff();
      const i = this._submenuName = e.getAttribute("data-command"), s = this.submenu = this._menuTray[i];
      this.submenuActiveButton = e, this._setMenuPosition(e, s), this._bindedSubmenuOff = this.submenuOff.bind(this), this.addDocEvent("mousedown", this._bindedSubmenuOff, !1), this.plugins[i].on && this.plugins[i].on.call(this), this._antiBlur = !0;
    },
    /**
     * @description Disable submenu
     */
    submenuOff: function() {
      this.removeDocEvent("mousedown", this._bindedSubmenuOff), this._bindedSubmenuOff = null, this.submenu && (this._submenuName = "", this.submenu.style.display = "none", this.submenu = null, t.removeClass(this.submenuActiveButton, "on"), this.submenuActiveButton = null, this._notHideToolbar = !1), this._antiBlur = !1;
    },
    /**
     * @description Disable more layer
     */
    moreLayerOff: function() {
      if (this._moreLayerActiveButton) {
        const e = n.element.toolbar.querySelector("." + this._moreLayerActiveButton.getAttribute("data-command"));
        e.style.display = "none", t.removeClass(this._moreLayerActiveButton, "on"), this._moreLayerActiveButton = null;
      }
    },
    /**
     * @description Enable container
     * @param {Element} element Container's button element to call
     */
    containerOn: function(e) {
      this._bindedContainerOff && this._bindedContainerOff();
      const i = this._containerName = e.getAttribute("data-command"), s = this.container = this._menuTray[i];
      this.containerActiveButton = e, this._setMenuPosition(e, s), this._bindedContainerOff = this.containerOff.bind(this), this.addDocEvent("mousedown", this._bindedContainerOff, !1), this.plugins[i].on && this.plugins[i].on.call(this), this._antiBlur = !0;
    },
    /**
     * @description Disable container
     */
    containerOff: function() {
      this.removeDocEvent("mousedown", this._bindedContainerOff), this._bindedContainerOff = null, this.container && (this._containerName = "", this.container.style.display = "none", this.container = null, t.removeClass(this.containerActiveButton, "on"), this.containerActiveButton = null, this._notHideToolbar = !1), this._antiBlur = !1;
    },
    /**
     * @description Set the menu position. (submenu, container)
     * @param {*} element Button element
     * @param {*} menu Menu element
     * @private
     */
    _setMenuPosition: function(e, i) {
      i.style.visibility = "hidden", i.style.display = "block", i.style.height = "", t.addClass(e, "on");
      const s = this.context.element.toolbar, r = s.offsetWidth, f = p._getEditorOffsets(n.element.toolbar), d = i.offsetWidth, o = e.parentElement.offsetLeft + 3;
      if (c.rtl) {
        const N = e.offsetWidth, V = d > N ? d - N : 0, M = V > 0 ? 0 : N - d;
        i.style.left = o - V + M + "px", f.left > p._getEditorOffsets(i).left && (i.style.left = "0px");
      } else {
        const N = r <= d ? 0 : r - (o + d);
        N < 0 ? i.style.left = o + N + "px" : i.style.left = o + "px";
      }
      let g = 0, u = e;
      for (; u && u !== s; )
        g += u.offsetTop, u = u.offsetParent;
      const h = g;
      this._isBalloon ? g += s.offsetTop + e.offsetHeight : g -= e.offsetHeight;
      const y = f.top, T = i.offsetHeight, L = this.getGlobalScrollOffset().top, k = w.innerHeight - (y - L + h + e.parentElement.offsetHeight);
      if (k < T) {
        let N = -1 * (T - h + 3);
        const V = y - L + N, M = T + (V < 0 ? V : 0);
        M > k ? (i.style.height = M + "px", N = -1 * (M - h + 3)) : (i.style.height = k + "px", N = h + e.parentElement.offsetHeight), i.style.top = N + "px";
      } else
        i.style.top = h + e.parentElement.offsetHeight + "px";
      i.style.visibility = "";
    },
    /**
     * @description Show controller at editor area (controller elements, function, "controller target element(@Required)", "controller name(@Required)", etc..)
     * @param {*} arguments controller elements, functions..
     */
    controllersOn: function() {
      this._bindControllersOff && this._bindControllersOff(), this.controllerArray = [];
      for (let e = 0, i; e < arguments.length; e++)
        if (i = arguments[e], !!i) {
          if (typeof i == "string") {
            this.currentControllerName = i;
            continue;
          }
          if (typeof i == "function") {
            this.controllerArray.push(i);
            continue;
          }
          if (!t.hasClass(i, "se-controller")) {
            this.currentControllerTarget = i, this.currentFileComponentInfo = this.getFileComponent(i);
            continue;
          }
          i.style && (i.style.display = "block", this._shadowRoot && this._shadowRootControllerEventTarget.indexOf(i) === -1 && (i.addEventListener("mousedown", function(s) {
            s.preventDefault(), s.stopPropagation();
          }), this._shadowRootControllerEventTarget.push(i))), this.controllerArray.push(i);
        }
      this._bindControllersOff = this.controllersOff.bind(this), this.addDocEvent("mousedown", this._bindControllersOff, !1), this.addDocEvent("keydown", this._bindControllersOff, !1), this._antiBlur = !0, typeof O.showController == "function" && O.showController(this.currentControllerName, this.controllerArray, this);
    },
    /**
     * @description Hide controller at editor area (link button, image resize button..)
     * @param {KeyboardEvent|MouseEvent|null} e Event object when called from mousedown and keydown events registered in "core.controllersOn"
     */
    controllersOff: function(e) {
      this._lineBreaker.style.display = "none";
      const i = this.controllerArray.length;
      if (e && e.target && i > 0) {
        for (let s = 0; s < i; s++)
          if (typeof this.controllerArray[s].contains == "function" && this.controllerArray[s].contains(e.target))
            return;
      }
      if (!(this._fileManager.pluginRegExp.test(this.currentControllerName) && e && e.type === "keydown" && e.keyCode !== 27) && (n.element.lineBreaker_t.style.display = n.element.lineBreaker_b.style.display = "none", this._variable._lineBreakComp = null, this.currentControllerName = "", this.currentControllerTarget = null, this.currentFileComponentInfo = null, this.effectNode = null, !!this._bindControllersOff)) {
        if (this.removeDocEvent("mousedown", this._bindControllersOff), this.removeDocEvent("keydown", this._bindControllersOff), this._bindControllersOff = null, i > 0) {
          for (let s = 0; s < i; s++)
            typeof this.controllerArray[s] == "function" ? this.controllerArray[s]() : this.controllerArray[s].style.display = "none";
          this.controllerArray = [];
        }
        this._antiBlur = !1;
      }
    },
    /**
     * @description Specify the position of the controller.
     * @param {Element} controller Controller element.
     * @param {Element} referEl Element that is the basis of the controller's position.
     * @param {String} position Type of position ("top" | "bottom")
     * When using the "top" position, there should not be an arrow on the controller.
     * When using the "bottom" position there should be an arrow on the controller.
     * @param {Object} addOffset These are the left and top values that need to be added specially. 
     * This argument is required. - {left: 0, top: 0}
     * Please enter the value based on ltr mode.
     * Calculated automatically in rtl mode.
     */
    setControllerPosition: function(e, i, s, r) {
      c.rtl && (r.left *= -1);
      const f = t.getOffset(i, n.element.wysiwygFrame);
      e.style.visibility = "hidden", e.style.display = "block";
      const d = s === "top" ? -(e.offsetHeight + 2) : i.offsetHeight + 12;
      e.style.top = f.top + d + r.top + "px";
      const o = f.left - n.element.wysiwygFrame.scrollLeft + r.left, g = e.offsetWidth, u = i.offsetWidth, h = t.hasClass(e.firstElementChild, "se-arrow") ? e.firstElementChild : null;
      if (c.rtl) {
        const y = g > u ? g - u : 0, T = y > 0 ? 0 : u - g;
        e.style.left = o - y + T + "px", y > 0 && h && (h.style.left = (g - 14 < 10 + y ? g - 14 : 10 + y) + "px");
        const L = n.element.wysiwygFrame.offsetLeft - e.offsetLeft;
        L > 0 && (e.style.left = "0px", h && (h.style.left = L + "px"));
      } else {
        e.style.left = o + "px";
        const y = n.element.wysiwygFrame.offsetWidth - (e.offsetLeft + g);
        y < 0 ? (e.style.left = e.offsetLeft + y + "px", h && (h.style.left = 20 - y + "px")) : h && (h.style.left = "20px");
      }
      e.style.visibility = "";
    },
    /**
     * @description javascript execCommand
     * @param {String} command javascript execCommand function property
     * @param {Boolean|undefined} showDefaultUI javascript execCommand function property
     * @param {String|undefined} value javascript execCommand function property
     */
    execCommand: function(e, i, s) {
      this._wd.execCommand(e, i, e === "formatBlock" ? "<" + s + ">" : s), this.history.push(!0);
    },
    /**
     * @description Focus to wysiwyg area using "native focus function"
     */
    nativeFocus: function() {
      this.__focus(), this._editorRange();
    },
    /**
     * @description Focus method
     * @private
     */
    __focus: function() {
      const e = t.getParentElement(this.getSelectionNode(), "figcaption");
      e ? e.focus() : n.element.wysiwyg.focus();
    },
    /**
     * @description Focus to wysiwyg area
     */
    focus: function() {
      if (n.element.wysiwygFrame.style.display !== "none") {
        if (c.iframe)
          this.nativeFocus();
        else
          try {
            const e = this.getRange();
            if (e.startContainer === e.endContainer && t.isWysiwygDiv(e.startContainer)) {
              const i = e.commonAncestorContainer.children[e.startOffset];
              if (!t.isFormatElement(i) && !t.isComponent(i)) {
                const s = t.createElement(c.defaultTag), r = t.createElement("BR");
                s.appendChild(r), n.element.wysiwyg.insertBefore(s, i), this.setRange(r, 0, r, 0);
                return;
              }
            }
            this.setRange(e.startContainer, e.startOffset, e.endContainer, e.endOffset);
          } catch {
            this.nativeFocus();
          }
        p._applyTagEffects(), this._isBalloon && p._toggleToolbarBalloon();
      }
    },
    /**
     * @description If "focusEl" is a component, then that component is selected; if it is a format element, the last text is selected
     * If "focusEdge" is null, then selected last element
     * @param {Element|null} focusEl Focus element
     */
    focusEdge: function(e) {
      e || (e = n.element.wysiwyg.lastElementChild);
      const i = this.getFileComponent(e);
      i ? this.selectComponent(i.target, i.pluginName) : e ? (e = t.getChildElement(e, function(s) {
        return s.childNodes.length === 0 || s.nodeType === 3;
      }, !0), e ? this.setRange(e, e.textContent.length, e, e.textContent.length) : this.nativeFocus()) : this.focus();
    },
    /**
     * @description Focusout to wysiwyg area (.blur())
     */
    blur: function() {
      c.iframe ? n.element.wysiwygFrame.blur() : n.element.wysiwyg.blur();
    },
    /**
     * @description Set current editor's range object and return.
     * @param {Node} startCon The startContainer property of the selection object.
     * @param {Number} startOff The startOffset property of the selection object.
     * @param {Node} endCon The endContainer property of the selection object.
     * @param {Number} endOff The endOffset property of the selection object.
     * @returns {Object} Range object.
     */
    setRange: function(e, i, s, r) {
      if (!e || !s)
        return;
      i > e.textContent.length && (i = e.textContent.length), r > s.textContent.length && (r = s.textContent.length), t.isFormatElement(e) && (e = e.childNodes[i] || e.childNodes[i - 1] || e, i = i > 0 ? e.nodeType === 1 ? 1 : e.textContent ? e.textContent.length : 0 : 0), t.isFormatElement(s) && (s = s.childNodes[r] || s.childNodes[r - 1] || s, r = r > 0 ? s.nodeType === 1 ? 1 : s.textContent ? s.textContent.length : 0 : 0);
      const f = this._wd.createRange();
      try {
        f.setStart(e, i), f.setEnd(s, r);
      } catch (o) {
        console.warn("[SUNEDITOR.core.focus.error] " + o), this.nativeFocus();
        return;
      }
      const d = this.getSelection();
      return d.removeAllRanges && d.removeAllRanges(), d.addRange(f), this._rangeInfo(f, this.getSelection()), c.iframe && this.__focus(), f;
    },
    /**
     * @description Remove range object and button effect
     */
    removeRange: function() {
      this._variable._range = null, this._variable._selectionNode = null, this.hasFocus && this.getSelection().removeAllRanges(), this._setKeyEffect([]);
    },
    /**
     * @description Get current editor's range object
     * @returns {Object}
     */
    getRange: function() {
      const e = this._variable._range || this._createDefaultRange(), i = this.getSelection();
      if (e.collapsed === i.isCollapsed || !n.element.wysiwyg.contains(i.focusNode))
        return e;
      if (i.rangeCount > 0)
        return this._variable._range = i.getRangeAt(0), this._variable._range;
      {
        const s = i.anchorNode, r = i.focusNode, f = i.anchorOffset, d = i.focusOffset, o = t.compareElements(s, r), g = o.ancestor && (o.result === 0 ? f <= d : o.result > 1);
        return this.setRange(
          g ? s : r,
          g ? f : d,
          g ? r : s,
          g ? d : f
        );
      }
    },
    /**
     * @description If the "range" object is a non-editable area, add a line at the top of the editor and update the "range" object.
     * Returns a new "range" or argument "range".
     * @param {Object} range core.getRange()
     * @param {Element|null} container If there is "container" argument, it creates a line in front of the container.
     * @returns {Object} range
     */
    getRange_addLine: function(e, i) {
      if (this._selectionVoid(e)) {
        const s = n.element.wysiwyg, r = t.createElement(c.defaultTag);
        r.innerHTML = "<br>", s.insertBefore(r, i && i !== s ? i.nextElementSibling : s.firstElementChild), this.setRange(r.firstElementChild, 0, r.firstElementChild, 1), e = this._variable._range;
      }
      return e;
    },
    /**
     * @description Get window selection obejct
     * @returns {Object}
     */
    getSelection: function() {
      const e = this._shadowRoot && this._shadowRoot.getSelection ? this._shadowRoot.getSelection() : this._ww.getSelection();
      return !this._variable._range && !n.element.wysiwyg.contains(e.focusNode) && (e.removeAllRanges(), e.addRange(this._createDefaultRange())), e;
    },
    /**
     * @description Get current select node
     * @returns {Node}
     */
    getSelectionNode: function() {
      if (n.element.wysiwyg.contains(this._variable._selectionNode) || this._editorRange(), !this._variable._selectionNode) {
        const e = t.getChildElement(n.element.wysiwyg.firstChild, function(i) {
          return i.childNodes.length === 0 || i.nodeType === 3;
        }, !1);
        if (!e)
          this._editorRange();
        else
          return this._variable._selectionNode = e, e;
      }
      return this._variable._selectionNode;
    },
    /**
     * @description Saving the range object and the currently selected node of editor
     * @private
     */
    _editorRange: function() {
      const e = this._wd.activeElement;
      if (t.isInputElement(e))
        return this._variable._selectionNode = e, e;
      const i = this.getSelection();
      if (!i)
        return null;
      let s = null;
      i.rangeCount > 0 ? s = i.getRangeAt(0) : s = this._createDefaultRange(), this._rangeInfo(s, i);
    },
    /**
     * @description Set "range" and "selection" info.
     * @param {Object} range range object.
     * @param {Object} selection selection object.
     */
    _rangeInfo: function(e, i) {
      let s = null;
      this._variable._range = e, e.collapsed ? t.isWysiwygDiv(e.commonAncestorContainer) ? s = e.commonAncestorContainer.children[e.startOffset] || e.commonAncestorContainer : s = e.commonAncestorContainer : s = i.extentNode || i.anchorNode, this._variable._selectionNode = s;
    },
    /**
     * @description Return the range object of editor's first child node
     * @returns {Object}
     * @private
     */
    _createDefaultRange: function() {
      const e = n.element.wysiwyg, i = this._wd.createRange();
      let s = e.firstElementChild, r = null;
      return s ? (r = s.firstChild, r || (r = t.createElement("BR"), s.appendChild(r))) : (s = t.createElement(c.defaultTag), r = t.createElement("BR"), s.appendChild(r), e.appendChild(s)), i.setStart(r, 0), i.setEnd(r, 0), i;
    },
    /**
     * @description Returns true if there is no valid "selection".
     * @param {Object} range core.getRange()
     * @returns {Object} range
     * @private
     */
    _selectionVoid: function(e) {
      const i = e.commonAncestorContainer;
      return t.isWysiwygDiv(e.startContainer) && t.isWysiwygDiv(e.endContainer) || /FIGURE/i.test(i.nodeName) || this._fileManager.regExp.test(i.nodeName) || t.isMediaComponent(i);
    },
    /**
     * @description Reset range object to text node selected status.
     * @returns {Boolean} Returns false if there is no valid selection.
     * @private
     */
    _resetRangeToTextNode: function() {
      const e = this.getRange();
      if (this._selectionVoid(e))
        return !1;
      let i = e.startContainer, s = e.startOffset, r = e.endContainer, f = e.endOffset, d, o, g;
      if (t.isFormatElement(i))
        for (i.childNodes[s] ? (i = i.childNodes[s] || i, s = 0) : (i = i.lastChild || i, s = i.textContent.length); i && i.nodeType === 1 && i.firstChild; )
          i = i.firstChild || i, s = 0;
      if (t.isFormatElement(r)) {
        for (r = r.childNodes[f] || r.lastChild || r; r && r.nodeType === 1 && r.lastChild; )
          r = r.lastChild;
        f = r.textContent.length;
      }
      if (d = t.isWysiwygDiv(i) ? n.element.wysiwyg.firstChild : i, o = s, t.isBreak(d) || d.nodeType === 1 && d.childNodes.length > 0) {
        const u = t.isBreak(d);
        if (!u) {
          for (; d && !t.isBreak(d) && d.nodeType === 1; )
            d = d.childNodes[o] || d.nextElementSibling || d.nextSibling, o = 0;
          let h = t.getFormatElement(d, null);
          h === t.getRangeFormatElement(h, null) && (h = t.createElement(t.getParentElement(d, t.isCell) ? "DIV" : c.defaultTag), d.parentNode.insertBefore(h, d), h.appendChild(d));
        }
        if (t.isBreak(d)) {
          const h = t.createTextNode(t.zeroWidthSpace);
          d.parentNode.insertBefore(h, d), d = h, u && i === r && (r = d, f = 1);
        }
      }
      if (i = d, s = o, d = t.isWysiwygDiv(r) ? n.element.wysiwyg.lastChild : r, o = f, t.isBreak(d) || d.nodeType === 1 && d.childNodes.length > 0) {
        const u = t.isBreak(d);
        if (!u) {
          for (; d && !t.isBreak(d) && d.nodeType === 1 && (g = d.childNodes, g.length !== 0); )
            d = g[o > 0 ? o - 1 : o] || !/FIGURE/i.test(g[0].nodeName) ? g[0] : d.previousElementSibling || d.previousSibling || i, o = o > 0 ? d.textContent.length : o;
          let h = t.getFormatElement(d, null);
          h === t.getRangeFormatElement(h, null) && (h = t.createElement(t.isCell(h) ? "DIV" : c.defaultTag), d.parentNode.insertBefore(h, d), h.appendChild(d));
        }
        if (t.isBreak(d)) {
          const h = t.createTextNode(t.zeroWidthSpace);
          d.parentNode.insertBefore(h, d), d = h, o = 1, u && !d.previousSibling && t.removeItem(r);
        }
      }
      return r = d, f = o, this.setRange(i, s, r, f), !0;
    },
    /**
     * @description Returns a "formatElement"(util.isFormatElement) array from the currently selected range.
     * @param {Function|null} validation The validation function. (Replaces the default validation function-util.isFormatElement(current))
     * @returns {Array}
     */
    getSelectedElements: function(e) {
      if (!this._resetRangeToTextNode())
        return [];
      let i = this.getRange();
      if (t.isWysiwygDiv(i.startContainer)) {
        const N = n.element.wysiwyg.children;
        if (N.length === 0)
          return [];
        this.setRange(N[0], 0, N[N.length - 1], N[N.length - 1].textContent.trim().length), i = this.getRange();
      }
      const s = i.startContainer, r = i.endContainer, f = i.commonAncestorContainer, d = t.getListChildren(f, function(N) {
        return e ? e(N) : t.isFormatElement(N);
      });
      if (!t.isWysiwygDiv(f) && !t.isRangeFormatElement(f) && d.unshift(t.getFormatElement(f, null)), s === r || d.length === 1)
        return d;
      let o = t.getFormatElement(s, null), g = t.getFormatElement(r, null), u = null, h = null;
      const y = function(N) {
        return t.isTable(N) ? /^TABLE$/i.test(N.nodeName) : !0;
      };
      let T = t.getRangeFormatElement(o, y), L = t.getRangeFormatElement(g, y);
      t.isTable(T) && t.isListCell(T.parentNode) && (T = T.parentNode), t.isTable(L) && t.isListCell(L.parentNode) && (L = L.parentNode);
      const k = T === L;
      for (let N = 0, V = d.length, M; N < V; N++) {
        if (M = d[N], o === M || !k && M === T) {
          u = N;
          continue;
        }
        if (g === M || !k && M === L) {
          h = N;
          break;
        }
      }
      return u === null && (u = 0), h === null && (h = d.length - 1), d.slice(u, h + 1);
    },
    /**
     * @description Get format elements and components from the selected area. (P, DIV, H[1-6], OL, UL, TABLE..)
     * If some of the component are included in the selection, get the entire that component.
     * @param {Boolean} removeDuplicate If true, if there is a parent and child tag among the selected elements, the child tag is excluded.
     * @returns {Array}
     */
    getSelectedElementsAndComponents: function(e) {
      const i = this.getRange().commonAncestorContainer, s = t.getParentElement(i, t.isComponent), r = t.isTable(i) ? this.getSelectedElements(null) : this.getSelectedElements((function(f) {
        const d = this.getParentElement(f, this.isComponent);
        return this.isFormatElement(f) && (!d || d === s) || this.isComponent(f) && !this.getFormatElement(f);
      }).bind(t));
      if (e) {
        for (let f = 0, d = r.length; f < d; f++)
          for (let o = f - 1; o >= 0; o--)
            if (r[o].contains(r[f])) {
              r.splice(f, 1), f--, d--;
              break;
            }
      }
      return r;
    },
    /**
     * @description Determine if this offset is the edge offset of container
     * @param {Node} container The node of the selection object. (range.startContainer..)
     * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)
     * @param {String|undefined} dir Select check point - Both edge, Front edge or End edge. ("front": Front edge, "end": End edge, undefined: Both edge)
     * @returns {Boolean}
     */
    isEdgePoint: function(e, i, s) {
      return s !== "end" && i === 0 || (!s || s !== "front") && !e.nodeValue && i === 1 || (!s || s === "end") && !!e.nodeValue && i === e.nodeValue.length;
    },
    /**
     * @description Check if the container and offset values are the edges of the format tag
     * @param {Node} container The node of the selection object. (range.startContainer..)
     * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)
     * @param {String} dir Select check point - "front": Front edge, "end": End edge, undefined: Both edge.
     * @returns {Array|null}
     * @private
     */
    _isEdgeFormat: function(e, i, s) {
      if (!this.isEdgePoint(e, i, s))
        return !1;
      const r = [];
      for (s = s === "front" ? "previousSibling" : "nextSibling"; e && !t.isFormatElement(e) && !t.isWysiwygDiv(e); )
        if (!e[s] || t.isBreak(e[s]) && !e[s][s])
          e.nodeType === 1 && r.push(e.cloneNode(!1)), e = e.parentNode;
        else
          return null;
      return r;
    },
    /**
     * @description Show loading box
     */
    showLoading: function() {
      n.element.loading.style.display = "block";
    },
    /**
     * @description Close loading box
     */
    closeLoading: function() {
      n.element.loading.style.display = "none";
    },
    /**
     * @description Append format element to sibling node of argument element.
     * If the "formatNodeName" argument value is present, the tag of that argument value is inserted,
     * If not, the currently selected format tag is inserted.
     * @param {Element} element Insert as siblings of that element
     * @param {String|Element|null} formatNode Node name or node obejct to be inserted
     * @returns {Element}
     */
    appendFormatTag: function(e, i) {
      if (!e || !e.parentNode)
        return null;
      const s = t.getFormatElement(this.getSelectionNode(), null);
      let r = null;
      if (!t.isFormatElement(e) && t.isFreeFormatElement(s || e.parentNode))
        r = t.createElement("BR");
      else {
        const f = i ? typeof i == "string" ? i : i.nodeName : t.isFormatElement(s) && !t.isRangeFormatElement(s) && !t.isFreeFormatElement(s) ? s.nodeName : c.defaultTag;
        r = t.createElement(f), r.innerHTML = "<br>", (i && typeof i != "string" || !i && t.isFormatElement(s)) && t.copyTagAttributes(r, i || s, ["id"]);
      }
      return t.isCell(e) ? e.insertBefore(r, e.nextElementSibling) : e.parentNode.insertBefore(r, e.nextElementSibling), r;
    },
    /**
     * @description The method to insert a element and return. (used elements : table, hr, image, video)
     * If "element" is "HR", insert and return the new line.
     * @param {Element} element Element to be inserted
     * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)
     * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
     * @param {Boolean} notSelect If true, Do not automatically select the inserted component.
     * @returns {Element}
     */
    insertComponent: function(e, i, s, r) {
      if (this.isReadOnly || s && !this.checkCharCount(e, null))
        return null;
      const f = this.removeNode();
      this.getRange_addLine(this.getRange(), f.container);
      let d = null, o = this.getSelectionNode(), g = t.getFormatElement(o, null);
      if (t.isListCell(g))
        this.insertNode(e, o === g ? null : f.container.nextSibling, !1), e.nextSibling || e.parentNode.appendChild(t.createElement("BR"));
      else {
        if (this.getRange().collapsed && (f.container.nodeType === 3 || t.isBreak(f.container))) {
          const u = t.getParentElement(f.container, (function(h) {
            return this.isRangeFormatElement(h);
          }).bind(t));
          d = t.splitElement(f.container, f.offset, u ? t.getElementDepth(u) + 1 : 0), d && (g = d.previousSibling);
        }
        this.insertNode(e, t.isRangeFormatElement(g) ? null : g, !1), g && t.onlyZeroWidthSpace(g) && t.removeItem(g);
      }
      if (!r) {
        this.setRange(e, 0, e, 0);
        const u = this.getFileComponent(e);
        u ? this.selectComponent(u.target, u.pluginName) : d && (d = t.getEdgeChildNodes(d, null).sc || d, this.setRange(d, 0, d, 0));
      }
      return i || this.history.push(1), d || e;
    },
    /**
     * @description Gets the file component and that plugin name
     * return: {target, component, pluginName} | null
     * @param {Element} element Target element (figure tag, component div, file tag)
     * @returns {Object|null}
     */
    getFileComponent: function(e) {
      if (!this._fileManager.queryString || !e)
        return null;
      let i, s;
      return (/^FIGURE$/i.test(e.nodeName) || /se-component/.test(e.className)) && (i = e.querySelector(this._fileManager.queryString)), !i && e.nodeName && this._fileManager.regExp.test(e.nodeName) && (i = e), i && (s = this._fileManager.pluginMap[i.nodeName.toLowerCase()], s) ? {
        target: i,
        component: t.getParentElement(i, t.isComponent),
        pluginName: s
      } : null;
    },
    /**
     * @description The component(image, video) is selected and the resizing module is called.
     * @param {Element} element Element tag (img, iframe, video)
     * @param {String} pluginName Plugin name (image, video)
     */
    selectComponent: function(e, i) {
      if (t.isUneditableComponent(t.getParentElement(e, t.isComponent)) || t.isUneditableComponent(e))
        return !1;
      this.hasFocus || this.focus();
      const s = this.plugins[i];
      s && w.setTimeout((function() {
        typeof s.select == "function" && this.callPlugin(i, s.select.bind(this, e), null), this._setComponentLineBreaker(e);
      }).bind(this));
    },
    /**
     * @description Set line breaker of component
     * @param {Element} element Element tag (img, iframe, video)
     * @private
     */
    _setComponentLineBreaker: function(e) {
      this._lineBreaker.style.display = "none";
      const i = t.getParentElement(e, t.isComponent), s = n.element.lineBreaker_t.style, r = n.element.lineBreaker_b.style, f = this.context.resizing.resizeContainer.style.display === "block" ? this.context.resizing.resizeContainer : e, d = t.isListCell(i.parentNode);
      let o, g, u;
      (d ? !i.previousSibling : !t.isFormatElement(i.previousElementSibling)) ? (this._variable._lineBreakComp = i, g = n.element.wysiwyg.scrollTop, o = t.getOffset(e, n.element.wysiwygFrame).top + g, u = f.offsetWidth / 2 / 2, s.top = o - g - 12 + "px", s.left = t.getOffset(f).left + u + "px", s.display = "block") : s.display = "none", (d ? !i.nextSibling : !t.isFormatElement(i.nextElementSibling)) ? (o || (this._variable._lineBreakComp = i, g = n.element.wysiwyg.scrollTop, o = t.getOffset(e, n.element.wysiwygFrame).top + g, u = f.offsetWidth / 2 / 2), r.top = o + f.offsetHeight - g - 12 + "px", r.left = t.getOffset(f).left + f.offsetWidth - u - 24 + "px", r.display = "block") : r.display = "none";
    },
    _checkDuplicateNode: function(e, i) {
      (function s(r) {
        a._dupleCheck(r, i);
        const f = r.childNodes;
        for (let d = 0, o = f.length; d < o; d++)
          s(f[d]);
      })(e);
    },
    _dupleCheck: function(e, i) {
      if (!t.isTextStyleElement(e))
        return;
      const s = (e.style.cssText.match(/[^;]+;/g) || []).map(function(d) {
        return d.trim();
      }), r = e.nodeName;
      if (/^span$/i.test(r) && s.length === 0)
        return e;
      let f = !1;
      return function d(o) {
        if (!(t.isWysiwygDiv(o) || !t.isTextStyleElement(o))) {
          if (o.nodeName === r) {
            f = !0;
            const g = o.style.cssText.match(/[^;]+;/g) || [];
            for (let u = 0, h = g.length, y; u < h; u++)
              (y = s.indexOf(g[u].trim())) > -1 && s.splice(y, 1);
            for (let u = 0, h = o.classList.length; u < h; u++)
              e.classList.remove(o.classList[u]);
          }
          d(o.parentElement);
        }
      }(i), f && ((e.style.cssText = s.join(" ")) || (e.setAttribute("style", ""), e.removeAttribute("style")), e.attributes.length || e.setAttribute("data-se-duple", "true")), e;
    },
    /**
     * @description Delete selected node and insert argument value node and return.
     * If the "afterNode" exists, it is inserted after the "afterNode"
     * Inserting a text node merges with both text nodes on both sides and returns a new "{ container, startOffset, endOffset }".
     * @param {Node} oNode Element to be inserted
     * @param {Node|null} afterNode If the node exists, it is inserted after the node
     * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
     * @returns {Object|Node|null}
     */
    insertNode: function(e, i, s) {
      if (this.isReadOnly || s && !this.checkCharCount(e, null))
        return null;
      let r = this.getRange(), f = t.isListCell(r.commonAncestorContainer) ? r.commonAncestorContainer : t.getFormatElement(this.getSelectionNode(), null), d = t.isListCell(f) && (t.isListCell(e) || t.isList(e)), o, g, u, h = null;
      const y = t.isFreeFormatElement(f), T = !y && (t.isFormatElement(e) || t.isRangeFormatElement(e)) || t.isComponent(e);
      if (d && (u = i || t.isList(e) ? f.lastChild : f.nextElementSibling, h = t.isList(e) ? f : (u || f).parentNode), !i && (T || t.isComponent(e) || t.isMedia(e))) {
        const _ = this.isEdgePoint(r.endContainer, r.endOffset, "end"), A = this.removeNode(), H = A.container, b = H === A.prevContainer && r.collapsed ? null : A.prevContainer;
        if (d && b)
          if (h = b.nodeType === 3 ? b.parentNode : b, h.contains(H)) {
            let B = !0;
            for (u = H; u.parentNode && u.parentNode !== h; )
              u = u.parentNode, B = !1;
            B && H === b && (u = u.nextSibling);
          } else
            u = null;
        else if (d && t.isListCell(H) && !f.parentElement)
          f = t.createElement("LI"), h.appendChild(f), H.appendChild(h), u = null;
        else if (H.nodeType === 3 || t.isBreak(H) || d) {
          const B = t.getParentElement(H, (function(x) {
            return this.isRangeFormatElement(x) || this.isListCell(x);
          }).bind(t));
          if (i = t.splitElement(H, A.offset, B ? t.getElementDepth(B) + 1 : 0), !i)
            u = i = f;
          else if (d) {
            if (f.contains(H)) {
              const x = t.isList(f.lastElementChild);
              let S = null;
              _ || (S = f.cloneNode(!1), S.appendChild(i.textContent.trim() ? i : t.createTextNode(t.zeroWidthSpace))), x && (S || (S = f.cloneNode(!1), S.appendChild(t.createTextNode(t.zeroWidthSpace))), S.appendChild(f.lastElementChild)), S && (f.parentNode.insertBefore(S, f.nextElementSibling), u = i = S);
            }
          } else
            i = i.previousSibling;
        }
      }
      r = !i && !T ? this.getRange_addLine(this.getRange(), null) : this.getRange();
      const L = r.commonAncestorContainer, k = r.startOffset, N = r.endOffset, V = r.startContainer === L && t.isFormatElement(L), M = V && (L.childNodes[k] || L.childNodes[0]) || r.startContainer, D = V && (L.childNodes[N] || L.childNodes[L.childNodes.length - 1]) || r.endContainer;
      if (!d)
        if (i)
          o = i.parentNode, i = i.nextSibling, g = !0;
        else if (o = M, M.nodeType === 3 && (o = M.parentNode), r.collapsed)
          if (L.nodeType === 3)
            L.textContent.length > N ? i = L.splitText(N) : i = L.nextSibling;
          else if (t.isBreak(o))
            i = o, o = o.parentNode;
          else {
            let _ = o.childNodes[k];
            const A = _ && _.nodeType === 3 && t.onlyZeroWidthSpace(_) && t.isBreak(_.nextSibling) ? _.nextSibling : _;
            A ? !A.nextSibling && t.isBreak(A) ? (o.removeChild(A), i = null) : i = t.isBreak(A) && !t.isBreak(e) ? A : A.nextSibling : i = null;
          }
        else if (M === D) {
          this.isEdgePoint(D, N) ? i = D.nextSibling : i = D.splitText(N);
          let A = M;
          this.isEdgePoint(M, k) || (A = M.splitText(k)), o.removeChild(A), o.childNodes.length === 0 && T && (o.innerHTML = "<br>");
        } else {
          const A = this.removeNode(), H = A.container, b = A.prevContainer;
          if (H && H.childNodes.length === 0 && T && (t.isFormatElement(H) ? H.innerHTML = "<br>" : t.isRangeFormatElement(H) && (H.innerHTML = "<" + c.defaultTag + "><br></" + c.defaultTag + ">")), t.isListCell(H) && e.nodeType === 3)
            o = H, i = null;
          else if (!T && b)
            if (o = b.nodeType === 3 ? b.parentNode : b, o.contains(H)) {
              let B = !0;
              for (i = H; i.parentNode && i.parentNode !== o; )
                i = i.parentNode, B = !1;
              B && H === b && (i = i.nextSibling);
            } else
              i = null;
          else
            t.isWysiwygDiv(H) && !t.isFormatElement(e) ? (o = H.appendChild(t.createElement(c.defaultTag)), i = null) : (i = T ? D : H === b ? H.nextSibling : H, o = !i || !i.parentNode ? L : i.parentNode);
          for (; i && !t.isFormatElement(i) && i.parentNode !== L; )
            i = i.parentNode;
        }
      try {
        if (!d) {
          if ((t.isWysiwygDiv(i) || o === n.element.wysiwyg.parentNode) && (o = n.element.wysiwyg, i = null), t.isFormatElement(e) || t.isRangeFormatElement(e) || !t.isListCell(o) && t.isComponent(e)) {
            const _ = o;
            if (t.isList(i))
              o = i, i = null;
            else if (t.isListCell(i))
              o = i.previousElementSibling || i;
            else if (!g && !i) {
              const A = this.removeNode(), H = A.container.nodeType === 3 ? t.isListCell(t.getFormatElement(A.container, null)) ? A.container : t.getFormatElement(A.container, null) || A.container.parentNode : A.container, b = t.isWysiwygDiv(H) || t.isRangeFormatElement(H);
              o = b ? H : H.parentNode, i = b ? null : H.nextSibling;
            }
            _.childNodes.length === 0 && o !== _ && t.removeItem(_);
          }
          if (T && !y && !t.isRangeFormatElement(o) && !t.isListCell(o) && !t.isWysiwygDiv(o) && (i = o.nextElementSibling, o = o.parentNode), t.isWysiwygDiv(o) && (e.nodeType === 3 || t.isBreak(e))) {
            const _ = t.createElement(c.defaultTag);
            _.appendChild(e), e = _;
          }
        }
        if (d ? h.parentNode ? (o = h, i = u) : (o = n.element.wysiwyg, i = null) : i = o === i ? o.lastChild : i, t.isListCell(e) && !t.isList(o)) {
          if (t.isListCell(o))
            i = o.nextElementSibling, o = o.parentNode;
          else {
            const _ = t.createElement("ol");
            o.insertBefore(_, i), o = _, i = null;
          }
          d = !0;
        }
        if (this._checkDuplicateNode(e, o), o.insertBefore(e, i), d)
          if (t.onlyZeroWidthSpace(f.textContent.trim()))
            t.removeItem(f), e = e.lastChild;
          else {
            const _ = t.getArrayItem(f.children, t.isList);
            _ && (e !== _ ? (e.appendChild(_), e = _.previousSibling) : (o.appendChild(e), e = o), t.onlyZeroWidthSpace(f.textContent.trim()) && t.removeItem(f));
          }
      } catch (_) {
        o.appendChild(e), console.warn("[SUNEDITOR.insertNode.warn] " + _);
      } finally {
        const _ = o.querySelectorAll("[data-se-duple]");
        if (_.length > 0)
          for (let A = 0, H = _.length, b, B, x, S; A < H; A++) {
            for (b = _[A], x = b.childNodes, S = b.parentNode; x[0]; )
              B = x[0], S.insertBefore(B, b);
            b === e && (e = B), t.removeItem(b);
          }
        if ((t.isFormatElement(e) || t.isComponent(e)) && M === D) {
          const A = t.getFormatElement(L, null);
          A && A.nodeType === 1 && t.isEmptyLine(A) && t.removeItem(A);
        }
        if (y && (t.isFormatElement(e) || t.isRangeFormatElement(e)) && (e = this._setIntoFreeFormat(e)), !t.isComponent(e)) {
          let A = 1;
          if (e.nodeType === 3) {
            const H = e.previousSibling, b = e.nextSibling, B = !H || H.nodeType === 1 || t.onlyZeroWidthSpace(H) ? "" : H.textContent, x = !b || b.nodeType === 1 || t.onlyZeroWidthSpace(b) ? "" : b.textContent;
            H && B.length > 0 && (e.textContent = B + e.textContent, t.removeItem(H)), b && b.length > 0 && (e.textContent += x, t.removeItem(b));
            const S = {
              container: e,
              startOffset: B.length,
              endOffset: e.textContent.length - x.length
            };
            return this.setRange(e, S.startOffset, e, S.endOffset), S;
          } else if (!t.isBreak(e) && !t.isListCell(e) && t.isFormatElement(o)) {
            let H = null;
            (!e.previousSibling || t.isBreak(e.previousSibling)) && (H = t.createTextNode(t.zeroWidthSpace), e.parentNode.insertBefore(H, e)), (!e.nextSibling || t.isBreak(e.nextSibling)) && (H = t.createTextNode(t.zeroWidthSpace), e.parentNode.insertBefore(H, e.nextSibling)), t._isIgnoreNodeChange(e) && (e = e.nextSibling, A = 0);
          }
          this.setRange(e, A, e, A);
        }
        return this.history.push(!0), e;
      }
    },
    _setIntoFreeFormat: function(e) {
      const i = e.parentNode;
      let s, r;
      for (; t.isFormatElement(e) || t.isRangeFormatElement(e); ) {
        for (s = e.childNodes, r = null; s[0]; ) {
          if (r = s[0], t.isFormatElement(r) || t.isRangeFormatElement(r)) {
            if (this._setIntoFreeFormat(r), !e.parentNode)
              break;
            s = e.childNodes;
            continue;
          }
          i.insertBefore(r, e);
        }
        e.childNodes.length === 0 && t.removeItem(e), e = t.createElement("BR"), i.insertBefore(e, r.nextSibling);
      }
      return e;
    },
    /**
     * @description Delete the currently selected nodes and reset selection range
     * Returns {container: "the last element after deletion", offset: "offset", prevContainer: "previousElementSibling Of the deleted area"}
     * @returns {Object}
     */
    removeNode: function() {
      this._resetRangeToTextNode();
      const e = this.getRange(), i = e.startOffset === 0, s = a.isEdgePoint(e.endContainer, e.endOffset, "end");
      let r = null, f = null, d = null;
      i && (f = t.getFormatElement(e.startContainer), r = f.previousElementSibling, f = f && r), s && (d = t.getFormatElement(e.endContainer), d = d && d.nextElementSibling);
      let o, g = 0, u = e.startContainer, h = e.endContainer, y = e.startOffset, T = e.endOffset;
      const L = e.commonAncestorContainer.nodeType === 3 && e.commonAncestorContainer.parentNode === u.parentNode ? u.parentNode : e.commonAncestorContainer;
      if (L === u && L === h && (u = L.children[y], h = L.children[T], y = T = 0), !u || !h)
        return {
          container: L,
          offset: 0
        };
      if (u === h && e.collapsed && u.textContent && t.onlyZeroWidthSpace(u.textContent.substr(y)))
        return {
          container: u,
          offset: y,
          prevContainer: u && u.parentNode ? u : null
        };
      let k = null, N = null;
      const V = t.getListChildNodes(L, null);
      let M = t.getArrayIndex(V, u), D = t.getArrayIndex(V, h);
      if (V.length > 0 && M > -1 && D > -1) {
        for (let H = M + 1, b = u; H >= 0; H--)
          V[H] === b.parentNode && V[H].firstChild === b && y === 0 && (M = H, b = b.parentNode);
        for (let H = D - 1, b = h; H > M; H--)
          V[H] === b.parentNode && V[H].nodeType === 1 && (V.splice(H, 1), b = b.parentNode, --D);
      } else {
        if (V.length === 0) {
          if (t.isFormatElement(L) || t.isRangeFormatElement(L) || t.isWysiwygDiv(L) || t.isBreak(L) || t.isMedia(L))
            return {
              container: L,
              offset: 0
            };
          if (L.nodeType === 3)
            return {
              container: L,
              offset: T
            };
          V.push(L), u = h = L;
        } else if (u = h = V[0], t.isBreak(u) || t.onlyZeroWidthSpace(u))
          return {
            container: t.isMedia(L) ? L : u,
            offset: 0
          };
        M = D = 0;
      }
      for (let H = M; H <= D; H++) {
        const b = V[H];
        if (b.length === 0 || b.nodeType === 3 && b.data === void 0) {
          this._nodeRemoveListItem(b);
          continue;
        }
        if (b === u) {
          if (u.nodeType === 1) {
            if (t.isComponent(u))
              continue;
            k = t.createTextNode(u.textContent);
          } else
            b === h ? (k = t.createTextNode(u.substringData(0, y) + h.substringData(T, h.length - T)), g = y) : k = t.createTextNode(u.substringData(0, y));
          if (k.length > 0 ? u.data = k.data : this._nodeRemoveListItem(u), b === h)
            break;
          continue;
        }
        if (b === h) {
          if (h.nodeType === 1) {
            if (t.isComponent(h))
              continue;
            N = t.createTextNode(h.textContent);
          } else
            N = t.createTextNode(h.substringData(T, h.length - T));
          N.length > 0 ? h.data = N.data : this._nodeRemoveListItem(h);
          continue;
        }
        this._nodeRemoveListItem(b);
      }
      const _ = t.getParentElement(h, "ul"), A = t.getParentElement(u, "li");
      if (_ && A && A.contains(_) ? (o = _.previousSibling, g = o.textContent.length) : (o = h && h.parentNode ? h : u && u.parentNode ? u : e.endContainer || e.startContainer, g = !i && !s ? g : s ? o.textContent.length : 0), !t.isWysiwygDiv(o) && o.childNodes.length === 0) {
        const H = t.removeItemAllParents(o, null, null);
        H && (o = H.sc || H.ec || n.element.wysiwyg);
      }
      return !t.getFormatElement(o) && !(u && u.parentNode) && (d ? (o = d, g = 0) : f && (o = f, g = 1)), this.setRange(o, g, o, g), this.history.push(!0), {
        container: o,
        offset: g,
        prevContainer: r
      };
    },
    _nodeRemoveListItem: function(e) {
      const i = t.getFormatElement(e, null);
      t.removeItem(e), t.isListCell(i) && (t.removeItemAllParents(i, null, null), i && t.isList(i.firstChild) && i.insertBefore(t.createTextNode(t.zeroWidthSpace), i.firstChild));
    },
    /**
     * @description Appended all selected format Element to the argument element and insert
     * @param {Element} rangeElement Element of wrap the arguments (BLOCKQUOTE...)
     */
    applyRangeFormatElement: function(e) {
      this.getRange_addLine(this.getRange(), null);
      const i = this.getSelectedElementsAndComponents(!1);
      if (!i || i.length === 0)
        return;
      e:
        for (let T = 0, L = i.length, k, N, V, M, D, _; T < L; T++)
          if (k = i[T], !!t.isListCell(k) && (N = k.lastElementChild, N && t.isListCell(k.nextElementSibling) && i.indexOf(k.nextElementSibling) > -1 && (M = N.lastElementChild, i.indexOf(M) > -1))) {
            let A = null;
            for (; A = M.lastElementChild; )
              if (t.isList(A))
                if (i.indexOf(A.lastElementChild) > -1)
                  M = A.lastElementChild;
                else
                  continue e;
            V = N.firstElementChild, D = i.indexOf(V), _ = i.indexOf(M), i.splice(D, _ - D + 1), L = i.length;
            continue;
          }
      let s = i[i.length - 1], r, f, d;
      t.isRangeFormatElement(s) || t.isFormatElement(s) ? r = s : r = t.getRangeFormatElement(s, null) || t.getFormatElement(s, null), t.isCell(r) ? (f = null, d = r) : (f = r.nextSibling, d = r.parentNode);
      let o = t.getElementDepth(r), g = null;
      const u = [], h = function(T, L, k) {
        let N = null;
        if (T !== L && !t.isTable(L)) {
          if (L && t.getElementDepth(T) === t.getElementDepth(L))
            return k;
          N = t.removeItemAllParents(L, null, T);
        }
        return N ? N.ec : k;
      };
      for (let T = 0, L = i.length, k, N, V, M, D, _, A; T < L; T++)
        if (k = i[T], N = k.parentNode, !(!N || e.contains(N)))
          if (V = t.getElementDepth(k), t.isList(N)) {
            if (g === null && (_ ? (g = _, A = !0, _ = null) : g = N.cloneNode(!1)), u.push(k), D = i[T + 1], T === L - 1 || D && D.parentNode !== N) {
              D && k.contains(D.parentNode) && (_ = D.parentNode.cloneNode(!1));
              let H = N.parentNode, b;
              for (; t.isList(H); )
                b = t.createElement(H.nodeName), b.appendChild(g), g = b, H = H.parentNode;
              const B = this.detachRangeFormatElement(N, u, null, !0, !0);
              o >= V ? (o = V, d = B.cc, f = h(d, N, B.ec), f && (d = f.parentNode)) : d === B.cc && (f = B.ec), d !== B.cc && (M = h(d, B.cc, M), M !== void 0 ? f = M : f = B.cc);
              for (let x = 0, S = B.removeArray.length; x < S; x++)
                g.appendChild(B.removeArray[x]);
              A || e.appendChild(g), _ && B.removeArray[B.removeArray.length - 1].appendChild(_), g = null, A = !1;
            }
          } else
            o >= V && (o = V, d = N, f = k.nextSibling), e.appendChild(k), d !== N && (M = h(d, N), M !== void 0 && (f = M));
      if (this.effectNode = null, t.mergeSameTags(e, null, !1), t.mergeNestedTags(e, (function(T) {
        return this.isList(T);
      }).bind(t)), f && t.getElementDepth(f) > 0 && (t.isList(f.parentNode) || t.isList(f.parentNode.parentNode))) {
        const T = t.getParentElement(f, (function(k) {
          return this.isRangeFormatElement(k) && !this.isList(k);
        }).bind(t)), L = t.splitElement(f, null, T ? t.getElementDepth(T) + 1 : 0);
        L.parentNode.insertBefore(e, L);
      } else
        d.insertBefore(e, f), h(e, f);
      const y = t.getEdgeChildNodes(e.firstElementChild, e.lastElementChild);
      i.length > 1 ? this.setRange(y.sc, 0, y.ec, y.ec.textContent.length) : this.setRange(y.ec, y.ec.textContent.length, y.ec, y.ec.textContent.length), this.history.push(!1);
    },
    /**
     * @description The elements of the "selectedFormats" array are detached from the "rangeElement" element. ("LI" tags are converted to "P" tags)
     * When "selectedFormats" is null, all elements are detached and return {cc: parentNode, sc: nextSibling, ec: previousSibling, removeArray: [Array of removed elements]}.
     * @param {Element} rangeElement Range format element (PRE, BLOCKQUOTE, OL, UL...)
     * @param {Array|null} selectedFormats Array of format elements (P, DIV, LI...) to remove.
     * If null, Applies to all elements and return {cc: parentNode, sc: nextSibling, ec: previousSibling}
     * @param {Element|null} newRangeElement The node(rangeElement) to replace the currently wrapped node.
     * @param {Boolean} remove If true, deleted without detached.
     * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)
     * @returns {Object}
     */
    detachRangeFormatElement: function(e, i, s, r, f) {
      const d = this.getRange();
      let o = d.startOffset, g = d.endOffset, u = t.getListChildNodes(e, function(B) {
        return B.parentNode === e;
      }), h = e.parentNode, y = null, T = null, L = e.cloneNode(!1);
      const k = [], N = t.isList(s);
      let V = !1, M = !1, D = !1;
      function _(B, x, S, R) {
        if (t.onlyZeroWidthSpace(x) && (x.innerHTML = t.zeroWidthSpace, o = g = 1), x.nodeType === 3)
          return B.insertBefore(x, S), x;
        const Z = (D ? x : R).childNodes;
        let W = x.cloneNode(!1), U = null, P = null;
        for (; Z[0]; )
          P = Z[0], t._notTextNode(P) && !t.isBreak(P) && !t.isListCell(W) ? (W.childNodes.length > 0 && (U || (U = W), B.insertBefore(W, S), W = x.cloneNode(!1)), B.insertBefore(P, S), U || (U = P)) : W.appendChild(P);
        if (W.childNodes.length > 0) {
          if (t.isListCell(B) && t.isListCell(W) && t.isList(S))
            if (N) {
              for (U = S; S; )
                W.appendChild(S), S = S.nextSibling;
              B.parentNode.insertBefore(W, B.nextElementSibling);
            } else {
              const I = R.nextElementSibling, $ = t.detachNestedList(R, !1);
              if (e !== $ || I !== R.nextElementSibling) {
                const j = W.childNodes;
                for (; j[0]; )
                  R.appendChild(j[0]);
                e = $, M = !0;
              }
            }
          else
            B.insertBefore(W, S);
          U || (U = W);
        }
        return U;
      }
      for (let B = 0, x = u.length, S, R, Z; B < x; B++)
        if (S = u[B], !(S.nodeType === 3 && t.isList(L)))
          if (D = !1, r && B === 0 && (!i || i.length === x || i[0] === S ? y = e.previousSibling : y = L), i && (R = i.indexOf(S)), i && R === -1)
            L || (L = e.cloneNode(!1)), L.appendChild(S);
          else {
            if (i && (Z = i[R + 1]), L && L.children.length > 0 && (h.insertBefore(L, e), L = null), !N && t.isListCell(S))
              if (Z && t.getElementDepth(S) !== t.getElementDepth(Z) && (t.isListCell(h) || t.getArrayItem(S.children, t.isList, !1))) {
                const W = S.nextElementSibling, U = t.detachNestedList(S, !1);
                (e !== U || W !== S.nextElementSibling) && (e = U, M = !0);
              } else {
                const W = S;
                S = t.createElement(r ? W.nodeName : t.isList(e.parentNode) || t.isListCell(e.parentNode) ? "LI" : t.isCell(e.parentNode) ? "DIV" : c.defaultTag);
                const U = t.isListCell(S), P = W.childNodes;
                for (; P[0] && !(t.isList(P[0]) && !U); )
                  S.appendChild(P[0]);
                t.copyFormatAttributes(S, W), D = !0;
              }
            else
              S = S.cloneNode(!1);
            if (!M && (r ? (k.push(S), t.removeItem(u[B])) : (s ? (V || (h.insertBefore(s, e), V = !0), S = _(s, S, null, u[B])) : S = _(h, S, e, u[B]), M || (i ? (T = S, y || (y = S)) : y || (y = T = S))), M)) {
              M = D = !1, u = t.getListChildNodes(e, function(W) {
                return W.parentNode === e;
              }), L = e.cloneNode(!1), h = e.parentNode, B = -1, x = u.length;
              continue;
            }
          }
      const A = e.parentNode;
      let H = e.nextSibling;
      L && L.children.length > 0 && A.insertBefore(L, H), s ? y = s.previousSibling : y || (y = e.previousSibling), H = e.nextSibling !== L ? e.nextSibling : L ? L.nextSibling : null, e.children.length === 0 || e.textContent.length === 0 ? t.removeItem(e) : t.removeEmptyNode(e, null, !1);
      let b = null;
      if (r)
        b = {
          cc: A,
          sc: y,
          so: o,
          ec: H,
          eo: g,
          removeArray: k
        };
      else {
        y || (y = T), T || (T = y);
        const B = t.getEdgeChildNodes(y, T.parentNode ? y : T);
        b = {
          cc: (B.sc || B.ec).parentNode,
          sc: B.sc,
          so: o,
          ec: B.ec,
          eo: g,
          removeArray: null
        };
      }
      if (this.effectNode = null, f)
        return b;
      !r && b && (i ? this.setRange(b.sc, o, b.ec, g) : this.setRange(b.sc, 0, b.sc, 0)), this.history.push(!1);
    },
    /**
     * @description "selectedFormats" array are detached from the list element.
     * The return value is applied when the first and last lines of "selectedFormats" are "LI" respectively.
     * @param {Array} selectedFormats Array of format elements (LI, P...) to remove.
     * @param {Boolean} remove If true, deleted without detached.
     * @returns {Object} {sc: <LI>, ec: <LI>}.
     */
    detachList: function(e, i) {
      let s = {}, r = !1, f = !1, d = null, o = null;
      const g = (function(u) {
        return !this.isComponent(u);
      }).bind(t);
      for (let u = 0, h = e.length, y, T, L, k; u < h; u++) {
        if (L = u === h - 1, T = t.getRangeFormatElement(e[u], g), k = t.isList(T), !y && k)
          y = T, s = { r: y, f: [t.getParentElement(e[u], "LI")] }, u === 0 && (r = !0);
        else if (y && k)
          if (y !== T) {
            const N = this.detachRangeFormatElement(s.f[0].parentNode, s.f, null, i, !0);
            T = e[u].parentNode, r && (d = N.sc, r = !1), L && (o = N.ec), k ? (y = T, s = { r: y, f: [t.getParentElement(e[u], "LI")] }, L && (f = !0)) : y = null;
          } else
            s.f.push(t.getParentElement(e[u], "LI")), L && (f = !0);
        if (L && t.isList(y)) {
          const N = this.detachRangeFormatElement(s.f[0].parentNode, s.f, null, i, !0);
          (f || h === 1) && (o = N.ec), r && (d = N.sc || o);
        }
      }
      return {
        sc: d,
        ec: o
      };
    },
    /**
     * @description Add, update, and delete nodes from selected text.
     * 1. If there is a node in the "appendNode" argument, a node with the same tags and attributes as "appendNode" is added to the selection text.
     * 2. If it is in the same tag, only the tag's attributes are changed without adding a tag.
     * 3. If the "appendNode" argument is null, the node of the selection is update or remove without adding a new node.
     * 4. The same style as the style attribute of the "styleArray" argument is deleted.
     *    (Styles should be put with attribute names from css. ["background-color"])
     * 5. The same class name as the class attribute of the "styleArray" argument is deleted.
     *    (The class name is preceded by "." [".className"])
     * 6. Use a list of styles and classes of "appendNode" in "styleArray" to avoid duplicate property values.
     * 7. If a node with all styles and classes removed has the same tag name as "appendNode" or "removeNodeArray", or "appendNode" is null, that node is deleted.
     * 8. Regardless of the style and class of the node, the tag with the same name as the "removeNodeArray" argument value is deleted.
     * 9. If the "strictRemove" argument is true, only nodes with all styles and classes removed from the nodes of "removeNodeArray" are removed.
     *10. It won't work if the parent node has the same class and same value style.
     *    However, if there is a value in "removeNodeArray", it works and the text node is separated even if there is no node to replace.
     * @param {Element|null} appendNode The element to be added to the selection. If it is null, only delete the node.
     * @param {Array|null} styleArray The style or className attribute name Array to check (['font-size'], ['.className'], ['font-family', 'color', '.className']...])
     * @param {Array|null} removeNodeArray An array of node names to remove types from, remove all formats when "appendNode" is null and there is an empty array or null value. (['span'], ['strong', 'em'] ...])
     * @param {Boolean|null} strictRemove If true, only nodes with all styles and classes removed from the nodes of "removeNodeArray" are removed.
     */
    nodeChange: function(e, i, s, r) {
      this._resetRangeToTextNode();
      let f = this.getRange_addLine(this.getRange(), null);
      i = i && i.length > 0 ? i : !1, s = s && s.length > 0 ? s : !1;
      const d = !e, o = d && !s && !i;
      let g = f.startContainer, u = f.startOffset, h = f.endContainer, y = f.endOffset;
      if (o && f.collapsed && t.isFormatElement(g.parentNode) || g === h && g.nodeType === 1 && t.isNonEditable(g)) {
        const P = g.parentNode;
        if (!t.isListCell(P) || !t.getValues(P.style).some((function(I) {
          return this._listKebab.indexOf(I) > -1;
        }).bind(this)))
          return;
      }
      if (f.collapsed && !o && g.nodeType === 1 && !t.isBreak(g) && !t.isComponent(g)) {
        let P = null;
        const I = g.childNodes[u];
        I && (I.nextSibling ? P = t.isBreak(I) ? I : I.nextSibling : P = null);
        const $ = t.createTextNode(t.zeroWidthSpace);
        g.insertBefore($, P), this.setRange($, 1, $, 1), f = this.getRange(), g = f.startContainer, u = f.startOffset, h = f.endContainer, y = f.endOffset;
      }
      t.isFormatElement(g) && (g = g.childNodes[u] || g.firstChild, u = 0), t.isFormatElement(h) && (h = h.childNodes[y] || h.lastChild, y = h.textContent.length), d && (e = t.createElement("DIV"));
      const T = w.RegExp, L = e.nodeName;
      if (!o && g === h && !s && e) {
        let P = g, I = 0;
        const $ = [], j = e.style;
        for (let Y = 0, Q = j.length; Y < Q; Y++)
          $.push(j[Y]);
        const X = e.classList;
        for (let Y = 0, Q = X.length; Y < Q; Y++)
          $.push("." + X[Y]);
        if ($.length > 0) {
          for (; !t.isFormatElement(P) && !t.isWysiwygDiv(P); ) {
            for (let Y = 0; Y < $.length; Y++)
              if (P.nodeType === 1) {
                const Q = $[Y], ne = /^\./.test(Q) ? new T("\\s*" + Q.replace(/^\./, "") + "(\\s+|$)", "ig") : !1, fe = d ? !!P.style[Q] : !!P.style[Q] && !!e.style[Q] && P.style[Q] === e.style[Q], J = ne === !1 ? !1 : d ? !!P.className.match(ne) : !!P.className.match(ne) && !!e.className.match(ne);
                (fe || J) && I++;
              }
            P = P.parentNode;
          }
          if (I >= $.length)
            return;
        }
      }
      let k = {}, N = {}, V, M = "", D = "", _ = "";
      if (i) {
        for (let P = 0, I = i.length, $; P < I; P++)
          $ = i[P], /^\./.test($) ? D += (D ? "|" : "\\s*(?:") + $.replace(/^\./, "") : M += (M ? "|" : "(?:;|^|\\s)(?:") + $;
        M && (M += ")\\s*:[^;]*\\s*(?:;|$)", M = new T(M, "ig")), D && (D += ")(?=\\s+|$)", D = new T(D, "ig"));
      }
      if (s) {
        _ = "^(?:" + s[0];
        for (let P = 1; P < s.length; P++)
          _ += "|" + s[P];
        _ += ")$", _ = new T(_, "i");
      }
      const A = w.Boolean, H = { v: !1 }, b = function(P) {
        const I = P.cloneNode(!1);
        if (I.nodeType === 3 || t.isBreak(I))
          return I;
        if (o)
          return null;
        const $ = !_ && d || _ && _.test(I.nodeName);
        if ($ && !r)
          return H.v = !0, null;
        const j = I.style.cssText;
        let X = "";
        M && j.length > 0 && (X = j.replace(M, "").trim(), X !== j && (H.v = !0));
        const Y = I.className;
        let Q = "";
        return D && Y.length > 0 && (Q = Y.replace(D, "").trim(), Q !== Y && (H.v = !0)), d && (D || !Y) && (M || !j) && !X && !Q && $ ? (H.v = !0, null) : X || Q || I.nodeName !== L || A(M) !== A(j) || A(D) !== A(Y) ? (M && j.length > 0 && (I.style.cssText = X), I.style.cssText || I.removeAttribute("style"), D && Y.length > 0 && (I.className = Q.trim()), I.className.trim() || I.removeAttribute("class"), !I.style.cssText && !I.className && (I.nodeName === L || $) ? (H.v = !0, null) : I) : (H.v = !0, null);
      }, B = this.getSelectedElements(null);
      f = this.getRange(), g = f.startContainer, u = f.startOffset, h = f.endContainer, y = f.endOffset, t.getFormatElement(g, null) || (g = t.getChildElement(B[0], function(P) {
        return P.nodeType === 3;
      }, !1), u = 0), t.getFormatElement(h, null) || (h = t.getChildElement(B[B.length - 1], function(P) {
        return P.nodeType === 3;
      }, !1), y = h.textContent.length);
      const x = t.getFormatElement(g, null) === t.getFormatElement(h, null), S = B.length - (x ? 0 : 1);
      V = e.cloneNode(!1);
      const R = o || d && function(P) {
        for (let I = 0, $ = P.length; I < $; I++)
          if (t._isMaintainedNode(P[I]) || t._isSizeNode(P[I]))
            return !0;
        return !1;
      }(s), Z = d || t._isSizeNode(V), W = this._util_getMaintainedNode.bind(t, R, Z), U = this._util_isMaintainedNode.bind(t, R, Z);
      if (x) {
        this._resetCommonListCell(B[0], i) && (f = this.setRange(g, u, h, y));
        const P = this._nodeChange_oneLine(B[0], V, b, g, u, h, y, o, d, f.collapsed, H, W, U);
        k.container = P.startContainer, k.offset = P.startOffset, N.container = P.endContainer, N.offset = P.endOffset, k.container === N.container && t.onlyZeroWidthSpace(k.container) && (k.offset = N.offset = 1), this._setCommonListStyle(P.ancestor, null);
      } else {
        let P = !1;
        S > 0 && this._resetCommonListCell(B[S], i) && (P = !0), this._resetCommonListCell(B[0], i) && (P = !0), P && this.setRange(g, u, h, y), S > 0 && (V = e.cloneNode(!1), N = this._nodeChange_endLine(B[S], V, b, h, y, o, d, H, W, U));
        for (let I = S - 1, $; I > 0; I--)
          this._resetCommonListCell(B[I], i), V = e.cloneNode(!1), $ = this._nodeChange_middleLine(B[I], V, b, o, d, H, N.container), $.endContainer && $.ancestor.contains($.endContainer) && (N.ancestor = null, N.container = $.endContainer), this._setCommonListStyle($.ancestor, null);
        V = e.cloneNode(!1), k = this._nodeChange_startLine(B[0], V, b, g, u, o, d, H, W, U, N.container), k.endContainer && (N.ancestor = null, N.container = k.endContainer), S <= 0 ? N = k : N.container || (N.ancestor = null, N.container = k.container, N.offset = k.container.textContent.length), this._setCommonListStyle(k.ancestor, null), this._setCommonListStyle(N.ancestor || t.getFormatElement(N.container), null);
      }
      this.controllersOff(), this.setRange(k.container, k.offset, N.container, N.offset), this.history.push(!1);
    },
    /**
     * @description Reset common style of list cell
     * @param {Element} el List cell element. <li>
     * @param {Array|null} styleArray Style array
     * @private
     */
    _resetCommonListCell: function(e, i) {
      if (!t.isListCell(e))
        return;
      i || (i = this._listKebab);
      const s = t.getArrayItem(e.childNodes, function(T) {
        return !t.isBreak(T);
      }, !0), r = e.style, f = [], d = [], o = t.getValues(r);
      for (let T = 0, L = this._listKebab.length; T < L; T++)
        o.indexOf(this._listKebab[T]) > -1 && i.indexOf(this._listKebab[T]) > -1 && (f.push(this._listCamel[T]), d.push(this._listKebab[T]));
      if (!f.length)
        return;
      const g = t.createElement("SPAN");
      for (let T = 0, L = f.length; T < L; T++)
        g.style[f[T]] = r[d[T]], r.removeProperty(d[T]);
      let u = g.cloneNode(!1), h = null, y = !1;
      for (let T = 0, L = s.length, k, N; T < L; T++)
        k = s[T], !c._textTagsMap[k.nodeName.toLowerCase()] && (N = t.getValues(k.style), N.length === 0 || f.some(function(V) {
          return N.indexOf(V) === -1;
        }) && N.some(function(V) {
        }) ? (h = k.nextSibling, u.appendChild(k)) : u.childNodes.length > 0 && (e.insertBefore(u, h), u = g.cloneNode(!1), h = null, y = !0));
      return u.childNodes.length > 0 && (e.insertBefore(u, h), y = !0), r.length || e.removeAttribute("style"), y;
    },
    /**
     * @description If certain styles are applied to all child nodes of the list cell, the style of the list cell is also changed. (bold, color, size)
     * @param {Element} el List cell element. <li>
     * @param {Element|null} child Variable for recursive call. ("null" on the first call)
     * @private
     */
    _setCommonListStyle: function(e, i) {
      if (!t.isListCell(e))
        return;
      const s = t.getArrayItem((i || e).childNodes, function(u) {
        return !t.isBreak(u);
      }, !0);
      if (i = s[0], !i || s.length > 1 || i.nodeType !== 1)
        return;
      const r = i.style, f = e.style, d = i.nodeName.toLowerCase();
      let o = !1;
      c._textTagsMap[d] === c._defaultCommand.bold.toLowerCase() && (f.fontWeight = "bold"), c._textTagsMap[d] === c._defaultCommand.italic.toLowerCase() && (f.fontStyle = "italic");
      const g = t.getValues(r);
      if (g.length > 0)
        for (let u = 0, h = this._listCamel.length; u < h; u++)
          g.indexOf(this._listKebab[u]) > -1 && (f[this._listCamel[u]] = r[this._listCamel[u]], r.removeProperty(this._listKebab[u]), o = !0);
      if (this._setCommonListStyle(e, i), !!o && !r.length) {
        const u = i.childNodes, h = i.parentNode, y = i.nextSibling;
        for (; u.length > 0; )
          h.insertBefore(u[0], y);
        t.removeItem(i);
      }
    },
    /**
     * @description Strip remove node
     * @param {Node} removeNode The remove node
     * @private
     */
    _stripRemoveNode: function(e) {
      const i = e.parentNode;
      if (!e || e.nodeType === 3 || !i)
        return;
      const s = e.childNodes;
      for (; s[0]; )
        i.insertBefore(s[0], e);
      i.removeChild(e);
    },
    /**
     * @description Return the parent maintained tag. (bind and use a util object)
     * @param {Element} element Element
     * @returns {Element}
     * @private
     */
    _util_getMaintainedNode: function(e, i, s) {
      return !s || e ? null : this.getParentElement(s, this._isMaintainedNode.bind(this)) || (i ? null : this.getParentElement(s, this._isSizeNode.bind(this)));
    },
    /**
     * @description Check if element is a tag that should be persisted. (bind and use a util object)
     * @param {Element} element Element
     * @returns {Element}
     * @private
     */
    _util_isMaintainedNode: function(e, i, s) {
      if (!s || e || s.nodeType !== 1)
        return !1;
      const r = this._isMaintainedNode(s);
      return this.getParentElement(s, this._isMaintainedNode.bind(this)) ? r : r || (i ? !1 : this._isSizeNode(s));
    },
    /**
     * @description wraps text nodes of line selected text.
     * @param {Element} element The node of the line that contains the selected text node.
     * @param {Element} newInnerNode The dom that will wrap the selected text area
     * @param {Function} validation Check if the node should be stripped.
     * @param {Node} startCon The startContainer property of the selection object.
     * @param {Number} startOff The startOffset property of the selection object.
     * @param {Node} endCon The endContainer property of the selection object.
     * @param {Number} endOff The endOffset property of the selection object.
     * @param {Boolean} isRemoveFormat Is the remove all formats command?
     * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
     * @param {Boolean} collapsed range.collapsed
     * @returns {{ancestor: *, startContainer: *, startOffset: *, endContainer: *, endOffset: *}}
     * @private
     */
    _nodeChange_oneLine: function(e, i, s, r, f, d, o, g, u, h, y, T, L) {
      let k = r.parentNode;
      for (; !k.nextSibling && !k.previousSibling && !t.isFormatElement(k.parentNode) && !t.isWysiwygDiv(k.parentNode) && k.nodeName !== i.nodeName; )
        k = k.parentNode;
      if (!u && k === d.parentNode && k.nodeName === i.nodeName && t.onlyZeroWidthSpace(r.textContent.slice(0, f)) && t.onlyZeroWidthSpace(d.textContent.slice(o))) {
        const J = k.childNodes;
        let le = !0;
        for (let te = 0, ue = J.length, oe, de, ae, ee; te < ue; te++) {
          if (oe = J[te], ee = !t.onlyZeroWidthSpace(oe), oe === r) {
            de = !0;
            continue;
          }
          if (oe === d) {
            ae = !0;
            continue;
          }
          if (!de && ee || de && ae && ee) {
            le = !1;
            break;
          }
        }
        if (le)
          return t.copyTagAttributes(k, i), {
            ancestor: e,
            startContainer: r,
            startOffset: f,
            endContainer: d,
            endOffset: o
          };
      }
      y.v = !1;
      const N = e, V = [i], M = e.cloneNode(!1), D = r === d;
      let _ = r, A = f, H = d, b = o, B = !1, x = !1, S, R, Z, W, U;
      const P = w.RegExp;
      function I(J) {
        const le = new P("(?:;|^|\\s)(?:" + W + "null)\\s*:[^;]*\\s*(?:;|$)", "ig");
        let te = "";
        return le && J.style.cssText.length > 0 && (te = le.test(J.style.cssText)), !te;
      }
      if (function J(le, te) {
        const ue = le.childNodes;
        for (let oe = 0, de = ue.length, ae; oe < de; oe++) {
          let ee = ue[oe];
          if (!ee)
            continue;
          let ve = te, ge;
          if (!B && ee === _) {
            let ce = M;
            U = T(ee);
            const ie = t.createTextNode(_.nodeType === 1 ? "" : _.substringData(0, A)), re = t.createTextNode(
              _.nodeType === 1 ? "" : _.substringData(
                A,
                D && b >= A ? b - A : _.data.length - A
              )
            );
            if (U) {
              const pe = T(te);
              if (pe && pe.parentNode !== ce) {
                let he = pe, ye = null;
                for (; he.parentNode !== ce; ) {
                  for (te = ye = he.parentNode.cloneNode(!1); he.childNodes[0]; )
                    ye.appendChild(he.childNodes[0]);
                  he.appendChild(ye), he = he.parentNode;
                }
                he.parentNode.appendChild(pe);
              }
              U = U.cloneNode(!1);
            }
            t.onlyZeroWidthSpace(ie) || te.appendChild(ie);
            const se = T(te);
            for (se && (U = se), U && (ce = U), R = ee, S = [], W = ""; R !== ce && R !== N && R !== null; )
              ae = L(R) ? null : s(R), ae && R.nodeType === 1 && I(R) && (S.push(ae), W += R.style.cssText.substr(0, R.style.cssText.indexOf(":")) + "|"), R = R.parentNode;
            const me = S.pop() || re;
            for (Z = R = me; S.length > 0; )
              R = S.pop(), Z.appendChild(R), Z = R;
            if (i.appendChild(me), ce.appendChild(i), U && !T(H) && (i = i.cloneNode(!1), M.appendChild(i), V.push(i)), _ = re, A = 0, B = !0, R !== re && R.appendChild(_), !D)
              continue;
          }
          if (!x && ee === H) {
            U = T(ee);
            const ce = t.createTextNode(H.nodeType === 1 ? "" : H.substringData(b, H.length - b)), ie = t.createTextNode(D || H.nodeType === 1 ? "" : H.substringData(0, b));
            if (U ? U = U.cloneNode(!1) : L(i.parentNode) && !U && (i = i.cloneNode(!1), M.appendChild(i), V.push(i)), !t.onlyZeroWidthSpace(ce)) {
              R = ee, W = "", S = [];
              const se = [];
              for (; R !== M && R !== N && R !== null; )
                R.nodeType === 1 && I(R) && (L(R) ? se.push(R.cloneNode(!1)) : S.push(R.cloneNode(!1)), W += R.style.cssText.substr(0, R.style.cssText.indexOf(":")) + "|"), R = R.parentNode;
              for (S = S.concat(se), ge = Z = R = S.pop() || ce; S.length > 0; )
                R = S.pop(), Z.appendChild(R), Z = R;
              M.appendChild(ge), R.textContent = ce.data;
            }
            if (U && ge) {
              const se = T(ge);
              se && (U = se);
            }
            for (R = ee, S = [], W = ""; R !== M && R !== N && R !== null; )
              ae = L(R) ? null : s(R), ae && R.nodeType === 1 && I(R) && (S.push(ae), W += R.style.cssText.substr(0, R.style.cssText.indexOf(":")) + "|"), R = R.parentNode;
            const re = S.pop() || ie;
            for (Z = R = re; S.length > 0; )
              R = S.pop(), Z.appendChild(R), Z = R;
            U ? (i = i.cloneNode(!1), i.appendChild(re), U.insertBefore(i, U.firstChild), M.appendChild(U), V.push(i), U = null) : i.appendChild(re), H = ie, b = ie.data.length, x = !0, !g && h && (i = ie, ie.textContent = t.zeroWidthSpace), R !== ie && R.appendChild(H);
            continue;
          }
          if (B) {
            if (ee.nodeType === 1 && !t.isBreak(ee)) {
              t._isIgnoreNodeChange(ee) ? (M.appendChild(ee.cloneNode(!0)), h || (i = i.cloneNode(!1), M.appendChild(i), V.push(i))) : J(ee, ee);
              continue;
            }
            R = ee, S = [], W = "";
            const ce = [];
            for (; R.parentNode !== null && R !== N && R !== i; )
              ae = x ? R.cloneNode(!1) : s(R), R.nodeType === 1 && !t.isBreak(ee) && ae && I(R) && (L(R) ? U || ce.push(ae) : S.push(ae), W += R.style.cssText.substr(0, R.style.cssText.indexOf(":")) + "|"), R = R.parentNode;
            S = S.concat(ce);
            const ie = S.pop() || ee;
            for (Z = R = ie; S.length > 0; )
              R = S.pop(), Z.appendChild(R), Z = R;
            if (L(i.parentNode) && !L(ie) && !t.onlyZeroWidthSpace(i) && (i = i.cloneNode(!1), M.appendChild(i), V.push(i)), !x && !U && L(ie)) {
              i = i.cloneNode(!1);
              const re = ie.childNodes;
              for (let se = 0, me = re.length; se < me; se++)
                i.appendChild(re[se]);
              ie.appendChild(i), M.appendChild(ie), V.push(i), i.children.length > 0 ? te = R : te = i;
            } else
              ie === ee ? x ? te = M : te = i : x ? (M.appendChild(ie), te = R) : (i.appendChild(ie), te = R);
            if (U && ee.nodeType === 3)
              if (T(ee)) {
                const re = t.getParentElement(te, (function(se) {
                  return this._isMaintainedNode(se.parentNode) || se.parentNode === M;
                }).bind(t));
                U.appendChild(re), i = re.cloneNode(!1), V.push(i), M.appendChild(i);
              } else
                U = null;
          }
          ge = ee.cloneNode(!1), te.appendChild(ge), ee.nodeType === 1 && !t.isBreak(ee) && (ve = ge), J(ee, ve);
        }
      }(e, M), u && !g && !y.v)
        return {
          ancestor: e,
          startContainer: r,
          startOffset: f,
          endContainer: d,
          endOffset: o
        };
      if (g = g && u, g)
        for (let J = 0; J < V.length; J++) {
          let le = V[J], te, ue, oe;
          if (h)
            te = t.createTextNode(t.zeroWidthSpace), M.replaceChild(te, le);
          else {
            const de = le.childNodes;
            for (ue = de[0]; de[0]; )
              oe = de[0], M.insertBefore(oe, le);
            t.removeItem(le);
          }
          J === 0 && (h ? _ = H = te : (_ = ue, H = oe));
        }
      else {
        if (u)
          for (let J = 0; J < V.length; J++)
            this._stripRemoveNode(V[J]);
        h && (_ = H = i);
      }
      t.removeEmptyNode(M, i, !1), h && (A = _.textContent.length, b = H.textContent.length);
      const $ = g || H.textContent.length === 0;
      !t.isBreak(H) && H.textContent.length === 0 && (t.removeItem(H), H = _), b = $ ? H.textContent.length : b;
      const j = { s: 0, e: 0 }, X = t.getNodePath(_, M, j), Y = !H.parentNode;
      Y && (H = _);
      const Q = { s: 0, e: 0 }, ne = t.getNodePath(H, M, !Y && !$ ? Q : null);
      A += j.s, b = h ? A : Y ? _.textContent.length : $ ? b + j.s : b + Q.s;
      const fe = t.mergeSameTags(M, [X, ne], !0);
      return e.parentNode.replaceChild(M, e), _ = t.getNodeFromPath(X, M), H = t.getNodeFromPath(ne, M), {
        ancestor: M,
        startContainer: _,
        startOffset: A + fe[0],
        endContainer: H,
        endOffset: b + fe[1]
      };
    },
    /**
     * @description wraps first line selected text.
     * @param {Element} element The node of the line that contains the selected text node.
     * @param {Element} newInnerNode The dom that will wrap the selected text area
     * @param {Function} validation Check if the node should be stripped.
     * @param {Node} startCon The startContainer property of the selection object.
     * @param {Number} startOff The startOffset property of the selection object.
     * @param {Boolean} isRemoveFormat Is the remove all formats command?
     * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
     * @returns {null|Node} If end container is renewed, returned renewed node
     * @returns {Object} { ancestor, container, offset, endContainer }
     * @private
     */
    _nodeChange_startLine: function(e, i, s, r, f, d, o, g, u, h, y) {
      let T = r.parentNode;
      for (; !T.nextSibling && !T.previousSibling && !t.isFormatElement(T.parentNode) && !t.isWysiwygDiv(T.parentNode) && T.nodeName !== i.nodeName; )
        T = T.parentNode;
      if (!o && T.nodeName === i.nodeName && !t.isFormatElement(T) && !T.nextSibling && t.onlyZeroWidthSpace(r.textContent.slice(0, f))) {
        let B = !0, x = r.previousSibling;
        for (; x; ) {
          if (!t.onlyZeroWidthSpace(x)) {
            B = !1;
            break;
          }
          x = x.previousSibling;
        }
        if (B)
          return t.copyTagAttributes(T, i), {
            ancestor: e,
            container: r,
            offset: f
          };
      }
      g.v = !1;
      const L = e, k = [i], N = e.cloneNode(!1);
      let V = r, M = f, D = !1, _, A, H, b;
      if (function B(x, S) {
        const R = x.childNodes;
        for (let Z = 0, W = R.length, U, P; Z < W; Z++) {
          const I = R[Z];
          if (!I)
            continue;
          let $ = S;
          if (D && !t.isBreak(I)) {
            if (I.nodeType === 1) {
              if (t._isIgnoreNodeChange(I)) {
                if (i = i.cloneNode(!1), P = I.cloneNode(!0), N.appendChild(P), N.appendChild(i), k.push(i), y && I.contains(y)) {
                  const Q = t.getNodePath(y, I);
                  y = t.getNodeFromPath(Q, P);
                }
              } else
                B(I, I);
              continue;
            }
            A = I, _ = [];
            const j = [];
            for (; A.parentNode !== null && A !== L && A !== i; )
              U = s(A), A.nodeType === 1 && U && (h(A) ? b || j.push(U) : _.push(U)), A = A.parentNode;
            _ = _.concat(j);
            const X = _.length > 0, Y = _.pop() || I;
            for (H = A = Y; _.length > 0; )
              A = _.pop(), H.appendChild(A), H = A;
            if (h(i.parentNode) && !h(Y) && (i = i.cloneNode(!1), N.appendChild(i), k.push(i)), !b && h(Y)) {
              i = i.cloneNode(!1);
              const Q = Y.childNodes;
              for (let ne = 0, fe = Q.length; ne < fe; ne++)
                i.appendChild(Q[ne]);
              Y.appendChild(i), N.appendChild(Y), S = h(A) ? i : A, k.push(i);
            } else
              X ? (i.appendChild(Y), S = A) : S = i;
            if (b && I.nodeType === 3)
              if (u(I)) {
                const Q = t.getParentElement(S, (function(ne) {
                  return this._isMaintainedNode(ne.parentNode) || ne.parentNode === N;
                }).bind(t));
                b.appendChild(Q), i = Q.cloneNode(!1), k.push(i), N.appendChild(i);
              } else
                b = null;
          }
          if (!D && I === V) {
            let j = N;
            b = u(I);
            const X = t.createTextNode(V.nodeType === 1 ? "" : V.substringData(0, M)), Y = t.createTextNode(V.nodeType === 1 ? "" : V.substringData(M, V.length - M));
            if (b) {
              const fe = u(S);
              if (fe && fe.parentNode !== j) {
                let J = fe, le = null;
                for (; J.parentNode !== j; ) {
                  for (S = le = J.parentNode.cloneNode(!1); J.childNodes[0]; )
                    le.appendChild(J.childNodes[0]);
                  J.appendChild(le), J = J.parentNode;
                }
                J.parentNode.appendChild(fe);
              }
              b = b.cloneNode(!1);
            }
            t.onlyZeroWidthSpace(X) || S.appendChild(X);
            const Q = u(S);
            for (Q && (b = Q), b && (j = b), A = S, _ = []; A !== j && A !== null; )
              U = s(A), A.nodeType === 1 && U && _.push(U), A = A.parentNode;
            const ne = _.pop() || S;
            for (H = A = ne; _.length > 0; )
              A = _.pop(), H.appendChild(A), H = A;
            ne !== S ? (i.appendChild(ne), S = A) : S = i, t.isBreak(I) && i.appendChild(I.cloneNode(!1)), j.appendChild(i), V = Y, M = 0, D = !0, S.appendChild(V);
            continue;
          }
          U = D ? s(I) : I.cloneNode(!1), U && (S.appendChild(U), I.nodeType === 1 && !t.isBreak(I) && ($ = U)), B(I, $);
        }
      }(e, N), o && !d && !g.v)
        return {
          ancestor: e,
          container: r,
          offset: f,
          endContainer: y
        };
      if (d = d && o, d)
        for (let B = 0; B < k.length; B++) {
          let x = k[B];
          const S = x.childNodes, R = S[0];
          for (; S[0]; )
            N.insertBefore(S[0], x);
          t.removeItem(x), B === 0 && (V = R);
        }
      else if (o) {
        i = i.firstChild;
        for (let B = 0; B < k.length; B++)
          this._stripRemoveNode(k[B]);
      }
      if (!d && N.childNodes.length === 0)
        e.childNodes ? V = e.childNodes[0] : (V = t.createTextNode(t.zeroWidthSpace), e.appendChild(V));
      else {
        t.removeEmptyNode(N, i, !1), t.onlyZeroWidthSpace(N.textContent) && (V = N.firstChild, M = 0);
        const B = { s: 0, e: 0 }, x = t.getNodePath(V, N, B);
        M += B.s;
        const S = t.mergeSameTags(N, [x], !0);
        e.parentNode.replaceChild(N, e), V = t.getNodeFromPath(x, N), M += S[0];
      }
      return {
        ancestor: N,
        container: V,
        offset: M,
        endContainer: y
      };
    },
    /**
     * @description wraps mid lines selected text.
     * @param {Element} element The node of the line that contains the selected text node.
     * @param {Element} newInnerNode The dom that will wrap the selected text area
     * @param {Function} validation Check if the node should be stripped.
     * @param {Boolean} isRemoveFormat Is the remove all formats command?
     * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
     * @param {Node} _endContainer Offset node of last line already modified (end.container)
     * @returns {Object} { ancestor, endContainer: "If end container is renewed, returned renewed node" }
     * @private
     */
    _nodeChange_middleLine: function(e, i, s, r, f, d, o) {
      if (!f) {
        let y = null;
        o && e.contains(o) && (y = t.getNodePath(o, e));
        const T = e.cloneNode(!0), L = i.nodeName, k = i.style.cssText, N = i.className;
        let V = T.childNodes, M = 0, D = V.length;
        for (let _; M < D && (_ = V[M], _.nodeType !== 3); M++)
          if (_.nodeName === L)
            _.style.cssText += k, t.addClass(_, N);
          else {
            if (!t.isBreak(_) && t._isIgnoreNodeChange(_))
              continue;
            if (D === 1) {
              V = _.childNodes, D = V.length, M = -1;
              continue;
            } else
              break;
          }
        if (D > 0 && M === D)
          return e.innerHTML = T.innerHTML, {
            ancestor: e,
            endContainer: y ? t.getNodeFromPath(y, e) : null
          };
      }
      d.v = !1;
      const g = e.cloneNode(!1), u = [i];
      let h = !0;
      if (function y(T, L) {
        const k = T.childNodes;
        for (let N = 0, V = k.length, M, D; N < V; N++) {
          let _ = k[N];
          if (!_)
            continue;
          let A = L;
          if (!t.isBreak(_) && t._isIgnoreNodeChange(_)) {
            if (i.childNodes.length > 0 && (g.appendChild(i), i = i.cloneNode(!1)), D = _.cloneNode(!0), g.appendChild(D), g.appendChild(i), u.push(i), L = i, o && _.contains(o)) {
              const H = t.getNodePath(o, _);
              o = t.getNodeFromPath(H, D);
            }
            continue;
          } else
            M = s(_), M && (h = !1, L.appendChild(M), _.nodeType === 1 && (A = M));
          t.isBreak(_) || y(_, A);
        }
      }(e, i), h || f && !r && !d.v)
        return { ancestor: e, endContainer: o };
      if (g.appendChild(i), r && f)
        for (let y = 0; y < u.length; y++) {
          let T = u[y];
          const L = T.childNodes;
          for (; L[0]; )
            g.insertBefore(L[0], T);
          t.removeItem(T);
        }
      else if (f) {
        i = i.firstChild;
        for (let y = 0; y < u.length; y++)
          this._stripRemoveNode(u[y]);
      }
      return t.removeEmptyNode(g, i, !1), t.mergeSameTags(g, null, !0), e.parentNode.replaceChild(g, e), { ancestor: g, endContainer: o };
    },
    /**
     * @description wraps last line selected text.
     * @param {Element} element The node of the line that contains the selected text node.
     * @param {Element} newInnerNode The dom that will wrap the selected text area
     * @param {Function} validation Check if the node should be stripped.
     * @param {Node} endCon The endContainer property of the selection object.
     * @param {Number} endOff The endOffset property of the selection object.
     * @param {Boolean} isRemoveFormat Is the remove all formats command?
     * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
     * @returns {Object} { ancestor, container, offset }
     * @private
     */
    _nodeChange_endLine: function(e, i, s, r, f, d, o, g, u, h) {
      let y = r.parentNode;
      for (; !y.nextSibling && !y.previousSibling && !t.isFormatElement(y.parentNode) && !t.isWysiwygDiv(y.parentNode) && y.nodeName !== i.nodeName; )
        y = y.parentNode;
      if (!o && y.nodeName === i.nodeName && !t.isFormatElement(y) && !y.previousSibling && t.onlyZeroWidthSpace(r.textContent.slice(f))) {
        let b = !0, B = r.nextSibling;
        for (; B; ) {
          if (!t.onlyZeroWidthSpace(B)) {
            b = !1;
            break;
          }
          B = B.nextSibling;
        }
        if (b)
          return t.copyTagAttributes(y, i), {
            ancestor: e,
            container: r,
            offset: f
          };
      }
      g.v = !1;
      const T = e, L = [i], k = e.cloneNode(!1);
      let N = r, V = f, M = !1, D, _, A, H;
      if (function b(B, x) {
        const S = B.childNodes;
        for (let R = S.length - 1, Z; 0 <= R; R--) {
          const W = S[R];
          if (!W)
            continue;
          let U = x;
          if (M && !t.isBreak(W)) {
            if (W.nodeType === 1) {
              if (t._isIgnoreNodeChange(W)) {
                i = i.cloneNode(!1);
                const j = W.cloneNode(!0);
                k.insertBefore(j, x), k.insertBefore(i, j), L.push(i);
              } else
                b(W, W);
              continue;
            }
            _ = W, D = [];
            const P = [];
            for (; _.parentNode !== null && _ !== T && _ !== i; )
              Z = s(_), Z && _.nodeType === 1 && (h(_) ? H || P.push(Z) : D.push(Z)), _ = _.parentNode;
            D = D.concat(P);
            const I = D.length > 0, $ = D.pop() || W;
            for (A = _ = $; D.length > 0; )
              _ = D.pop(), A.appendChild(_), A = _;
            if (h(i.parentNode) && !h($) && (i = i.cloneNode(!1), k.insertBefore(i, k.firstChild), L.push(i)), !H && h($)) {
              i = i.cloneNode(!1);
              const j = $.childNodes;
              for (let X = 0, Y = j.length; X < Y; X++)
                i.appendChild(j[X]);
              $.appendChild(i), k.insertBefore($, k.firstChild), L.push(i), i.children.length > 0 ? x = _ : x = i;
            } else
              I ? (i.insertBefore($, i.firstChild), x = _) : x = i;
            if (H && W.nodeType === 3)
              if (u(W)) {
                const j = t.getParentElement(x, (function(X) {
                  return this._isMaintainedNode(X.parentNode) || X.parentNode === k;
                }).bind(t));
                H.appendChild(j), i = j.cloneNode(!1), L.push(i), k.insertBefore(i, k.firstChild);
              } else
                H = null;
          }
          if (!M && W === N) {
            H = u(W);
            const P = t.createTextNode(N.nodeType === 1 ? "" : N.substringData(V, N.length - V)), I = t.createTextNode(N.nodeType === 1 ? "" : N.substringData(0, V));
            if (H) {
              H = H.cloneNode(!1);
              const j = u(x);
              if (j && j.parentNode !== k) {
                let X = j, Y = null;
                for (; X.parentNode !== k; ) {
                  for (x = Y = X.parentNode.cloneNode(!1); X.childNodes[0]; )
                    Y.appendChild(X.childNodes[0]);
                  X.appendChild(Y), X = X.parentNode;
                }
                X.parentNode.insertBefore(j, X.parentNode.firstChild);
              }
              H = H.cloneNode(!1);
            } else
              h(i.parentNode) && !H && (i = i.cloneNode(!1), k.appendChild(i), L.push(i));
            for (t.onlyZeroWidthSpace(P) || x.insertBefore(P, x.firstChild), _ = x, D = []; _ !== k && _ !== null; )
              Z = h(_) ? null : s(_), Z && _.nodeType === 1 && D.push(Z), _ = _.parentNode;
            const $ = D.pop() || x;
            for (A = _ = $; D.length > 0; )
              _ = D.pop(), A.appendChild(_), A = _;
            $ !== x ? (i.insertBefore($, i.firstChild), x = _) : x = i, t.isBreak(W) && i.appendChild(W.cloneNode(!1)), H ? (H.insertBefore(i, H.firstChild), k.insertBefore(H, k.firstChild), H = null) : k.insertBefore(i, k.firstChild), N = I, V = I.data.length, M = !0, x.insertBefore(N, x.firstChild);
            continue;
          }
          Z = M ? s(W) : W.cloneNode(!1), Z && (x.insertBefore(Z, x.firstChild), W.nodeType === 1 && !t.isBreak(W) && (U = Z)), b(W, U);
        }
      }(e, k), o && !d && !g.v)
        return {
          ancestor: e,
          container: r,
          offset: f
        };
      if (d = d && o, d)
        for (let b = 0; b < L.length; b++) {
          let B = L[b];
          const x = B.childNodes;
          let S = null;
          for (; x[0]; )
            S = x[0], k.insertBefore(S, B);
          t.removeItem(B), b === L.length - 1 && (N = S, V = S.textContent.length);
        }
      else if (o) {
        i = i.firstChild;
        for (let b = 0; b < L.length; b++)
          this._stripRemoveNode(L[b]);
      }
      if (!d && k.childNodes.length === 0)
        e.childNodes ? N = e.childNodes[0] : (N = t.createTextNode(t.zeroWidthSpace), e.appendChild(N));
      else {
        if (!o && i.textContent.length === 0)
          return t.removeEmptyNode(k, null, !1), {
            ancestor: null,
            container: null,
            offset: 0
          };
        t.removeEmptyNode(k, i, !1), t.onlyZeroWidthSpace(k.textContent) ? (N = k.firstChild, V = N.textContent.length) : t.onlyZeroWidthSpace(N) && (N = i, V = 1);
        const b = { s: 0, e: 0 }, B = t.getNodePath(N, k, b);
        V += b.s;
        const x = t.mergeSameTags(k, [B], !0);
        e.parentNode.replaceChild(k, e), N = t.getNodeFromPath(B, k), V += x[0];
      }
      return {
        ancestor: k,
        container: N,
        offset: N.nodeType === 1 && V === 1 ? N.childNodes.length : V
      };
    },
    /**
     * @description Run plugin calls and basic commands.
     * @param {String} command Command string
     * @param {String} display Display type string ('command', 'submenu', 'dialog', 'container')
     * @param {Element} target The element of command button
     */
    actionCall: function(e, i, s) {
      if (i) {
        if (/more/i.test(i)) {
          if (s !== this._moreLayerActiveButton) {
            const r = n.element.toolbar.querySelector("." + e);
            r && (this._moreLayerActiveButton && this.moreLayerOff(), this._moreLayerActiveButton = s, r.style.display = "block", p._showToolbarBalloon(), p._showToolbarInline()), t.addClass(s, "on");
          } else
            n.element.toolbar.querySelector("." + this._moreLayerActiveButton.getAttribute("data-command")) && (this.moreLayerOff(), p._showToolbarBalloon(), p._showToolbarInline());
          return;
        }
        if (/container/.test(i) && (this._menuTray[e] === null || s !== this.containerActiveButton)) {
          this.callPlugin(e, this.containerOn.bind(this, s), s);
          return;
        }
        if (this.isReadOnly && t.arrayIncludes(this.resizingDisabledButtons, s))
          return;
        if (/submenu/.test(i) && (this._menuTray[e] === null || s !== this.submenuActiveButton)) {
          this.callPlugin(e, this.submenuOn.bind(this, s), s);
          return;
        } else if (/dialog/.test(i)) {
          this.callPlugin(e, this.plugins[e].open.bind(this), s);
          return;
        } else
          /command/.test(i) ? this.callPlugin(e, this.plugins[e].action.bind(this), s) : /fileBrowser/.test(i) && this.callPlugin(e, this.plugins[e].open.bind(this, null), s);
      } else
        e && this.commandHandler(s, e);
      /submenu/.test(i) ? this.submenuOff() : /command/.test(i) || (this.submenuOff(), this.containerOff());
    },
    /**
     * @description Execute command of command button(All Buttons except submenu and dialog)
     * (selectAll, codeView, fullScreen, indent, outdent, undo, redo, removeFormat, print, preview, showBlocks, save, bold, underline, italic, strike, subscript, superscript, copy, cut, paste)
     * @param {Element|null} target The element of command button
     * @param {String} command Property of command button (data-value)
     */
    commandHandler: function(e, i) {
      if (!(a.isReadOnly && !/copy|cut|selectAll|codeView|fullScreen|print|preview|showBlocks/.test(i)))
        switch (i) {
          case "copy":
          case "cut":
            this.execCommand(i);
            break;
          case "paste":
            break;
          case "selectAll":
            this.containerOff(), this.controllersOff();
            const s = n.element.wysiwyg;
            let r = t.getChildElement(s.firstChild, function(u) {
              return u.childNodes.length === 0 || u.nodeType === 3;
            }, !1) || s.firstChild, f = t.getChildElement(s.lastChild, function(u) {
              return u.childNodes.length === 0 || u.nodeType === 3;
            }, !0) || s.lastChild;
            if (!r || !f)
              return;
            if (t.isMedia(r)) {
              const u = this.getFileComponent(r), h = t.createElement("BR"), y = t.createElement(c.defaultTag);
              y.appendChild(h), r = u ? u.component : r, r.parentNode.insertBefore(y, r), r = h;
            }
            if (t.isMedia(f)) {
              const u = t.createElement("BR"), h = t.createElement(c.defaultTag);
              h.appendChild(u), s.appendChild(h), f = u;
            }
            p._showToolbarBalloon(this.setRange(r, 0, f, f.textContent.length));
            break;
          case "codeView":
            this.toggleCodeView();
            break;
          case "fullScreen":
            this.toggleFullScreen(e);
            break;
          case "indent":
          case "outdent":
            this.indent(i);
            break;
          case "undo":
            this.history.undo();
            break;
          case "redo":
            this.history.redo();
            break;
          case "removeFormat":
            this.removeFormat(), this.focus();
            break;
          case "print":
            this.print();
            break;
          case "preview":
            this.preview();
            break;
          case "showBlocks":
            this.toggleDisplayBlocks();
            break;
          case "dir":
            this.setDir(c.rtl ? "ltr" : "rtl");
            break;
          case "dir_ltr":
            this.setDir("ltr");
            break;
          case "dir_rtl":
            this.setDir("rtl");
            break;
          case "save":
            if (typeof c.callBackSave == "function")
              c.callBackSave(this.getContents(!1), this._variable.isChanged);
            else if (this._variable.isChanged && typeof O.save == "function")
              O.save();
            else
              throw Error("[SUNEDITOR.core.commandHandler.fail] Please register call back function in creation option. (callBackSave : Function)");
            this._variable.isChanged = !1, n.tool.save && n.tool.save.setAttribute("disabled", !0);
            break;
          default:
            i = c._defaultCommand[i.toLowerCase()] || i, this.commandMap[i] || (this.commandMap[i] = e);
            const d = this._variable.currentNodesMap, o = d.indexOf(i) > -1 ? null : t.createElement(i);
            let g = i;
            /^SUB$/i.test(i) && d.indexOf("SUP") > -1 ? g = "SUP" : /^SUP$/i.test(i) && d.indexOf("SUB") > -1 && (g = "SUB"), this.nodeChange(o, this._commandMapStyles[i] || null, [g], !1), this.focus();
        }
    },
    /**
     * @description Remove format of the currently selected range
     */
    removeFormat: function() {
      this.nodeChange(null, null, null, null);
    },
    /**
     * @description This method implements indentation to selected range.
     * Setted "margin-left" to "25px" in the top "P" tag of the parameter node.
     * @param {String} command Separator ("indent" or "outdent")
     */
    indent: function(e) {
      const i = this.getRange(), s = this.getSelectedElements(null), r = [], f = e !== "indent", d = c.rtl ? "marginRight" : "marginLeft";
      let o = i.startContainer, g = i.endContainer, u = i.startOffset, h = i.endOffset;
      for (let y = 0, T = s.length, L, k; y < T; y++)
        L = s[y], !t.isListCell(L) || !this.plugins.list ? (k = /\d+/.test(L.style[d]) ? t.getNumber(L.style[d], 0) : 0, f ? k -= 25 : k += 25, t.setStyle(L, d, k <= 0 ? "" : k + "px")) : (f || L.previousElementSibling) && r.push(L);
      r.length > 0 && this.plugins.list.editInsideList.call(this, f, r), this.effectNode = null, this.setRange(o, u, g, h), this.history.push(!1);
    },
    /**
     * @description Add or remove the class name of "body" so that the code block is visible
     */
    toggleDisplayBlocks: function() {
      const e = n.element.wysiwyg;
      t.toggleClass(e, "se-show-block"), t.hasClass(e, "se-show-block") ? t.addClass(this._styleCommandMap.showBlocks, "active") : t.removeClass(this._styleCommandMap.showBlocks, "active"), this._resourcesStateChange();
    },
    /**
     * @description Changes to code view or wysiwyg view
     */
    toggleCodeView: function() {
      const e = this._variable.isCodeView;
      this.controllersOff(), t.setDisabledButtons(!e, this.codeViewDisabledButtons), e ? (t.isNonEditable(n.element.wysiwygFrame) || this._setCodeDataToEditor(), n.element.wysiwygFrame.scrollTop = 0, n.element.code.style.display = "none", n.element.wysiwygFrame.style.display = "block", this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: none"), this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: block"), c.height === "auto" && !c.codeMirrorEditor && (n.element.code.style.height = "0px"), this._variable.isCodeView = !1, this._variable.isFullScreen || (this._notHideToolbar = !1, /balloon|balloon-always/i.test(c.mode) && (n.element._arrow.style.display = "", this._isInline = !1, this._isBalloon = !0, p._hideToolbar())), this.nativeFocus(), t.removeClass(this._styleCommandMap.codeView, "active"), t.isNonEditable(n.element.wysiwygFrame) || (this.history.push(!1), this.history._resetCachingButton())) : (this._setEditorDataToCodeView(), this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: block"), this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: none"), this._variable.isFullScreen ? n.element.code.style.height = "100%" : c.height === "auto" && !c.codeMirrorEditor && (n.element.code.style.height = n.element.code.scrollHeight > 0 ? n.element.code.scrollHeight + "px" : "auto"), c.codeMirrorEditor && c.codeMirrorEditor.refresh(), this._variable.isCodeView = !0, this._variable.isFullScreen || (this._notHideToolbar = !0, this._isBalloon && (n.element._arrow.style.display = "none", n.element.toolbar.style.left = "", this._isInline = !0, this._isBalloon = !1, p._showToolbarInline())), this._variable._range = null, n.element.code.focus(), t.addClass(this._styleCommandMap.codeView, "active")), this._checkPlaceholder(), this.isReadOnly && t.setDisabledButtons(!0, this.resizingDisabledButtons), typeof O.toggleCodeView == "function" && O.toggleCodeView(this._variable.isCodeView, this);
    },
    /**
     * @description Convert the data of the code view and put it in the WYSIWYG area.
     * @private
     */
    _setCodeDataToEditor: function() {
      const e = this._getCodeView();
      if (c.fullPage) {
        const i = this._parser.parseFromString(e, "text/html");
        if (!this.options.__allowedScriptTag) {
          const f = i.head.children;
          for (let d = 0, o = f.length; d < o; d++)
            /^script$/i.test(f[d].tagName) && (i.head.removeChild(f[d]), d--, o--);
        }
        let s = i.head.innerHTML;
        (!i.head.querySelector('link[rel="stylesheet"]') || this.options.height === "auto" && !i.head.querySelector("style")) && (s += t._setIframeCssTags(this.options)), this._wd.head.innerHTML = s, this._wd.body.innerHTML = this.convertContentsForEditor(i.body.innerHTML);
        const r = i.body.attributes;
        for (let f = 0, d = r.length; f < d; f++)
          r[f].name !== "contenteditable" && this._wd.body.setAttribute(r[f].name, r[f].value);
        if (!t.hasClass(this._wd.body, "sun-editor-editable")) {
          const f = c._editableClass.split(" ");
          for (let d = 0; d < f.length; d++)
            t.addClass(this._wd.body, c._editableClass[d]);
        }
      } else
        n.element.wysiwyg.innerHTML = e.length > 0 ? this.convertContentsForEditor(e) : "<" + c.defaultTag + "><br></" + c.defaultTag + ">";
    },
    /**
     * @description Convert the data of the WYSIWYG area and put it in the code view area.
     * @private
     */
    _setEditorDataToCodeView: function() {
      const e = this.convertHTMLForCodeView(n.element.wysiwyg, !1);
      let i = "";
      if (c.fullPage) {
        const s = t.getAttributesToString(this._wd.body, null);
        i = `<!DOCTYPE html>
<html>
` + this._wd.head.outerHTML.replace(/>(?!\n)/g, `>
`) + "<body " + s + `>
` + e + `</body>
</html>`;
      } else
        i = e;
      n.element.code.style.display = "block", n.element.wysiwygFrame.style.display = "none", this._setCodeView(i);
    },
    /**
     * @description Changes to full screen or default screen
     * @param {Element|null} element full screen button
     */
    toggleFullScreen: function(e) {
      const i = n.element.topArea, s = n.element.toolbar, r = n.element.editorArea, f = n.element.wysiwygFrame, d = n.element.code, o = this._variable;
      this.controllersOff();
      const g = s.style.display === "none" || this._isInline && !this._inlineToolbarAttr.isShow;
      o.isFullScreen ? (o.isFullScreen = !1, f.style.cssText = o._wysiwygOriginCssText, d.style.cssText = o._codeOriginCssText, s.style.cssText = "", r.style.cssText = o._editorAreaOriginCssText, i.style.cssText = o._originCssText, E.body.style.overflow = o._bodyOverflow, c.height === "auto" && !c.codeMirrorEditor && p._codeViewAutoHeight(), c.toolbarContainer && c.toolbarContainer.appendChild(s), c.stickyToolbar > -1 && t.removeClass(s, "se-toolbar-sticky"), o._fullScreenAttrs.sticky && !c.toolbarContainer && (o._fullScreenAttrs.sticky = !1, n.element._stickyDummy.style.display = "block", t.addClass(s, "se-toolbar-sticky")), this._isInline = o._fullScreenAttrs.inline, this._isBalloon = o._fullScreenAttrs.balloon, this._isInline && p._showToolbarInline(), c.toolbarContainer && t.removeClass(s, "se-toolbar-balloon"), p.onScroll_window(), e && t.changeElement(e.firstElementChild, F.expansion), n.element.topArea.style.marginTop = "", t.removeClass(this._styleCommandMap.fullScreen, "active")) : (o.isFullScreen = !0, o._fullScreenAttrs.inline = this._isInline, o._fullScreenAttrs.balloon = this._isBalloon, (this._isInline || this._isBalloon) && (this._isInline = !1, this._isBalloon = !1), c.toolbarContainer && n.element.relative.insertBefore(s, r), i.style.position = "fixed", i.style.top = "0", i.style.left = "0", i.style.width = "100%", i.style.maxWidth = "100%", i.style.height = "100%", i.style.zIndex = "2147483647", n.element._stickyDummy.style.display !== "" && (o._fullScreenAttrs.sticky = !0, n.element._stickyDummy.style.display = "none", t.removeClass(s, "se-toolbar-sticky")), o._bodyOverflow = E.body.style.overflow, E.body.style.overflow = "hidden", o._editorAreaOriginCssText = r.style.cssText, o._wysiwygOriginCssText = f.style.cssText, o._codeOriginCssText = d.style.cssText, r.style.cssText = s.style.cssText = "", f.style.cssText = (f.style.cssText.match(/\s?display(\s+)?:(\s+)?[a-zA-Z]+;/) || [""])[0] + c._editorStyles.editor, d.style.cssText = (d.style.cssText.match(/\s?display(\s+)?:(\s+)?[a-zA-Z]+;/) || [""])[0], s.style.width = f.style.height = d.style.height = "100%", s.style.position = "relative", s.style.display = "block", o.innerHeight_fullScreen = w.innerHeight - s.offsetHeight, r.style.height = o.innerHeight_fullScreen - c.fullScreenOffset + "px", e && t.changeElement(e.firstElementChild, F.reduction), c.iframe && c.height === "auto" && (r.style.overflow = "auto", this._iframeAutoHeight()), n.element.topArea.style.marginTop = c.fullScreenOffset + "px", t.addClass(this._styleCommandMap.fullScreen, "active")), g && O.toolbar.hide(), typeof O.toggleFullScreen == "function" && O.toggleFullScreen(this._variable.isFullScreen, this);
    },
    /**
     * @description Prints the current contents of the editor.
     */
    print: function() {
      const e = t.createElement("IFRAME");
      e.style.display = "none", E.body.appendChild(e);
      const i = c.printTemplate ? c.printTemplate.replace(/\{\{\s*contents\s*\}\}/i, this.getContents(!0)) : this.getContents(!0), s = t.getIframeDocument(e), r = this._wd;
      if (c.iframe) {
        const f = c._printClass !== null ? 'class="' + c._printClass + '"' : c.fullPage ? t.getAttributesToString(r.body, ["contenteditable"]) : 'class="' + c._editableClass + '"';
        s.write(
          "<!DOCTYPE html><html><head>" + r.head.innerHTML + "</head><body " + f + ">" + i + "</body></html>"
        );
      } else {
        const f = E.head.getElementsByTagName("link"), d = E.head.getElementsByTagName("style");
        let o = "";
        for (let g = 0, u = f.length; g < u; g++)
          o += f[g].outerHTML;
        for (let g = 0, u = d.length; g < u; g++)
          o += d[g].outerHTML;
        s.write(
          "<!DOCTYPE html><html><head>" + o + '</head><body class="' + (c._printClass !== null ? c._printClass : c._editableClass) + '">' + i + "</body></html>"
        );
      }
      this.showLoading(), w.setTimeout(function() {
        try {
          if (e.focus(), t.isIE_Edge || t.isChromium || E.documentMode || w.StyleMedia)
            try {
              e.contentWindow.document.execCommand("print", !1, null);
            } catch {
              e.contentWindow.print();
            }
          else
            e.contentWindow.print();
        } catch (f) {
          throw Error("[SUNEDITOR.core.print.fail] error: " + f);
        } finally {
          a.closeLoading(), t.removeItem(e);
        }
      }, 1e3);
    },
    /**
     * @description Open the preview window.
     */
    preview: function() {
      a.submenuOff(), a.containerOff(), a.controllersOff();
      const e = c.previewTemplate ? c.previewTemplate.replace(/\{\{\s*contents\s*\}\}/i, this.getContents(!0)) : this.getContents(!0), i = w.open("", "_blank");
      i.mimeType = "text/html";
      const s = this._wd;
      if (c.iframe) {
        const r = c._printClass !== null ? 'class="' + c._printClass + '"' : c.fullPage ? t.getAttributesToString(s.body, ["contenteditable"]) : 'class="' + c._editableClass + '"';
        i.document.write(
          "<!DOCTYPE html><html><head>" + s.head.innerHTML + "<style>body {overflow:auto !important; margin: 10px auto !important; height:auto !important; outline:1px dashed #ccc;}</style></head><body " + r + ">" + e + "</body></html>"
        );
      } else {
        const r = E.head.getElementsByTagName("link"), f = E.head.getElementsByTagName("style");
        let d = "";
        for (let o = 0, g = r.length; o < g; o++)
          d += r[o].outerHTML;
        for (let o = 0, g = f.length; o < g; o++)
          d += f[o].outerHTML;
        i.document.write(
          '<!DOCTYPE html><html><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>' + C.toolbar.preview + "</title>" + d + '</head><body class="' + (c._printClass !== null ? c._printClass : c._editableClass) + '" style="margin:10px auto !important; height:auto !important; outline:1px dashed #ccc;">' + e + "</body></html>"
        );
      }
    },
    /**
     * @description Set direction to "rtl" or "ltr".
     * @param {String} dir "rtl" or "ltr"
     */
    setDir: function(e) {
      const i = e === "rtl", s = this._prevRtl !== i;
      this._prevRtl = c.rtl = i, s && (this.plugins.align && this.plugins.align.exchangeDir.call(this), n.tool.indent && t.changeElement(n.tool.indent.firstElementChild, F.indent), n.tool.outdent && t.changeElement(n.tool.outdent.firstElementChild, F.outdent));
      const r = n.element;
      i ? (t.addClass(r.topArea, "se-rtl"), t.addClass(r.wysiwygFrame, "se-rtl")) : (t.removeClass(r.topArea, "se-rtl"), t.removeClass(r.wysiwygFrame, "se-rtl"));
      const f = t.getListChildren(r.wysiwyg, function(o) {
        return t.isFormatElement(o) && (o.style.marginRight || o.style.marginLeft || o.style.textAlign);
      });
      for (let o = 0, g = f.length, u, h, y; o < g; o++)
        u = f[o], y = u.style.marginRight, h = u.style.marginLeft, (y || h) && (u.style.marginRight = h, u.style.marginLeft = y), y = u.style.textAlign, y === "left" ? u.style.textAlign = "right" : y === "right" && (u.style.textAlign = "left");
      const d = n.tool;
      d.dir && (t.changeTxt(d.dir.querySelector(".se-tooltip-text"), C.toolbar[c.rtl ? "dir_ltr" : "dir_rtl"]), t.changeElement(d.dir.firstElementChild, F[c.rtl ? "dir_ltr" : "dir_rtl"])), d.dir_ltr && (i ? t.removeClass(d.dir_ltr, "active") : t.addClass(d.dir_ltr, "active")), d.dir_rtl && (i ? t.addClass(d.dir_rtl, "active") : t.removeClass(d.dir_rtl, "active"));
    },
    /**
     * @description Sets the HTML string
     * @param {String|undefined} html HTML string
     */
    setContents: function(e) {
      this.removeRange();
      const i = e == null ? "" : this.convertContentsForEditor(e, null, null);
      if (!this._variable.isCodeView)
        n.element.wysiwyg.innerHTML = i, this._resetComponents(), this.history.push(!1);
      else {
        const s = this.convertHTMLForCodeView(i, !1);
        this._setCodeView(s);
      }
    },
    /**
     * @description Sets the contents of the iframe's head tag and body tag when using the "iframe" or "fullPage" option.
     * @param {Object} ctx { head: HTML string, body: HTML string}
     */
    setIframeContents: function(e) {
      if (!c.iframe)
        return !1;
      e.head && (this._wd.head.innerHTML = this.options.__allowedScriptTag ? e.head : e.head.replace(this.__scriptTagRegExp, "")), e.body && (this._wd.body.innerHTML = this.convertContentsForEditor(e.body)), this._resetComponents();
    },
    /**
     * @description Gets the current contents
     * @param {Boolean} onlyContents Return only the contents of the body without headers when the "fullPage" option is true
     * @returns {Object}
     */
    getContents: function(e) {
      const i = this.cleanHTML(n.element.wysiwyg.innerHTML, null, null), s = t.createElement("DIV");
      s.innerHTML = i;
      const r = t.getListChildren(s, function(f) {
        return f.hasAttribute("contenteditable");
      });
      for (let f = 0, d = r.length; f < d; f++)
        r[f].removeAttribute("contenteditable");
      if (c.fullPage && !e) {
        const f = t.getAttributesToString(this._wd.body, ["contenteditable"]);
        return "<!DOCTYPE html><html>" + this._wd.head.outerHTML + "<body " + f + ">" + s.innerHTML + "</body></html>";
      } else
        return s.innerHTML;
    },
    /**
     * @description Gets the current contents with containing parent div(div.sun-editor-editable).
     * <div class="sun-editor-editable">{contents}</div>
     * @param {Boolean} onlyContents Return only the contents of the body without headers when the "fullPage" option is true
     * @returns {String}
     */
    getFullContents: function(e) {
      return '<div class="sun-editor-editable' + (c.rtl ? " se-rtl" : "") + '">' + this.getContents(e) + "</div>";
    },
    /**
     * @description Returns HTML string according to tag type and configuration.
     * Use only "cleanHTML"
     * @param {Node} node Node
     * @param {Boolean} requireFormat If true, text nodes that do not have a format node is wrapped with the format tag.
     * @private
     */
    _makeLine: function(e, i) {
      const s = c.defaultTag;
      if (e.nodeType === 1) {
        if (this.__disallowedTagNameRegExp.test(e.nodeName))
          return "";
        if (/__se__tag/.test(e.className))
          return e.outerHTML;
        const r = t.getListChildNodes(e, function(f) {
          return t.isSpanWithoutAttr(f) && !t.getParentElement(f, t.isNotCheckingNode);
        }) || [];
        for (let f = r.length - 1; f >= 0; f--)
          r[f].outerHTML = r[f].innerHTML;
        return !i || t.isFormatElement(e) || t.isRangeFormatElement(e) || t.isComponent(e) || t.isMedia(e) || t.isAnchor(e) && t.isMedia(e.firstElementChild) ? t.isSpanWithoutAttr(e) ? e.innerHTML : e.outerHTML : "<" + s + ">" + (t.isSpanWithoutAttr(e) ? e.innerHTML : e.outerHTML) + "</" + s + ">";
      }
      if (e.nodeType === 3) {
        if (!i)
          return t._HTMLConvertor(e.textContent);
        const r = e.textContent.split(/\n/g);
        let f = "";
        for (let d = 0, o = r.length, g; d < o; d++)
          g = r[d].trim(), g.length > 0 && (f += "<" + s + ">" + t._HTMLConvertor(g) + "</" + s + ">");
        return f;
      }
      return e.nodeType === 8 && this._allowHTMLComments ? "<!--" + e.textContent.trim() + "-->" : "";
    },
    /**
     * @description Removes attribute values such as style and converts tags that do not conform to the "html5" standard.
     * @param {String} text 
     * @returns {String} HTML string
     * @private
     */
    _tagConvertor: function(e) {
      if (!this._disallowedTextTagsRegExp)
        return e;
      const i = c._textTagsMap;
      return e.replace(this._disallowedTextTagsRegExp, function(s, r, f, d) {
        return r + (typeof i[f] == "string" ? i[f] : f) + (d ? " " + d : "");
      });
    },
    /**
     * @description Delete disallowed tags
     * @param {String} html HTML string
     * @returns {String}
     * @private
     */
    _deleteDisallowedTags: function(e) {
      return e = e.replace(this.__disallowedTagsRegExp, "").replace(/<[a-z0-9]+\:[a-z0-9]+[^>^\/]*>[^>]*<\/[a-z0-9]+\:[a-z0-9]+>/gi, ""), /\bfont\b/i.test(this.options._editorTagsWhitelist) || (e = e.replace(/(<\/?)font(\s?)/gi, "$1span$2")), e.replace(this.editorTagsWhitelistRegExp, "").replace(this.editorTagsBlacklistRegExp, "");
    },
    _convertFontSize: function(e, i) {
      const s = this._w.Math, r = i.match(/(\d+(?:\.\d+)?)(.+)/), f = r ? r[1] * 1 : t.fontValueMap[i], d = r ? r[2] : "rem";
      let o = f;
      switch (/em/.test(d) ? o = s.round(f / 0.0625) : d === "pt" ? o = s.round(f * 1.333) : d === "%" && (o = f / 100), e) {
        case "em":
        case "rem":
        case "%":
          return (o * 0.0625).toFixed(2) + e;
        case "pt":
          return s.floor(o / 1.333) + e;
        default:
          return o + e;
      }
    },
    _cleanStyle: function(e, i, s) {
      let r = (e.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/) || [])[0];
      if (/span/i.test(s) && !r && (e.match(/<span\s(.+)/) || [])[1]) {
        const f = (e.match(/\ssize="([^"]+)"/i) || [])[1], d = (e.match(/\sface="([^"]+)"/i) || [])[1], o = (e.match(/\scolor="([^"]+)"/i) || [])[1];
        (f || d || o) && (r = 'style="' + (f ? "font-size:" + this.util.getNumber(f / 3.333, 1) + "rem;" : "") + (d ? "font-family:" + d + ";" : "") + (o ? "color:" + o + ";" : "") + '"');
      }
      if (r) {
        i || (i = []);
        const f = r.replace(/&quot;/g, "").match(this._cleanStyleRegExp[s]);
        if (f) {
          const d = [];
          for (let o = 0, g = f.length, u; o < g; o++)
            if (u = f[o].match(/([a-zA-Z0-9-]+)(:)([^"]+)/), u && !/inherit|initial|revert|unset/i.test(u[3])) {
              const h = t.kebabToCamelCase(u[1].trim()), y = this.wwComputedStyle[h].replace(/"/g, ""), T = u[3].trim();
              switch (h) {
                case "fontFamily":
                  if (!c.plugins.font || c.font.indexOf(T) === -1)
                    continue;
                  break;
                case "fontSize":
                  if (!c.plugins.fontSize)
                    continue;
                  this._cleanStyleRegExp.fontSizeUnit.test(u[0]) || (u[0] = u[0].replace((u[0].match(/:\s*([^;]+)/) || [])[1], this._convertFontSize.bind(this, c.fontSizeUnit)));
                  break;
                case "color":
                  if (!c.plugins.fontColor || /rgba\(([0-9]+\s*,\s*){3}0\)|windowtext/i.test(T))
                    continue;
                  break;
                case "backgroundColor":
                  if (!c.plugins.hiliteColor || /rgba\(([0-9]+\s*,\s*){3}0\)|windowtext/i.test(T))
                    continue;
                  break;
              }
              y !== T && d.push(u[0]);
            }
          d.length > 0 && i.push('style="' + d.join(";") + '"');
        }
      }
      return i;
    },
    /**
     * @description Tag and tag attribute check RegExp function. (used by "cleanHTML" and "convertContentsForEditor")
     * @param {Boolean} lowLevelCheck Row level check
     * @param {String} m RegExp value
     * @param {String} t RegExp value
     * @returns {String}
     * @private
     */
    _cleanTags: function(e, i, s) {
      if (/^<[a-z0-9]+\:[a-z0-9]+/i.test(i))
        return i;
      let r = null;
      const f = s.match(/(?!<)[a-zA-Z0-9\-]+/)[0].toLowerCase(), d = this._attributesTagsBlacklist[f];
      i = i.replace(/\s(?:on[a-z]+)\s*=\s*(")[^"]*\1/ig, ""), d ? i = i.replace(d, "") : i = i.replace(this._attributesBlacklistRegExp, "");
      const o = this._attributesTagsWhitelist[f];
      if (o ? r = i.match(o) : r = i.match(e ? this._attributesWhitelistRegExp : this._attributesWhitelistRegExp_all_data), e || f === "span")
        if (f === "a") {
          const g = i.match(/(?:(?:id|name)\s*=\s*(?:"|')[^"']*(?:"|'))/g);
          g && (r || (r = []), r.push(g[0]));
        } else
          (!r || !/style=/i.test(r.toString())) && (f === "span" ? r = this._cleanStyle(i, r, "span") : /^(P|DIV|H[1-6]|PRE)$/i.test(f) && (r = this._cleanStyle(i, r, "format")));
      else {
        const g = i.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/);
        g && !r ? r = [g[0]] : g && !r.some(function(u) {
          return /^style/.test(u.trim());
        }) && r.push(g[0]);
      }
      if (t.isFigures(f)) {
        const g = i.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/);
        r || (r = []), g && r.push(g[0]);
      }
      if (r)
        for (let g = 0, u = r.length, h; g < u; g++)
          h = /^(?:href|src)\s*=\s*('|"|\s)*javascript\s*\:/i.test(r[g].trim()) ? "" : r[g], s += (/^\s/.test(h) ? "" : " ") + h;
      return s;
    },
    /**
     * @description Determines if formatting is required and returns a domTree
     * @param {Element} dom documentFragment
     * @returns {Element}
     * @private
     */
    _editFormat: function(e) {
      let i = "", s;
      const r = e.childNodes;
      for (let f = 0, d = r.length, o; f < d; f++)
        o = r[f], o.nodeType === 8 ? i += "<!-- " + o.textContent + " -->" : !t.isFormatElement(o) && !t.isRangeFormatElement(o) && !t.isComponent(o) && !/meta/i.test(o.nodeName) ? (s || (s = t.createElement(c.defaultTag)), s.appendChild(o), f--, d--) : (s && (i += s.outerHTML, s = null), i += o.outerHTML);
      return s && (i += s.outerHTML), E.createRange().createContextualFragment(i);
    },
    _convertListCell: function(e) {
      let i = "";
      for (let s = 0, r = e.length, f; s < r; s++)
        f = e[s], f.nodeType === 1 ? t.isList(f) ? i += f.innerHTML : t.isListCell(f) ? i += f.outerHTML : t.isFormatElement(f) ? i += "<li>" + (f.innerHTML.trim() || "<br>") + "</li>" : t.isRangeFormatElement(f) && !t.isTable(f) ? i += this._convertListCell(f) : i += "<li>" + f.outerHTML + "</li>" : i += "<li>" + (f.textContent || "<br>") + "</li>";
      return i;
    },
    _isFormatData: function(e) {
      let i = !1;
      for (let s = 0, r = e.length, f; s < r; s++)
        if (f = e[s], f.nodeType === 1 && !t.isTextStyleElement(f) && !t.isBreak(f) && !this.__disallowedTagNameRegExp.test(f.nodeName)) {
          i = !0;
          break;
        }
      return i;
    },
    /**
     * @description Gets the clean HTML code for editor
     * @param {String} html HTML string
     * @param {String|RegExp|null} whitelist Regular expression of allowed tags.
     * RegExp object is create by util.createTagsWhitelist method. (core.pasteTagsWhitelistRegExp)
     * @param {String|RegExp|null} blacklist Regular expression of disallowed tags.
     * RegExp object is create by util.createTagsBlacklist method. (core.pasteTagsBlacklistRegExp)
     * @returns {String}
     */
    cleanHTML: function(e, i, s) {
      e = this._deleteDisallowedTags(this._parser.parseFromString(t.htmlCompress(e), "text/html").body.innerHTML).replace(/(<[a-zA-Z0-9\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, !0)).replace(/<br\/?>$/i, "");
      const r = E.createRange().createContextualFragment(e);
      try {
        t._consistencyCheckOfHTML(r, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, this._classNameFilter);
      } catch (g) {
        console.warn("[SUNEDITOR.cleanHTML.consistencyCheck.fail] " + g);
      }
      if (this.managedTagsInfo && this.managedTagsInfo.query) {
        const g = r.querySelectorAll(this.managedTagsInfo.query);
        for (let u = 0, h = g.length, y, T; u < h; u++) {
          T = [].slice.call(g[u].classList);
          for (let L = 0, k = T.length; L < k; L++)
            if (y = this.managedTagsInfo.map[T[L]], y) {
              y(g[u]);
              break;
            }
        }
      }
      let f = r.childNodes, d = "";
      const o = this._isFormatData(f);
      o && (f = this._editFormat(r).childNodes);
      for (let g = 0, u = f.length, h; g < u; g++) {
        if (h = f[g], this.__allowedScriptRegExp.test(h.nodeName)) {
          d += h.outerHTML;
          continue;
        }
        d += this._makeLine(h, o);
      }
      return d = t.htmlRemoveWhiteSpace(d), d ? (i && (d = d.replace(typeof i == "string" ? t.createTagsWhitelist(i) : i, "")), s && (d = d.replace(typeof s == "string" ? t.createTagsBlacklist(s) : s, ""))) : d = e, this._tagConvertor(d);
    },
    /**
     * @description Converts contents into a format that can be placed in an editor
     * @param {String} contents contents
     * @returns {String}
     */
    convertContentsForEditor: function(e) {
      e = this._deleteDisallowedTags(this._parser.parseFromString(t.htmlCompress(e), "text/html").body.innerHTML).replace(/(<[a-zA-Z0-9\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, !0));
      const i = E.createRange().createContextualFragment(e);
      try {
        t._consistencyCheckOfHTML(i, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, this._classNameFilter);
      } catch (d) {
        console.warn("[SUNEDITOR.convertContentsForEditor.consistencyCheck.fail] " + d);
      }
      if (this.managedTagsInfo && this.managedTagsInfo.query) {
        const d = i.querySelectorAll(this.managedTagsInfo.query);
        for (let o = 0, g = d.length, u, h; o < g; o++) {
          h = [].slice.call(d[o].classList);
          for (let y = 0, T = h.length; y < T; y++)
            if (u = this.managedTagsInfo.map[h[y]], u) {
              u(d[o]);
              break;
            }
        }
      }
      const s = i.childNodes;
      let r = "", f = null;
      for (let d = 0, o; d < s.length; d++) {
        if (o = s[d], this.__allowedScriptRegExp.test(o.nodeName)) {
          r += o.outerHTML;
          continue;
        }
        if (!t.isFormatElement(o) && !t.isRangeFormatElement(o) && !t.isComponent(o) && !t.isMedia(o) && o.nodeType !== 8 && !/__se__tag/.test(o.className)) {
          if (f || (f = t.createElement(c.defaultTag)), f.appendChild(o), d--, s[d + 1] && !t.isFormatElement(s[d + 1]))
            continue;
          o = f, f = null;
        }
        f && (r += this._makeLine(f, !0), f = null), r += this._makeLine(o, !0);
      }
      return f && (r += this._makeLine(f, !0)), r.length === 0 ? "<" + c.defaultTag + "><br></" + c.defaultTag + ">" : (r = t.htmlRemoveWhiteSpace(r), this._tagConvertor(r));
    },
    /**
     * @description Converts wysiwyg area element into a format that can be placed in an editor of code view mode
     * @param {Element|String} html WYSIWYG element (context.element.wysiwyg) or HTML string.
     * @param {Boolean} comp If true, does not line break and indentation of tags.
     * @returns {String}
     */
    convertHTMLForCodeView: function(e, i) {
      let s = "";
      const r = w.RegExp, f = new r("^(BLOCKQUOTE|PRE|TABLE|THEAD|TBODY|TR|TH|TD|OL|UL|IMG|IFRAME|VIDEO|AUDIO|FIGURE|FIGCAPTION|HR|BR|CANVAS|SELECT)$", "i"), d = typeof e == "string" ? E.createRange().createContextualFragment(e) : e, o = (function(h) {
        return this.isFormatElement(h) || this.isComponent(h);
      }).bind(t), g = i ? "" : `
`;
      let u = i ? 0 : this._variable.codeIndent * 1;
      return u = u > 0 ? new w.Array(u + 1).join(" ") : "", function h(y, T) {
        const L = y.childNodes, k = f.test(y.nodeName), N = k ? T : "";
        for (let V = 0, M = L.length, D, _, A, H, b, B; V < M; V++) {
          if (D = L[V], H = f.test(D.nodeName), _ = H ? g : "", A = o(D) && !k && !/^(TH|TD)$/i.test(y.nodeName) ? g : "", D.nodeType === 8) {
            s += `
<!-- ` + D.textContent.trim() + " -->" + _;
            continue;
          }
          if (D.nodeType === 3) {
            t.isList(D.parentElement) || (s += t._HTMLConvertor(/^\n+$/.test(D.data) ? "" : D.data));
            continue;
          }
          if (D.childNodes.length === 0) {
            s += (/^HR$/i.test(D.nodeName) ? g : "") + (/^PRE$/i.test(D.parentElement.nodeName) && /^BR$/i.test(D.nodeName) ? "" : N) + D.outerHTML + _;
            continue;
          }
          D.outerHTML ? (b = D.nodeName.toLowerCase(), B = N || H ? T : "", s += (A || (k ? "" : _)) + B + D.outerHTML.match(r("<" + b + "[^>]*>", "i"))[0] + _, h(D, T + u), s += (/\n$/.test(s) ? B : "") + "</" + b + ">" + (A || _ || k || /^(TH|TD)$/i.test(D.nodeName) ? g : "")) : s += new w.XMLSerializer().serializeToString(D);
        }
      }(d, ""), s.trim() + g;
    },
    /**
     * @description Add an event to document.
     * When created as an Iframe, the same event is added to the document in the Iframe.
     * @param {String} type Event type
     * @param {Function} listener Event listener
     * @param {Boolean} useCapture Use event capture
     */
    addDocEvent: function(e, i, s) {
      E.addEventListener(e, i, s), c.iframe && this._wd.addEventListener(e, i);
    },
    /**
             * @description Remove events from document.
             * When created as an Iframe, the event of the document inside the Iframe is also removed.
             * @param {String} type Event type
             * @param {Function} listener Event listener
             */
    removeDocEvent: function(e, i) {
      E.removeEventListener(e, i), c.iframe && this._wd.removeEventListener(e, i);
    },
    /**
     * @description The current number of characters is counted and displayed.
     * @param {String} inputText Text added.
     * @returns {Boolean}
     * @private
     */
    _charCount: function(e) {
      const i = c.maxCharCount, s = c.charCounterType;
      let r = 0;
      if (e && (r = this.getCharLength(e, s)), this._setCharCount(), i > 0) {
        let f = !1;
        const d = O.getCharCount(s);
        if (d > i) {
          if (f = !0, r > 0) {
            this._editorRange();
            const o = this.getRange(), g = o.endOffset - 1, u = this.getSelectionNode().textContent, h = o.endOffset - (d - i);
            this.getSelectionNode().textContent = u.slice(0, h < 0 ? 0 : h) + u.slice(o.endOffset, u.length), this.setRange(o.endContainer, g, o.endContainer, g);
          }
        } else
          d + r > i && (f = !0);
        if (f && (this._callCounterBlink(), r > 0))
          return !1;
      }
      return !0;
    },
    /**
     * @description When "element" is added, if it is greater than "options.maxCharCount", false is returned.
     * @param {Node|String} element Element node or String.
     * @param {String|null} charCounterType charCounterType. If it is null, the options.charCounterType
     * @returns {Boolean}
     */
    checkCharCount: function(e, i) {
      if (c.maxCharCount) {
        const s = i || c.charCounterType, r = this.getCharLength(typeof e == "string" ? e : this._charTypeHTML && e.nodeType === 1 ? e.outerHTML : e.textContent, s);
        if (r > 0 && r + O.getCharCount(s) > c.maxCharCount)
          return this._callCounterBlink(), !1;
      }
      return !0;
    },
    /**
     * @description Get the length of the content.
     * Depending on the option, the length of the character is taken. (charCounterType)
     * @param {String} content Content to count
     * @param {String} charCounterType options.charCounterType
     * @returns {Number}
     */
    getCharLength: function(e, i) {
      return /byte/.test(i) ? t.getByteLength(e) : e.length;
    },
    /**
     * @description Reset buttons of the responsive toolbar.
     */
    resetResponsiveToolbar: function() {
      a.controllersOff();
      const e = p._responsiveButtonSize;
      if (e) {
        let i = 0;
        (a._isBalloon || a._isInline) && c.toolbarWidth === "auto" ? i = n.element.topArea.offsetWidth : i = n.element.toolbar.offsetWidth;
        let s = "default";
        for (let r = 1, f = e.length; r < f; r++)
          if (i < e[r]) {
            s = e[r] + "";
            break;
          }
        p._responsiveCurrentSize !== s && (p._responsiveCurrentSize = s, O.setToolbarButtons(p._responsiveButtons[s]));
      }
    },
    /**
     * @description Set the char count to charCounter element textContent.
     * @private
     */
    _setCharCount: function() {
      n.element.charCounter && w.setTimeout(function() {
        n.element.charCounter.textContent = O.getCharCount(c.charCounterType);
      });
    },
    /**
     * @description The character counter blinks.
     * @private
     */
    _callCounterBlink: function() {
      const e = n.element.charWrapper;
      e && !t.hasClass(e, "se-blink") && (t.addClass(e, "se-blink"), w.setTimeout(function() {
        t.removeClass(e, "se-blink");
      }, 600));
    },
    /**
     * @description Check the components such as image and video and modify them according to the format.
     * @private
     */
    _checkComponents: function() {
      for (let e = 0, i = this._fileInfoPluginsCheck.length; e < i; e++)
        this._fileInfoPluginsCheck[e]();
    },
    /**
     * @description Initialize the information of the components.
     * @private
     */
    _resetComponents: function() {
      for (let e = 0, i = this._fileInfoPluginsReset.length; e < i; e++)
        this._fileInfoPluginsReset[e]();
    },
    /**
     * @description Set method in the code view area
     * @param {String} value HTML string
     * @private
     */
    _setCodeView: function(e) {
      c.codeMirrorEditor ? c.codeMirrorEditor.getDoc().setValue(e) : n.element.code.value = e;
    },
    /**
     * @description Get method in the code view area
     * @private
     */
    _getCodeView: function() {
      return c.codeMirrorEditor ? c.codeMirrorEditor.getDoc().getValue() : n.element.code.value;
    },
    /**
     * @description remove class, display text.
     * @param {Array|null} ignoredList Igonred button list
     */
    _setKeyEffect: function(e) {
      const i = this.commandMap, s = this.activePlugins;
      for (let r in i)
        e.indexOf(r) > -1 || !t.hasOwn(i, r) || (s.indexOf(r) > -1 ? m[r].active.call(this, null) : i.OUTDENT && /^OUTDENT$/i.test(r) ? t.isImportantDisabled(i.OUTDENT) || i.OUTDENT.setAttribute("disabled", !0) : i.INDENT && /^INDENT$/i.test(r) ? t.isImportantDisabled(i.INDENT) || i.INDENT.removeAttribute("disabled") : t.removeClass(i[r], "active"));
    },
    /**
     * @description Initializ core variable
     * @param {Boolean} reload Is relooad?
     * @param {String} _initHTML initial html string
     * @private
     */
    _init: function(e, i) {
      const s = w.RegExp;
      this._ww = c.iframe ? n.element.wysiwygFrame.contentWindow : w, this._wd = E, this._charTypeHTML = c.charCounterType === "byte-html", this.wwComputedStyle = w.getComputedStyle(n.element.wysiwyg), this._editorHeight = n.element.wysiwygFrame.offsetHeight, this._editorHeightPadding = t.getNumber(this.wwComputedStyle.getPropertyValue("padding-top")) + t.getNumber(this.wwComputedStyle.getPropertyValue("padding-bottom")), this._classNameFilter = (function(_) {
        return this.test(_) ? _ : "";
      }).bind(c.allowedClassNames);
      const r = c.__allowedScriptTag ? "" : "script|";
      if (this.__scriptTagRegExp = new s("<(script)[^>]*>([\\s\\S]*?)<\\/\\1>|<script[^>]*\\/?>", "gi"), this.__disallowedTagsRegExp = new s("<(" + r + "style)[^>]*>([\\s\\S]*?)<\\/\\1>|<(" + r + "style)[^>]*\\/?>", "gi"), this.__disallowedTagNameRegExp = new s("^(" + r + "meta|link|style|[a-z]+:[a-z]+)$", "i"), this.__allowedScriptRegExp = new s("^" + (c.__allowedScriptTag ? "script" : "") + "$", "i"), !c.iframe && typeof w.ShadowRoot == "function") {
        let _ = n.element.wysiwygFrame;
        for (; _; ) {
          if (_.shadowRoot) {
            this._shadowRoot = _.shadowRoot;
            break;
          } else if (_ instanceof w.ShadowRoot) {
            this._shadowRoot = _;
            break;
          }
          _ = _.parentNode;
        }
        this._shadowRoot && (this._shadowRootControllerEventTarget = []);
      }
      const f = w.Object.keys(c._textTagsMap), d = c.addTagsWhitelist ? c.addTagsWhitelist.split("|").filter(function(_) {
        return /b|i|ins|s|strike/i.test(_);
      }) : [];
      for (let _ = 0; _ < d.length; _++)
        f.splice(f.indexOf(d[_].toLowerCase()), 1);
      this._disallowedTextTagsRegExp = f.length === 0 ? null : new s("(<\\/?)(" + f.join("|") + ")\\b\\s*([^>^<]+)?\\s*(?=>)", "gi");
      const o = function(_, A) {
        return _ ? _ === "*" ? "[a-z-]+" : A ? _ + "|" + A : _ : "^";
      }, g = "contenteditable|colspan|rowspan|target|href|download|rel|src|alt|class|type|controls|origin-size", u = "data-format|data-size|data-file-size|data-file-name|data-origin|data-align|data-image-link|data-rotate|data-proportion|data-percentage|data-exp|data-font-size";
      this._allowHTMLComments = c._editorTagsWhitelist.indexOf("//") > -1 || c._editorTagsWhitelist === "*", this._htmlCheckWhitelistRegExp = new s("^(" + o(c._editorTagsWhitelist.replace("|//", ""), "") + ")$", "i"), this._htmlCheckBlacklistRegExp = new s("^(" + (c.tagsBlacklist || "^") + ")$", "i"), this.editorTagsWhitelistRegExp = t.createTagsWhitelist(o(c._editorTagsWhitelist.replace("|//", "|<!--|-->"), "")), this.editorTagsBlacklistRegExp = t.createTagsBlacklist(c.tagsBlacklist.replace("|//", "|<!--|-->")), this.pasteTagsWhitelistRegExp = t.createTagsWhitelist(o(c.pasteTagsWhitelist, "")), this.pasteTagsBlacklistRegExp = t.createTagsBlacklist(c.pasteTagsBlacklist);
      const h = '\\s*=\\s*(")[^"]*\\1', y = c.attributesWhitelist;
      let T = {}, L = "";
      if (y)
        for (let _ in y)
          !t.hasOwn(y, _) || /^on[a-z]+$/i.test(y[_]) || (_ === "all" ? L = o(y[_], g) : T[_] = new s("\\s(?:" + o(y[_], "") + ")" + h, "ig"));
      this._attributesWhitelistRegExp = new s("\\s(?:" + (L || g + "|" + u) + ")" + h, "ig"), this._attributesWhitelistRegExp_all_data = new s("\\s(?:" + ((L || g) + "|data-[a-z0-9\\-]+") + ")" + h, "ig"), this._attributesTagsWhitelist = T;
      const k = c.attributesBlacklist;
      if (T = {}, L = "", k)
        for (let _ in k)
          t.hasOwn(k, _) && (_ === "all" ? L = o(k[_], "") : T[_] = new s("\\s(?:" + o(k[_], "") + ")" + h, "ig"));
      this._attributesBlacklistRegExp = new s("\\s(?:" + (L || "^") + ")" + h, "ig"), this._attributesTagsBlacklist = T, this._isInline = /inline/i.test(c.mode), this._isBalloon = /balloon|balloon-always/i.test(c.mode), this._isBalloonAlways = /balloon-always/i.test(c.mode), this._cachingButtons(), this._fileInfoPluginsCheck = [], this._fileInfoPluginsReset = [], this.managedTagsInfo = { query: "", map: {} };
      const N = [];
      this.activePlugins = [], this._fileManager.tags = [], this._fileManager.pluginMap = {};
      let V = [], M, D;
      for (let _ in m)
        if (t.hasOwn(m, _)) {
          if (M = m[_], D = l[_], (M.active || M.action) && D && this.callPlugin(_, null, D), typeof M.checkFileInfo == "function" && typeof M.resetFileInfo == "function" && (this.callPlugin(_, null, D), this._fileInfoPluginsCheck.push(M.checkFileInfo.bind(this)), this._fileInfoPluginsReset.push(M.resetFileInfo.bind(this))), w.Array.isArray(M.fileTags)) {
            const A = M.fileTags;
            this.callPlugin(_, null, D), this._fileManager.tags = this._fileManager.tags.concat(A), V.push(_);
            for (let H = 0, b = A.length; H < b; H++)
              this._fileManager.pluginMap[A[H].toLowerCase()] = _;
          }
          if (M.managedTags) {
            const A = M.managedTags();
            N.push("." + A.className), this.managedTagsInfo.map[A.className] = A.method.bind(this);
          }
        }
      this.managedTagsInfo.query = N.toString(), this._fileManager.queryString = this._fileManager.tags.join(","), this._fileManager.regExp = new s("^(" + (this._fileManager.tags.join("|") || "^") + ")$", "i"), this._fileManager.pluginRegExp = new s("^(" + (V.length === 0 ? "^" : V.join("|")) + ")$", "i"), this._variable._originCssText = n.element.topArea.style.cssText, this._placeholder = n.element.placeholder, this._lineBreaker = n.element.lineBreaker, this._lineBreakerButton = this._lineBreaker.querySelector("button"), this.history = Ee(this, this._onChange_historyStack.bind(this)), this.addModule([we]), c.iframe && (this._wd = n.element.wysiwygFrame.contentDocument, n.element.wysiwyg = this._wd.body, c._editorStyles.editor && (n.element.wysiwyg.style.cssText = c._editorStyles.editor), c.height === "auto" && (this._iframeAuto = this._wd.body)), this._initWysiwygArea(e, i);
    },
    /**
     * @description Caching basic buttons to use
     * @private
     */
    _cachingButtons: function() {
      this.codeViewDisabledButtons = n.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~="se-code-view-enabled"]):not([data-display="MORE"])'), this.resizingDisabledButtons = n.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~="se-resizing-enabled"]):not([data-display="MORE"])');
      const e = n.tool, i = this.commandMap;
      i.INDENT = e.indent, i.OUTDENT = e.outdent, i[c.textTags.bold.toUpperCase()] = e.bold, i[c.textTags.underline.toUpperCase()] = e.underline, i[c.textTags.italic.toUpperCase()] = e.italic, i[c.textTags.strike.toUpperCase()] = e.strike, i[c.textTags.sub.toUpperCase()] = e.subscript, i[c.textTags.sup.toUpperCase()] = e.superscript, this._styleCommandMap = {
        fullScreen: e.fullScreen,
        showBlocks: e.showBlocks,
        codeView: e.codeView
      }, this._saveButtonStates();
    },
    /**
     * @description Initializ wysiwyg area (Only called from core._init)
     * @param {Boolean} reload Is relooad?
     * @param {String} _initHTML initial html string
     * @private
     */
    _initWysiwygArea: function(e, i) {
      n.element.wysiwyg.innerHTML = e ? i : this.convertContentsForEditor((typeof i == "string" ? i : /^TEXTAREA$/i.test(n.element.originElement.nodeName) ? n.element.originElement.value : n.element.originElement.innerHTML) || "");
    },
    /**
     * @description Called when there are changes to tags in the wysiwyg region.
     * @private
     */
    _resourcesStateChange: function() {
      this._iframeAutoHeight(), this._checkPlaceholder();
    },
    /**
     * @description Called when after execute "history.push"
     * @private
     */
    _onChange_historyStack: function() {
      this.hasFocus && p._applyTagEffects(), this._variable.isChanged = !0, n.tool.save && n.tool.save.removeAttribute("disabled"), O.onChange && O.onChange(this.getContents(!0), this), n.element.toolbar.style.display === "block" && p._showToolbarBalloon();
    },
    /**
     * @description Modify the height value of the iframe when the height of the iframe is automatic.
     * @private
     */
    _iframeAutoHeight: function() {
      this._iframeAuto ? w.setTimeout(function() {
        const e = a._iframeAuto.offsetHeight;
        n.element.wysiwygFrame.style.height = e + "px", t.isResizeObserverSupported || a.__callResizeFunction(e, null);
      }) : t.isResizeObserverSupported || a.__callResizeFunction(n.element.wysiwygFrame.offsetHeight, null);
    },
    __callResizeFunction: function(e, i) {
      e = e === -1 ? i.borderBoxSize && i.borderBoxSize[0] ? i.borderBoxSize[0].blockSize : i.contentRect.height + this._editorHeightPadding : e, this._editorHeight !== e && (typeof O.onResizeEditor == "function" && O.onResizeEditor(e, this._editorHeight, a, i), this._editorHeight = e);
    },
    /**
     * @description Set display property when there is placeholder.
     * @private
     */
    _checkPlaceholder: function() {
      if (this._placeholder) {
        if (this._variable.isCodeView) {
          this._placeholder.style.display = "none";
          return;
        }
        const e = n.element.wysiwyg;
        !t.onlyZeroWidthSpace(e.textContent) || e.querySelector(t._allowedEmptyNodeList) || (e.innerText.match(/\n/g) || "").length > 1 ? this._placeholder.style.display = "none" : this._placeholder.style.display = "block";
      }
    },
    /**
     * @description If there is no default format, add a format and move "selection".
     * @param {String|null} formatName Format tag name (default: 'P')
     * @returns {undefined|null}
     * @private
     */
    _setDefaultFormat: function(e) {
      if (this._fileManager.pluginRegExp.test(this.currentControllerName))
        return;
      const i = this.getRange(), s = i.commonAncestorContainer, r = i.startContainer, f = t.getRangeFormatElement(s, null);
      let d, o, g;
      const u = t.getParentElement(s, t.isComponent);
      if (!(u && !t.isTable(u))) {
        if (s.nodeType === 1 && s.getAttribute("data-se-embed") === "true") {
          let h = s.nextElementSibling;
          t.isFormatElement(h) || (h = this.appendFormatTag(s, c.defaultTag)), this.setRange(h.firstChild, 0, h.firstChild, 0);
          return;
        }
        if (!((t.isRangeFormatElement(r) || t.isWysiwygDiv(r)) && (t.isComponent(r.children[i.startOffset]) || t.isComponent(r.children[i.startOffset - 1])))) {
          if (t.getParentElement(s, t.isNotCheckingNode))
            return null;
          if (f) {
            g = t.createElement(e || c.defaultTag), g.innerHTML = f.innerHTML, g.childNodes.length === 0 && (g.innerHTML = t.zeroWidthSpace), f.innerHTML = g.outerHTML, g = f.firstChild, d = t.getEdgeChildNodes(g, null).sc, d || (d = t.createTextNode(t.zeroWidthSpace), g.insertBefore(d, g.firstChild)), o = d.textContent.length, this.setRange(d, o, d, o);
            return;
          }
          if (t.isRangeFormatElement(s) && s.childNodes.length <= 1) {
            let h = null;
            s.childNodes.length === 1 && t.isBreak(s.firstChild) ? h = s.firstChild : (h = t.createTextNode(t.zeroWidthSpace), s.appendChild(h)), this.setRange(h, 1, h, 1);
            return;
          }
          if (this.execCommand("formatBlock", !1, e || c.defaultTag), d = t.getEdgeChildNodes(s, s), d = d ? d.ec : s, g = t.getFormatElement(d, null), !g) {
            this.removeRange(), this._editorRange();
            return;
          }
          if (t.isBreak(g.nextSibling) && t.removeItem(g.nextSibling), t.isBreak(g.previousSibling) && t.removeItem(g.previousSibling), t.isBreak(d)) {
            const h = t.createTextNode(t.zeroWidthSpace);
            d.parentNode.insertBefore(h, d), d = h;
          }
          this.effectNode = null, this.nativeFocus();
        }
      }
    },
    /**
     * @description Initialization after "setOptions"
     * @param {Object} el context.element
     * @param {String} _initHTML Initial html string
     * @private
     */
    _setOptionsInit: function(e, i) {
      this.context = n = be(e.originElement, this._getConstructed(e), c), this._componentsInfoReset = !0, this._editorInit(!0, i);
    },
    /**
     * @description Initializ editor
     * @param {Boolean} reload Is relooad?
     * @param {String} _initHTML initial html string
     * @private
     */
    _editorInit: function(e, i) {
      this._init(e, i), p._addEvent(), this._setCharCount(), p._offStickyToolbar(), p.onResize_window(), n.element.toolbar.style.visibility = "";
      const s = c.frameAttrbutes;
      for (let r in s)
        n.element.wysiwyg.setAttribute(r, s[r]);
      this._checkComponents(), this._componentsInfoInit = !1, this._componentsInfoReset = !1, this.history.reset(!0), w.setTimeout(function() {
        typeof a._resourcesStateChange == "function" && (p._resizeObserver && p._resizeObserver.observe(n.element.wysiwygFrame), p._toolbarObserver && p._toolbarObserver.observe(n.element._toolbarShadow), a._resourcesStateChange(), typeof O.onload == "function" && O.onload(a, e));
      });
    },
    /**
     * @description Create and return an object to cache the new context.
     * @param {Element} contextEl context.element
     * @returns {Object}
     * @private
     */
    _getConstructed: function(e) {
      return {
        _top: e.topArea,
        _relative: e.relative,
        _toolBar: e.toolbar,
        _toolbarShadow: e._toolbarShadow,
        _menuTray: e._menuTray,
        _editorArea: e.editorArea,
        _wysiwygArea: e.wysiwygFrame,
        _codeArea: e.code,
        _placeholder: e.placeholder,
        _resizingBar: e.resizingBar,
        _navigation: e.navigation,
        _charCounter: e.charCounter,
        _charWrapper: e.charWrapper,
        _loading: e.loading,
        _lineBreaker: e.lineBreaker,
        _lineBreaker_t: e.lineBreaker_t,
        _lineBreaker_b: e.lineBreaker_b,
        _resizeBack: e.resizeBackground,
        _stickyDummy: e._stickyDummy,
        _arrow: e._arrow
      };
    }
  }, p = {
    _IEisComposing: !1,
    // In IE, there is no "e.isComposing" in the key-up event.
    _lineBreakerBind: null,
    _responsiveCurrentSize: "default",
    _responsiveButtonSize: null,
    _responsiveButtons: null,
    _cursorMoveKeyCode: new w.RegExp("^(8|3[2-9]|40|46)$"),
    _directionKeyCode: new w.RegExp("^(8|13|3[2-9]|40|46)$"),
    _nonTextKeyCode: new w.RegExp("^(8|13|1[6-9]|20|27|3[3-9]|40|45|46|11[2-9]|12[0-3]|144|145)$"),
    _historyIgnoreKeyCode: new w.RegExp("^(1[6-9]|20|27|3[3-9]|40|45|11[2-9]|12[0-3]|144|145)$"),
    _onButtonsCheck: new w.RegExp("^(" + w.Object.keys(c._textTagsMap).join("|") + ")$", "i"),
    _frontZeroWidthReg: new w.RegExp(t.zeroWidthSpace + "+", ""),
    _keyCodeShortcut: {
      65: "A",
      66: "B",
      83: "S",
      85: "U",
      73: "I",
      89: "Y",
      90: "Z",
      219: "[",
      221: "]"
    },
    _shortcutCommand: function(e, i) {
      let s = null;
      const r = p._keyCodeShortcut[e];
      switch (r) {
        case "A":
          s = "selectAll";
          break;
        case "B":
          c.shortcutsDisable.indexOf("bold") === -1 && (s = "bold");
          break;
        case "S":
          i && c.shortcutsDisable.indexOf("strike") === -1 ? s = "strike" : !i && c.shortcutsDisable.indexOf("save") === -1 && (s = "save");
          break;
        case "U":
          c.shortcutsDisable.indexOf("underline") === -1 && (s = "underline");
          break;
        case "I":
          c.shortcutsDisable.indexOf("italic") === -1 && (s = "italic");
          break;
        case "Z":
          c.shortcutsDisable.indexOf("undo") === -1 && (i ? s = "redo" : s = "undo");
          break;
        case "Y":
          c.shortcutsDisable.indexOf("undo") === -1 && (s = "redo");
          break;
        case "[":
          c.shortcutsDisable.indexOf("indent") === -1 && (s = c.rtl ? "indent" : "outdent");
          break;
        case "]":
          c.shortcutsDisable.indexOf("indent") === -1 && (s = c.rtl ? "outdent" : "indent");
          break;
      }
      return s ? (a.commandHandler(a.commandMap[s], s), !0) : !!r;
    },
    _applyTagEffects: function() {
      let e = a.getSelectionNode();
      if (e === a.effectNode)
        return;
      a.effectNode = e;
      const i = c.rtl ? "marginRight" : "marginLeft", s = a.commandMap, r = p._onButtonsCheck, f = [], d = [], o = a.activePlugins, g = o.length;
      let u = "";
      for (; e.firstChild; )
        e = e.firstChild;
      for (let h = e; !t.isWysiwygDiv(h) && h; h = h.parentNode)
        if (!(h.nodeType !== 1 || t.isBreak(h))) {
          if (u = h.nodeName.toUpperCase(), d.push(u), !a.isReadOnly)
            for (let y = 0, T; y < g; y++)
              T = o[y], f.indexOf(T) === -1 && m[T].active.call(a, h) && f.push(T);
          if (t.isFormatElement(h)) {
            f.indexOf("OUTDENT") === -1 && s.OUTDENT && !t.isImportantDisabled(s.OUTDENT) && (t.isListCell(h) || h.style[i] && t.getNumber(h.style[i], 0) > 0) && (f.push("OUTDENT"), s.OUTDENT.removeAttribute("disabled")), f.indexOf("INDENT") === -1 && s.INDENT && !t.isImportantDisabled(s.INDENT) && (f.push("INDENT"), t.isListCell(h) && !h.previousElementSibling ? s.INDENT.setAttribute("disabled", !0) : s.INDENT.removeAttribute("disabled"));
            continue;
          }
          r && r.test(u) && (f.push(u), t.addClass(s[u], "active"));
        }
      a._setKeyEffect(f), a._variable.currentNodes = d.reverse(), a._variable.currentNodesMap = f, c.showPathLabel && (n.element.navigation.textContent = a._variable.currentNodes.join(" > "));
    },
    _buttonsEventHandler: function(e) {
      let i = e.target;
      if (a._bindControllersOff && e.stopPropagation(), /^(input|textarea|select|option)$/i.test(i.nodeName) ? a._antiBlur = !1 : e.preventDefault(), t.getParentElement(i, ".se-submenu"))
        e.stopPropagation(), a._notHideToolbar = !0;
      else {
        let s = i.getAttribute("data-command"), r = i.className;
        for (; !s && !/se-menu-list/.test(r) && !/sun-editor-common/.test(r); )
          i = i.parentNode, s = i.getAttribute("data-command"), r = i.className;
        (s === a._submenuName || s === a._containerName) && e.stopPropagation();
      }
    },
    onClick_toolbar: function(e) {
      let i = e.target, s = i.getAttribute("data-display"), r = i.getAttribute("data-command"), f = i.className;
      for (a.controllersOff(); i.parentNode && !r && !/se-menu-list/.test(f) && !/se-toolbar/.test(f); )
        i = i.parentNode, r = i.getAttribute("data-command"), s = i.getAttribute("data-display"), f = i.className;
      !r && !s || i.disabled || a.actionCall(r, s, i);
    },
    onMouseDown_wysiwyg: function(e) {
      if (a.isReadOnly || t.isNonEditable(n.element.wysiwyg))
        return;
      if (t._isExcludeSelectionElement(e.target)) {
        e.preventDefault();
        return;
      }
      if (w.setTimeout(a._editorRange.bind(a)), typeof O.onMouseDown == "function" && O.onMouseDown(e, a) === !1)
        return;
      const i = t.getParentElement(e.target, t.isCell);
      if (i) {
        const s = a.plugins.table;
        s && i !== s._fixedCell && !s._shift && a.callPlugin("table", function() {
          s.onTableCellMultiSelect.call(a, i, !1);
        }, null);
      }
      a._isBalloon && p._hideToolbar();
    },
    onClick_wysiwyg: function(e) {
      const i = e.target;
      if (a.isReadOnly)
        return e.preventDefault(), t.isAnchor(i) && w.open(i.href, i.target), !1;
      if (t.isNonEditable(n.element.wysiwyg) || typeof O.onClick == "function" && O.onClick(e, a) === !1)
        return;
      const s = a.getFileComponent(i);
      if (s) {
        e.preventDefault(), a.selectComponent(s.target, s.pluginName);
        return;
      }
      const r = t.getParentElement(i, "FIGCAPTION");
      if (r && t.isNonEditable(r) && (e.preventDefault(), r.focus(), a._isInline && !a._inlineToolbarAttr.isShow)) {
        p._showToolbarInline();
        const g = function() {
          p._hideToolbar(), r.removeEventListener("blur", g);
        };
        r.addEventListener("blur", g);
      }
      if (a._editorRange(), e.detail === 3) {
        let g = a.getRange();
        t.isFormatElement(g.endContainer) && g.endOffset === 0 && (g = a.setRange(g.startContainer, g.startOffset, g.startContainer, g.startContainer.length), a._rangeInfo(g, a.getSelection()));
      }
      const f = a.getSelectionNode(), d = t.getFormatElement(f, null), o = t.getRangeFormatElement(f, null);
      if (!d && !t.isNonEditable(i) && !t.isList(o)) {
        const g = a.getRange();
        if (t.getFormatElement(g.startContainer) === t.getFormatElement(g.endContainer))
          if (t.isList(o)) {
            e.preventDefault();
            const u = t.createElement("LI"), h = f.nextElementSibling;
            u.appendChild(f), o.insertBefore(u, h), a.focus();
          } else
            !t.isWysiwygDiv(f) && !t.isComponent(f) && (!t.isTable(f) || t.isCell(f)) && a._setDefaultFormat(t.isRangeFormatElement(o) ? "DIV" : c.defaultTag) !== null ? (e.preventDefault(), a.focus()) : p._applyTagEffects();
      } else
        p._applyTagEffects();
      a._isBalloon && w.setTimeout(p._toggleToolbarBalloon);
    },
    _balloonDelay: null,
    _showToolbarBalloonDelay: function() {
      p._balloonDelay && w.clearTimeout(p._balloonDelay), p._balloonDelay = w.setTimeout((function() {
        w.clearTimeout(this._balloonDelay), this._balloonDelay = null, this._showToolbarBalloon();
      }).bind(p), 350);
    },
    _toggleToolbarBalloon: function() {
      a._editorRange();
      const e = a.getRange();
      a._bindControllersOff || !a._isBalloonAlways && e.collapsed ? p._hideToolbar() : p._showToolbarBalloon(e);
    },
    _showToolbarBalloon: function(e) {
      if (!a._isBalloon)
        return;
      const i = e || a.getRange(), s = n.element.toolbar, r = n.element.topArea, f = a.getSelection();
      let d;
      if (a._isBalloonAlways && i.collapsed)
        d = !0;
      else if (f.focusNode === f.anchorNode)
        d = f.focusOffset < f.anchorOffset;
      else {
        const _ = t.getListChildNodes(i.commonAncestorContainer, null);
        d = t.getArrayIndex(_, f.focusNode) < t.getArrayIndex(_, f.anchorNode);
      }
      let o = i.getClientRects();
      o = o[d ? 0 : o.length - 1];
      const g = a.getGlobalScrollOffset();
      let u = g.left, h = g.top;
      const y = r.offsetWidth, T = p._getEditorOffsets(null), L = T.top, k = T.left;
      if (s.style.top = "-10000px", s.style.visibility = "hidden", s.style.display = "block", !o) {
        const _ = a.getSelectionNode();
        if (t.isFormatElement(_)) {
          const A = t.createTextNode(t.zeroWidthSpace);
          a.insertNode(A, null, !1), a.setRange(A, 1, A, 1), a._editorRange(), o = a.getRange().getClientRects(), o = o[d ? 0 : o.length - 1];
        }
        if (!o) {
          const A = t.getOffset(_, n.element.wysiwygFrame);
          o = {
            left: A.left,
            top: A.top,
            right: A.left,
            bottom: A.top + _.offsetHeight,
            noText: !0
          }, u = 0, h = 0;
        }
        d = !0;
      }
      const N = w.Math.round(n.element._arrow.offsetWidth / 2), V = s.offsetWidth, M = s.offsetHeight, D = /iframe/i.test(n.element.wysiwygFrame.nodeName) ? n.element.wysiwygFrame.getClientRects()[0] : null;
      if (D && (o = {
        left: o.left + D.left,
        top: o.top + D.top,
        right: o.right + D.right - D.width,
        bottom: o.bottom + D.bottom - D.height
      }), p._setToolbarOffset(d, o, s, k, y, u, h, L, N), (V !== s.offsetWidth || M !== s.offsetHeight) && p._setToolbarOffset(d, o, s, k, y, u, h, L, N), c.toolbarContainer) {
        const _ = r.parentElement;
        let A = c.toolbarContainer, H = A.offsetLeft, b = A.offsetTop;
        for (; !A.parentElement.contains(_) || !/^(BODY|HTML)$/i.test(A.parentElement.nodeName); )
          A = A.offsetParent, H += A.offsetLeft, b += A.offsetTop;
        s.style.left = s.offsetLeft - H + r.offsetLeft + "px", s.style.top = s.offsetTop - b + r.offsetTop + "px";
      }
      s.style.visibility = "";
    },
    _setToolbarOffset: function(e, i, s, r, f, d, o, g, u) {
      const y = s.offsetWidth, T = i.noText && !e ? 0 : s.offsetHeight, L = (e ? i.left : i.right) - r - y / 2 + d, k = L + y - f;
      let N = (e ? i.top - T - u : i.bottom + u) - (i.noText ? 0 : g) + o, V = L < 0 ? 1 : k < 0 ? L : L - k - 1 - 1, M = !1;
      const D = N + (e ? p._getEditorOffsets(null).top : s.offsetHeight - n.element.wysiwyg.offsetHeight);
      !e && D > 0 && p._getPageBottomSpace() < D ? (e = !0, M = !0) : e && E.documentElement.offsetTop > D && (e = !1, M = !0), M && (N = (e ? i.top - T - u : i.bottom + u) - (i.noText ? 0 : g) + o), s.style.left = w.Math.floor(V) + "px", s.style.top = w.Math.floor(N) + "px", e ? (t.removeClass(n.element._arrow, "se-arrow-up"), t.addClass(n.element._arrow, "se-arrow-down"), n.element._arrow.style.top = T + "px") : (t.removeClass(n.element._arrow, "se-arrow-down"), t.addClass(n.element._arrow, "se-arrow-up"), n.element._arrow.style.top = -u + "px");
      const _ = w.Math.floor(y / 2 + (L - V));
      n.element._arrow.style.left = (_ + u > s.offsetWidth ? s.offsetWidth - u : _ < u ? u : _) + "px";
    },
    _showToolbarInline: function() {
      if (!a._isInline)
        return;
      const e = n.element.toolbar;
      c.toolbarContainer ? e.style.position = "relative" : e.style.position = "absolute", e.style.visibility = "hidden", e.style.display = "block", a._inlineToolbarAttr.width = e.style.width = c.toolbarWidth, a._inlineToolbarAttr.top = e.style.top = (c.toolbarContainer ? 0 : -1 - e.offsetHeight) + "px", typeof O.showInline == "function" && O.showInline(e, n, a), p.onScroll_window(), a._inlineToolbarAttr.isShow = !0, e.style.visibility = "";
    },
    _hideToolbar: function() {
      !a._notHideToolbar && !a._variable.isFullScreen && (n.element.toolbar.style.display = "none", a._inlineToolbarAttr.isShow = !1);
    },
    onInput_wysiwyg: function(e) {
      if (document.body.contains(a.currentControllerTarget) || a.controllersOff(), a.isReadOnly || a.isDisabled)
        return e.preventDefault(), e.stopPropagation(), a.history.go(a.history.getCurrentIndex()), !1;
      a._editorRange();
      const i = (e.data === null ? "" : e.data === void 0 ? " " : e.data) || "";
      if (!a._charCount(i))
        return e.preventDefault(), e.stopPropagation(), !1;
      typeof O.onInput == "function" && O.onInput(e, a) === !1 || a.history.push(!0);
    },
    _isUneditableNode: function(e, i) {
      const s = i ? e.startContainer : e.endContainer, r = i ? e.startOffset : e.endOffset, f = i ? "previousSibling" : "nextSibling", d = s.nodeType === 1;
      let o;
      return d ? (o = p._isUneditableNode_getSibling(s.childNodes[r], f, s), o && o.nodeType === 1 && o.getAttribute("contenteditable") === "false") : (o = p._isUneditableNode_getSibling(s, f, s), a.isEdgePoint(s, r, i ? "front" : "end") && o && o.nodeType === 1 && o.getAttribute("contenteditable") === "false");
    },
    _isUneditableNode_getSibling: function(e, i, s) {
      if (!e)
        return null;
      let r = e[i];
      if (!r)
        if (r = t.getFormatElement(s), r = r ? r[i] : null, r && !t.isComponent(r))
          r = i === "previousSibling" ? r.firstChild : r.lastChild;
        else
          return null;
      return r;
    },
    _onShortcutKey: !1,
    onKeyDown_wysiwyg: function(e) {
      let i = a.getSelectionNode();
      if (t.isInputElement(i))
        return;
      const s = e.keyCode, r = e.shiftKey, f = e.ctrlKey || e.metaKey || s === 91 || s === 92 || s === 224, d = e.altKey;
      if (p._IEisComposing = s === 229, !f && a.isReadOnly && !p._cursorMoveKeyCode.test(s))
        return e.preventDefault(), !1;
      if (a.submenuOff(), a._isBalloon && p._hideToolbar(), typeof O.onKeyDown == "function" && O.onKeyDown(e, a) === !1)
        return;
      if (f && p._shortcutCommand(s, r))
        return p._onShortcutKey = !0, e.preventDefault(), e.stopPropagation(), !1;
      p._onShortcutKey && (p._onShortcutKey = !1);
      const o = a.getRange(), g = !o.collapsed || o.startContainer !== o.endContainer, u = a._fileManager.pluginRegExp.test(a.currentControllerName) ? a.currentControllerName : "";
      let h = t.getFormatElement(i, null) || i, y = t.getRangeFormatElement(h, null);
      switch (s) {
        case 8:
          if (!g && u) {
            e.preventDefault(), e.stopPropagation(), a.plugins[u].destroy.call(a);
            break;
          }
          if (g && p._hardDelete()) {
            e.preventDefault(), e.stopPropagation();
            break;
          }
          if (!t.isFormatElement(h) && !n.element.wysiwyg.firstElementChild && !t.isComponent(i) && a._setDefaultFormat(c.defaultTag) !== null)
            return e.preventDefault(), e.stopPropagation(), !1;
          if (!g && !h.previousElementSibling && o.startOffset === 0 && !i.previousSibling && !t.isListCell(h) && t.isFormatElement(h) && (!t.isFreeFormatElement(h) || t.isClosureFreeFormatElement(h))) {
            if (t.isClosureRangeFormatElement(h.parentNode))
              return e.preventDefault(), e.stopPropagation(), !1;
            if (t.isWysiwygDiv(h.parentNode) && h.childNodes.length <= 1 && (!h.firstChild || t.onlyZeroWidthSpace(h.textContent))) {
              if (e.preventDefault(), e.stopPropagation(), h.nodeName.toUpperCase() === c.defaultTag.toUpperCase()) {
                h.innerHTML = "<br>";
                const b = h.attributes;
                for (; b[0]; )
                  h.removeAttribute(b[0].name);
              } else {
                const b = t.createElement(c.defaultTag);
                b.innerHTML = "<br>", h.parentElement.replaceChild(b, h);
              }
              return a.nativeFocus(), !1;
            }
          }
          const T = o.startContainer;
          if (h && !h.previousElementSibling && o.startOffset === 0 && T.nodeType === 3 && !t.isFormatElement(T.parentNode)) {
            let b = T.parentNode.previousSibling;
            const B = T.parentNode.nextSibling;
            b || (B ? b = B : (b = t.createElement("BR"), h.appendChild(b)));
            let x = T;
            for (; h.contains(x) && !x.previousSibling; )
              x = x.parentNode;
            if (!h.contains(x)) {
              T.textContent = "", t.removeItemAllParents(T, null, h);
              break;
            }
          }
          if (p._isUneditableNode(o, !0)) {
            e.preventDefault(), e.stopPropagation();
            break;
          }
          !g && a._isEdgeFormat(o.startContainer, o.startOffset, "start") && t.isFormatElement(h.previousElementSibling) && (a._formatAttrsTemp = h.previousElementSibling.attributes);
          const L = o.commonAncestorContainer;
          if (h = t.getFormatElement(o.startContainer, null), y = t.getRangeFormatElement(h, null), y && h && !t.isCell(y) && !/^FIGCAPTION$/i.test(y.nodeName)) {
            if (t.isListCell(h) && t.isList(y) && (t.isListCell(y.parentNode) || h.previousElementSibling) && (i === h || i.nodeType === 3 && (!i.previousSibling || t.isList(i.previousSibling))) && (t.getFormatElement(o.startContainer, null) !== t.getFormatElement(o.endContainer, null) ? y.contains(o.startContainer) : o.startOffset === 0 && o.collapsed)) {
              if (o.startContainer !== o.endContainer)
                e.preventDefault(), a.removeNode(), o.startContainer.nodeType === 3 && a.setRange(o.startContainer, o.startContainer.textContent.length, o.startContainer, o.startContainer.textContent.length), a.history.push(!0);
              else {
                let b = h.previousElementSibling || y.parentNode;
                if (t.isListCell(b)) {
                  e.preventDefault();
                  let B = b;
                  if (!b.contains(h) && t.isListCell(B) && t.isList(B.lastElementChild)) {
                    for (B = B.lastElementChild.lastElementChild; t.isListCell(B) && t.isList(B.lastElementChild); )
                      B = B.lastElementChild && B.lastElementChild.lastElementChild;
                    b = B;
                  }
                  let x = b === y.parentNode ? y.previousSibling : b.lastChild;
                  x || (x = t.createTextNode(t.zeroWidthSpace), y.parentNode.insertBefore(x, y.parentNode.firstChild));
                  const S = x.nodeType === 3 ? x.textContent.length : 1, R = h.childNodes;
                  let Z = x, W = R[0];
                  for (; W = R[0]; )
                    b.insertBefore(W, Z.nextSibling), Z = W;
                  t.removeItem(h), y.children.length === 0 && t.removeItem(y), a.setRange(x, S, x, S), a.history.push(!0);
                }
              }
              break;
            }
            if (!g && o.startOffset === 0) {
              let b = !0, B = L;
              for (; B && B !== y && !t.isWysiwygDiv(B); ) {
                if (B.previousSibling && (B.previousSibling.nodeType === 1 || !t.onlyZeroWidthSpace(B.previousSibling.textContent.trim()))) {
                  b = !1;
                  break;
                }
                B = B.parentNode;
              }
              if (b && y.parentNode) {
                e.preventDefault(), a.detachRangeFormatElement(y, t.isListCell(h) ? [h] : null, null, !1, !1), a.history.push(!0);
                break;
              }
            }
          }
          if (!g && h && (o.startOffset === 0 || i === h && h.childNodes[o.startOffset])) {
            const b = i === h ? h.childNodes[o.startOffset] : i, B = h.previousSibling, x = (L.nodeType === 3 || t.isBreak(L)) && !L.previousSibling && o.startOffset === 0;
            if (b && !b.previousSibling && (L && t.isComponent(L.previousSibling) || x && t.isComponent(B))) {
              const S = a.getFileComponent(B);
              S ? (e.preventDefault(), e.stopPropagation(), h.textContent.length === 0 && t.removeItem(h), a.selectComponent(S.target, S.pluginName) === !1 && a.blur()) : t.isComponent(B) && (e.preventDefault(), e.stopPropagation(), t.removeItem(B));
              break;
            }
            if (b && t.isNonEditable(b.previousSibling)) {
              e.preventDefault(), e.stopPropagation(), t.removeItem(b.previousSibling);
              break;
            }
          }
          break;
        case 46:
          if (u) {
            e.preventDefault(), e.stopPropagation(), a.plugins[u].destroy.call(a);
            break;
          }
          if (g && p._hardDelete()) {
            e.preventDefault(), e.stopPropagation();
            break;
          }
          if (p._isUneditableNode(o, !1)) {
            e.preventDefault(), e.stopPropagation();
            break;
          }
          if ((t.isFormatElement(i) || i.nextSibling === null || t.onlyZeroWidthSpace(i.nextSibling) && i.nextSibling.nextSibling === null) && o.startOffset === i.textContent.length) {
            const b = h.nextElementSibling;
            if (!b)
              break;
            if (t.isComponent(b)) {
              if (e.preventDefault(), t.onlyZeroWidthSpace(h) && (t.removeItem(h), t.isTable(b))) {
                let x = t.getChildElement(b, t.isCell, !1);
                x = x.firstElementChild || x, a.setRange(x, 0, x, 0);
                break;
              }
              const B = a.getFileComponent(b);
              B ? (e.stopPropagation(), a.selectComponent(B.target, B.pluginName) === !1 && a.blur()) : t.isComponent(b) && (e.stopPropagation(), t.removeItem(b));
              break;
            }
          }
          if (!g && (a.isEdgePoint(o.endContainer, o.endOffset) || i === h && h.childNodes[o.startOffset])) {
            const b = i === h && h.childNodes[o.startOffset] || i;
            if (b && t.isNonEditable(b.nextSibling)) {
              e.preventDefault(), e.stopPropagation(), t.removeItem(b.nextSibling);
              break;
            } else if (t.isComponent(b)) {
              e.preventDefault(), e.stopPropagation(), t.removeItem(b);
              break;
            }
          }
          if (!g && a._isEdgeFormat(o.endContainer, o.endOffset, "end") && t.isFormatElement(h.nextElementSibling) && (a._formatAttrsTemp = h.attributes), h = t.getFormatElement(o.startContainer, null), y = t.getRangeFormatElement(h, null), t.isListCell(h) && t.isList(y) && (i === h || i.nodeType === 3 && (!i.nextSibling || t.isList(i.nextSibling)) && (t.getFormatElement(o.startContainer, null) !== t.getFormatElement(o.endContainer, null) ? y.contains(o.endContainer) : o.endOffset === i.textContent.length && o.collapsed))) {
            o.startContainer !== o.endContainer && a.removeNode();
            let b = t.getArrayItem(h.children, t.isList, !1);
            if (b = b || h.nextElementSibling || y.parentNode.nextElementSibling, b && (t.isList(b) || t.getArrayItem(b.children, t.isList, !1))) {
              e.preventDefault();
              let B, x;
              if (t.isList(b)) {
                const S = b.firstElementChild;
                for (x = S.childNodes, B = x[0]; x[0]; )
                  h.insertBefore(x[0], b);
                t.removeItem(S);
              } else {
                for (B = b.firstChild, x = b.childNodes; x[0]; )
                  h.appendChild(x[0]);
                t.removeItem(b);
              }
              a.setRange(B, 0, B, 0), a.history.push(!0);
            }
            break;
          }
          break;
        case 9:
          if (u || c.tabDisable || (e.preventDefault(), f || d || t.isWysiwygDiv(i)))
            break;
          const k = !o.collapsed || a.isEdgePoint(o.startContainer, o.startOffset), N = a.getSelectedElements(null);
          i = a.getSelectionNode();
          const V = [];
          let M = [], D = t.isListCell(N[0]), _ = t.isListCell(N[N.length - 1]), A = { sc: o.startContainer, so: o.startOffset, ec: o.endContainer, eo: o.endOffset };
          for (let b = 0, B = N.length, x; b < B; b++)
            if (x = N[b], t.isListCell(x)) {
              if (!x.previousElementSibling && !r)
                continue;
              V.push(x);
            } else
              M.push(x);
          if (V.length > 0 && k && a.plugins.list)
            A = a.plugins.list.editInsideList.call(a, r, V);
          else {
            const b = t.getParentElement(i, t.isCell);
            if (b && k) {
              const B = t.getParentElement(b, "table"), x = t.getListChildren(B, t.isCell);
              let S = r ? t.prevIdx(x, b) : t.nextIdx(x, b);
              S === x.length && !r && (S = 0), S === -1 && r && (S = x.length - 1);
              let R = x[S];
              if (!R)
                break;
              R = R.firstElementChild || R, a.setRange(R, 0, R, 0);
              break;
            }
            M = M.concat(V), D = _ = null;
          }
          if (M.length > 0)
            if (r) {
              const b = M.length - 1;
              for (let S = 0, R; S <= b; S++) {
                R = M[S].childNodes;
                for (let Z = 0, W = R.length, U; Z < W && (U = R[Z], !!U); Z++)
                  if (!t.onlyZeroWidthSpace(U)) {
                    /^\s{1,4}$/.test(U.textContent) ? t.removeItem(U) : /^\s{1,4}/.test(U.textContent) && (U.textContent = U.textContent.replace(/^\s{1,4}/, ""));
                    break;
                  }
              }
              const B = t.getChildElement(M[0], "text", !1), x = t.getChildElement(M[b], "text", !0);
              !D && B && (A.sc = B, A.so = 0), !_ && x && (A.ec = x, A.eo = x.textContent.length);
            } else {
              const b = t.createTextNode(new w.Array(a._variable.tabSize + 1).join(" "));
              if (M.length === 1) {
                const B = a.insertNode(b, null, !0);
                if (!B)
                  return !1;
                D || (A.sc = b, A.so = B.endOffset), _ || (A.ec = b, A.eo = B.endOffset);
              } else {
                const B = M.length - 1;
                for (let R = 0, Z; R <= B; R++)
                  Z = M[R].firstChild, Z && (t.isBreak(Z) ? M[R].insertBefore(b.cloneNode(!1), Z) : Z.textContent = b.textContent + Z.textContent);
                const x = t.getChildElement(M[0], "text", !1), S = t.getChildElement(M[B], "text", !0);
                !D && x && (A.sc = x, A.so = 0), !_ && S && (A.ec = S, A.eo = S.textContent.length);
              }
            }
          a.setRange(A.sc, A.so, A.ec, A.eo), a.history.push(!1);
          break;
        case 13:
          const H = t.getFreeFormatElement(i, null);
          if (a._charTypeHTML) {
            let b = "";
            if (!r && H || r ? b = "<br>" : b = "<" + h.nodeName + "><br></" + h.nodeName + ">", !a.checkCharCount(b, "byte-html"))
              return e.preventDefault(), !1;
          }
          if (!r) {
            const b = a._isEdgeFormat(o.endContainer, o.endOffset, "end"), B = a._isEdgeFormat(o.startContainer, o.startOffset, "start");
            if (b && (/^H[1-6]$/i.test(h.nodeName) || /^HR$/i.test(h.nodeName))) {
              e.preventDefault();
              let x = null;
              const S = a.appendFormatTag(h, c.defaultTag);
              if (b && b.length > 0) {
                x = b.pop();
                const R = x;
                for (; b.length > 0; )
                  x = x.appendChild(b.pop());
                S.appendChild(R);
              }
              x = x ? x.appendChild(S.firstChild) : S.firstChild, a.setRange(x, 0, x, 0);
              break;
            } else if (y && h && !t.isCell(y) && !/^FIGCAPTION$/i.test(y.nodeName)) {
              const x = a.getRange();
              if (a.isEdgePoint(x.endContainer, x.endOffset) && t.isList(i.nextSibling)) {
                e.preventDefault();
                const S = t.createElement("LI"), R = t.createElement("BR");
                S.appendChild(R), h.parentNode.insertBefore(S, h.nextElementSibling), S.appendChild(i.nextSibling), a.setRange(R, 1, R, 1);
                break;
              }
              if ((x.commonAncestorContainer.nodeType !== 3 || !x.commonAncestorContainer.nextElementSibling) && t.onlyZeroWidthSpace(h.innerText.trim()) && !t.isListCell(h.nextElementSibling)) {
                e.preventDefault();
                let S = null;
                if (t.isListCell(y.parentNode)) {
                  if (y = h.parentNode.parentNode.parentNode, S = t.splitElement(h, null, t.getElementDepth(h) - 2), !S) {
                    const R = t.createElement("LI");
                    R.innerHTML = "<br>", t.copyTagAttributes(R, h, c.lineAttrReset), y.insertBefore(R, S), S = R;
                  }
                } else {
                  const R = t.isCell(y.parentNode) ? "DIV" : t.isList(y.parentNode) ? "LI" : t.isFormatElement(y.nextElementSibling) && !t.isRangeFormatElement(y.nextElementSibling) ? y.nextElementSibling.nodeName : t.isFormatElement(y.previousElementSibling) && !t.isRangeFormatElement(y.previousElementSibling) ? y.previousElementSibling.nodeName : c.defaultTag;
                  S = t.createElement(R), t.copyTagAttributes(S, h, c.lineAttrReset);
                  const Z = a.detachRangeFormatElement(y, [h], null, !0, !0);
                  Z.cc.insertBefore(S, Z.ec);
                }
                S.innerHTML = "<br>", t.removeItemAllParents(h, null, null), a.setRange(S, 1, S, 1);
                break;
              }
            }
            if (H) {
              e.preventDefault();
              const x = i === H, S = a.getSelection(), R = i.childNodes, Z = S.focusOffset, W = i.previousElementSibling, U = i.nextSibling;
              if (!t.isClosureFreeFormatElement(H) && R && (x && o.collapsed && R.length - 1 <= Z + 1 && t.isBreak(R[Z]) && (!R[Z + 1] || (!R[Z + 2] || t.onlyZeroWidthSpace(R[Z + 2].textContent)) && R[Z + 1].nodeType === 3 && t.onlyZeroWidthSpace(R[Z + 1].textContent)) && Z > 0 && t.isBreak(R[Z - 1]) || !x && t.onlyZeroWidthSpace(i.textContent) && t.isBreak(W) && (t.isBreak(W.previousSibling) || !t.onlyZeroWidthSpace(W.previousSibling.textContent)) && (!U || !t.isBreak(U) && t.onlyZeroWidthSpace(U.textContent)))) {
                x ? t.removeItem(R[Z - 1]) : t.removeItem(i);
                const P = a.appendFormatTag(H, t.isFormatElement(H.nextElementSibling) && !t.isRangeFormatElement(H.nextElementSibling) ? H.nextElementSibling : null);
                t.copyFormatAttributes(P, H), a.setRange(P, 1, P, 1);
                break;
              }
              if (x) {
                O.insertHTML(o.collapsed && t.isBreak(o.startContainer.childNodes[o.startOffset - 1]) ? "<br>" : "<br><br>", !0, !1);
                let P = S.focusNode;
                const I = S.focusOffset;
                H === P && (P = P.childNodes[I - Z > 1 ? I - 1 : I]), a.setRange(P, 1, P, 1);
              } else {
                const P = S.focusNode.nextSibling, I = t.createElement("BR");
                a.insertNode(I, null, !1);
                const $ = I.previousSibling, j = I.nextSibling;
                !t.isBreak(P) && !t.isBreak($) && (!j || t.onlyZeroWidthSpace(j)) ? (I.parentNode.insertBefore(I.cloneNode(!1), I), a.setRange(I, 1, I, 1)) : a.setRange(j, 0, j, 0);
              }
              p._onShortcutKey = !0;
              break;
            }
            if (o.collapsed && (B || b)) {
              e.preventDefault();
              const x = t.createElement("BR"), S = t.createElement(h.nodeName);
              t.copyTagAttributes(S, h, c.lineAttrReset);
              let R = x;
              do {
                if (!t.isBreak(i) && i.nodeType === 1) {
                  const Z = i.cloneNode(!1);
                  Z.appendChild(R), R = Z;
                }
                i = i.parentNode;
              } while (h !== i && h.contains(i));
              S.appendChild(R), h.parentNode.insertBefore(S, B && !b ? h : h.nextElementSibling), b && a.setRange(x, 1, x, 1);
              break;
            }
            if (h) {
              e.stopPropagation();
              let x, S = 0;
              if (o.collapsed)
                t.onlyZeroWidthSpace(h) ? x = a.appendFormatTag(h, h.cloneNode(!1)) : x = t.splitElement(o.endContainer, o.endOffset, t.getElementDepth(h));
              else {
                const R = t.getFormatElement(o.startContainer, null) !== t.getFormatElement(o.endContainer, null), Z = h.cloneNode(!1);
                Z.innerHTML = "<br>";
                const W = a.removeNode();
                if (x = t.getFormatElement(W.container, null), !x) {
                  t.isWysiwygDiv(W.container) && (e.preventDefault(), n.element.wysiwyg.appendChild(Z), x = Z, t.copyTagAttributes(x, h, c.lineAttrReset), a.setRange(x, S, x, S));
                  break;
                }
                const U = t.getRangeFormatElement(W.container);
                if (x = x.contains(U) ? t.getChildElement(U, t.getFormatElement.bind(t)) : x, R) {
                  if (b && !B)
                    x.parentNode.insertBefore(Z, !W.prevContainer || W.container === W.prevContainer ? x.nextElementSibling : x), x = Z, S = 0;
                  else if (S = W.offset, B) {
                    const P = x.parentNode.insertBefore(Z, x);
                    b && (x = P, S = 0);
                  }
                } else
                  b && B ? (x.parentNode.insertBefore(Z, W.prevContainer && W.container === W.prevContainer ? x.nextElementSibling : x), x = Z, S = 0) : x = t.splitElement(W.container, W.offset, t.getElementDepth(h));
              }
              e.preventDefault(), t.copyTagAttributes(x, h, c.lineAttrReset), a.setRange(x, S, x, S);
              break;
            }
          }
          if (g)
            break;
          if (y && t.getParentElement(y, "FIGCAPTION") && t.getParentElement(y, t.isList) && (e.preventDefault(), h = a.appendFormatTag(h, null), a.setRange(h, 0, h, 0)), u) {
            e.preventDefault(), e.stopPropagation();
            const b = n[u], B = b._container, x = B.previousElementSibling || B.nextElementSibling;
            let S = null;
            t.isListCell(B.parentNode) ? S = t.createElement("BR") : (S = t.createElement(t.isFormatElement(x) && !t.isRangeFormatElement(x) ? x.nodeName : c.defaultTag), S.innerHTML = "<br>"), B.parentNode.insertBefore(S, B), a.callPlugin(u, function() {
              a.selectComponent(b._element, u) === !1 && a.blur();
            }, null);
          }
          break;
        case 27:
          if (u)
            return e.preventDefault(), e.stopPropagation(), a.controllersOff(), !1;
          break;
      }
      if (r && s === 16) {
        e.preventDefault(), e.stopPropagation();
        const T = a.plugins.table;
        if (T && !T._shift && !T._ref) {
          const L = t.getParentElement(h, t.isCell);
          if (L) {
            T.onTableCellMultiSelect.call(a, L, !0);
            return;
          }
        }
      } else if (r && (t.isOSX_IOS ? d : f) && s === 32) {
        e.preventDefault(), e.stopPropagation();
        const T = a.insertNode(t.createTextNode(" "));
        if (T && T.container) {
          a.setRange(T.container, T.endOffset, T.container, T.endOffset);
          return;
        }
      }
      if (t.isIE && !f && !d && !g && !p._nonTextKeyCode.test(s) && t.isBreak(o.commonAncestorContainer)) {
        const T = t.createTextNode(t.zeroWidthSpace);
        a.insertNode(T, null, !1), a.setRange(T, 1, T, 1);
      }
      p._directionKeyCode.test(s) && (a._editorRange(), p._applyTagEffects());
    },
    onKeyUp_wysiwyg: function(e) {
      if (p._onShortcutKey)
        return;
      a._editorRange();
      const i = e.keyCode, s = e.ctrlKey || e.metaKey || i === 91 || i === 92 || i === 224, r = e.altKey;
      if (a.isReadOnly) {
        !s && p._cursorMoveKeyCode.test(i) && p._applyTagEffects();
        return;
      }
      const f = a.getRange();
      let d = a.getSelectionNode();
      if (a._isBalloon && (a._isBalloonAlways && i !== 27 || !f.collapsed))
        if (a._isBalloonAlways)
          i !== 27 && p._showToolbarBalloonDelay();
        else {
          p._showToolbarBalloon();
          return;
        }
      if (i === 8 && t.isWysiwygDiv(d) && d.textContent === "" && d.children.length === 0) {
        e.preventDefault(), e.stopPropagation(), d.innerHTML = "";
        const y = t.createElement(t.isFormatElement(a._variable.currentNodes[0]) ? a._variable.currentNodes[0] : c.defaultTag);
        y.innerHTML = "<br>", d.appendChild(y), a.setRange(y, 0, y, 0), p._applyTagEffects(), a.history.push(!1);
        return;
      }
      const o = t.getFormatElement(d, null), g = t.getRangeFormatElement(d, null), u = a._formatAttrsTemp;
      if (u) {
        for (let y = 0, T = u.length; y < T; y++) {
          if (i === 13 && /^id$/i.test(u[y].name)) {
            o.removeAttribute("id");
            continue;
          }
          o.setAttribute(u[y].name, u[y].value);
        }
        a._formatAttrsTemp = null;
      }
      if (!o && f.collapsed && !t.isComponent(d) && !t.isList(d) && a._setDefaultFormat(t.isRangeFormatElement(g) ? "DIV" : c.defaultTag) !== null && (d = a.getSelectionNode()), !s && !r && !p._nonTextKeyCode.test(i) && d.nodeType === 3 && t.zeroWidthRegExp.test(d.textContent) && !(e.isComposing !== void 0 ? e.isComposing : p._IEisComposing)) {
        let y = f.startOffset, T = f.endOffset;
        const L = (d.textContent.substring(0, T).match(p._frontZeroWidthReg) || "").length;
        y = f.startOffset - L, T = f.endOffset - L, d.textContent = d.textContent.replace(t.zeroWidthRegExp, ""), a.setRange(d, y < 0 ? 0 : y, d, T < 0 ? 0 : T);
      }
      a._charCount(""), !(typeof O.onKeyUp == "function" && O.onKeyUp(e, a) === !1) && !s && !r && !p._historyIgnoreKeyCode.test(i) && a.history.push(!0);
    },
    onScroll_wysiwyg: function(e) {
      a.controllersOff(), a._isBalloon && p._hideToolbar(), typeof O.onScroll == "function" && O.onScroll(e, a);
    },
    onFocus_wysiwyg: function(e) {
      a._antiBlur || (a.hasFocus = !0, w.setTimeout(p._applyTagEffects), a._isInline && p._showToolbarInline(), typeof O.onFocus == "function" && O.onFocus(e, a));
    },
    onBlur_wysiwyg: function(e) {
      a._antiBlur || a._variable.isCodeView || (a.hasFocus = !1, a.effectNode = null, a.controllersOff(), (a._isInline || a._isBalloon) && p._hideToolbar(), a._setKeyEffect([]), a._variable.currentNodes = [], a._variable.currentNodesMap = [], c.showPathLabel && (n.element.navigation.textContent = ""), typeof O.onBlur == "function" && O.onBlur(e, a, this));
    },
    onMouseDown_resizingBar: function(e) {
      e.stopPropagation(), a.submenuOff(), a.controllersOff(), a._variable.resizeClientY = e.clientY, n.element.resizeBackground.style.display = "block";
      function i() {
        n.element.resizeBackground.style.display = "none", E.removeEventListener("mousemove", p._resize_editor), E.removeEventListener("mouseup", i);
      }
      E.addEventListener("mousemove", p._resize_editor), E.addEventListener("mouseup", i);
    },
    _resize_editor: function(e) {
      const i = n.element.editorArea.offsetHeight + (e.clientY - a._variable.resizeClientY), s = i < a._variable.minResizingSize ? a._variable.minResizingSize : i;
      n.element.wysiwygFrame.style.height = n.element.code.style.height = s + "px", a._variable.resizeClientY = e.clientY, t.isResizeObserverSupported || a.__callResizeFunction(s, null);
    },
    onResize_window: function() {
      t.isResizeObserverSupported || a.resetResponsiveToolbar();
      const e = n.element.toolbar, i = e.style.display === "none" || a._isInline && !a._inlineToolbarAttr.isShow;
      if (!(e.offsetWidth === 0 && !i)) {
        if (n.fileBrowser && n.fileBrowser.area.style.display === "block" && (n.fileBrowser.body.style.maxHeight = w.innerHeight - n.fileBrowser.header.offsetHeight - 50 + "px"), a.submenuActiveButton && a.submenu && a._setMenuPosition(a.submenuActiveButton, a.submenu), a._variable.isFullScreen) {
          a._variable.innerHeight_fullScreen += w.innerHeight - e.offsetHeight - a._variable.innerHeight_fullScreen, n.element.editorArea.style.height = a._variable.innerHeight_fullScreen + "px";
          return;
        }
        if (a._variable.isCodeView && a._isInline) {
          p._showToolbarInline();
          return;
        }
        a._iframeAutoHeight(), a._sticky && (e.style.width = n.element.topArea.offsetWidth - 2 + "px", p.onScroll_window());
      }
    },
    onScroll_window: function() {
      if (a._variable.isFullScreen || n.element.toolbar.offsetWidth === 0 || c.stickyToolbar < 0)
        return;
      const e = n.element, i = e.editorArea.offsetHeight, s = (this.scrollY || E.documentElement.scrollTop) + c.stickyToolbar, r = p._getEditorOffsets(c.toolbarContainer).top - (a._isInline ? e.toolbar.offsetHeight : 0), f = a._isInline && s - r > 0 ? s - r - n.element.toolbar.offsetHeight : 0;
      s < r ? p._offStickyToolbar() : s + a._variable.minResizingSize >= i + r ? (a._sticky || p._onStickyToolbar(f), e.toolbar.style.top = f + i + r + c.stickyToolbar - s - a._variable.minResizingSize + "px") : s >= r && p._onStickyToolbar(f);
    },
    _getEditorOffsets: function(e) {
      let i = e || n.element.topArea, s = 0, r = 0, f = 0;
      for (; i; )
        s += i.offsetTop, r += i.offsetLeft, f += i.scrollTop, i = i.offsetParent;
      return {
        top: s,
        left: r,
        scroll: f
      };
    },
    _getPageBottomSpace: function() {
      return E.documentElement.scrollHeight - (p._getEditorOffsets(null).top + n.element.topArea.offsetHeight);
    },
    _onStickyToolbar: function(e) {
      const i = n.element;
      !a._isInline && !c.toolbarContainer && (i._stickyDummy.style.height = i.toolbar.offsetHeight + "px", i._stickyDummy.style.display = "block"), i.toolbar.style.top = c.stickyToolbar + e + "px", i.toolbar.style.width = a._isInline ? a._inlineToolbarAttr.width : i.toolbar.offsetWidth + "px", t.addClass(i.toolbar, "se-toolbar-sticky"), a._sticky = !0;
    },
    _offStickyToolbar: function() {
      const e = n.element;
      e._stickyDummy.style.display = "none", e.toolbar.style.top = a._isInline ? a._inlineToolbarAttr.top : "", e.toolbar.style.width = a._isInline ? a._inlineToolbarAttr.width : "", e.editorArea.style.marginTop = "", t.removeClass(e.toolbar, "se-toolbar-sticky"), a._sticky = !1;
    },
    _codeViewAutoHeight: function() {
      a._variable.isFullScreen || (n.element.code.style.height = n.element.code.scrollHeight + "px");
    },
    // FireFox - table delete, Chrome - image, video, audio
    _hardDelete: function() {
      const e = a.getRange(), i = e.startContainer, s = e.endContainer, r = t.getRangeFormatElement(i), f = t.getRangeFormatElement(s), d = t.isCell(r), o = t.isCell(f), g = e.commonAncestorContainer;
      if ((d && !r.previousElementSibling && !r.parentElement.previousElementSibling || o && !f.nextElementSibling && !f.parentElement.nextElementSibling) && r !== f)
        if (!d)
          t.removeItem(t.getParentElement(f, function(y) {
            return g === y.parentNode;
          }));
        else if (!o)
          t.removeItem(t.getParentElement(r, function(y) {
            return g === y.parentNode;
          }));
        else
          return t.removeItem(t.getParentElement(r, function(y) {
            return g === y.parentNode;
          })), a.nativeFocus(), !0;
      const u = i.nodeType === 1 ? t.getParentElement(i, ".se-component") : null, h = s.nodeType === 1 ? t.getParentElement(s, ".se-component") : null;
      return u && t.removeItem(u), h && t.removeItem(h), !1;
    },
    onPaste_wysiwyg: function(e) {
      const i = t.isIE ? w.clipboardData : e.clipboardData;
      return i ? p._dataTransferAction("paste", e, i) : !0;
    },
    _setClipboardComponent: function(e, i, s) {
      e.preventDefault(), e.stopPropagation(), s.setData("text/html", i.component.outerHTML);
    },
    onCopy_wysiwyg: function(e) {
      const i = t.isIE ? w.clipboardData : e.clipboardData;
      if (typeof O.onCopy == "function" && O.onCopy(e, i, a) === !1)
        return e.preventDefault(), e.stopPropagation(), !1;
      const s = a.currentFileComponentInfo;
      s && !t.isIE && (p._setClipboardComponent(e, s, i), t.addClass(s.component, "se-component-copy"), w.setTimeout(function() {
        t.removeClass(s.component, "se-component-copy");
      }, 150));
    },
    onSave_wysiwyg: function(e) {
      if (typeof O.onSave == "function") {
        O.onSave(e, a);
        return;
      }
    },
    onCut_wysiwyg: function(e) {
      const i = t.isIE ? w.clipboardData : e.clipboardData;
      if (typeof O.onCut == "function" && O.onCut(e, i, a) === !1)
        return e.preventDefault(), e.stopPropagation(), !1;
      const s = a.currentFileComponentInfo;
      s && !t.isIE && (p._setClipboardComponent(e, s, i), t.removeItem(s.component), a.controllersOff()), w.setTimeout(function() {
        a.history.push(!1);
      });
    },
    onDrop_wysiwyg: function(e) {
      if (a.isReadOnly || t.isIE)
        return e.preventDefault(), e.stopPropagation(), !1;
      const i = e.dataTransfer;
      return i ? (a.removeNode(), p._setDropLocationSelection(e), p._dataTransferAction("drop", e, i)) : !0;
    },
    _setDropLocationSelection: function(e) {
      if (e.rangeParent)
        a.setRange(e.rangeParent, e.rangeOffset, e.rangeParent, e.rangeOffset);
      else if (a._wd.caretRangeFromPoint) {
        const i = a._wd.caretRangeFromPoint(e.clientX, e.clientY);
        a.setRange(i.startContainer, i.startOffset, i.endContainer, i.endOffset);
      } else {
        const i = a.getRange();
        a.setRange(i.startContainer, i.startOffset, i.endContainer, i.endOffset);
      }
    },
    _dataTransferAction: function(e, i, s) {
      let r, f;
      if (t.isIE) {
        r = s.getData("Text");
        const d = a.getRange(), o = t.createElement("DIV"), g = {
          sc: d.startContainer,
          so: d.startOffset,
          ec: d.endContainer,
          eo: d.endOffset
        };
        return o.setAttribute("contenteditable", !0), o.style.cssText = "position:absolute; top:0; left:0; width:1px; height:1px; overflow:hidden;", n.element.relative.appendChild(o), o.focus(), w.setTimeout(function() {
          f = o.innerHTML, t.removeItem(o), a.setRange(g.sc, g.so, g.ec, g.eo), p._setClipboardData(e, i, r, f, s);
        }), !0;
      } else if (r = s.getData("text/plain"), f = s.getData("text/html"), p._setClipboardData(e, i, r, f, s) === !1)
        return i.preventDefault(), i.stopPropagation(), !1;
    },
    _setClipboardData: function(e, i, s, r, f) {
      const d = /class=["']*Mso(Normal|List)/i.test(r) || /content=["']*Word.Document/i.test(r) || /content=["']*OneNote.File/i.test(r) || /content=["']*Excel.Sheet/i.test(r);
      !r ? r = t._HTMLConvertor(s).replace(/\n/g, "<br>") : (r = r.replace(/^<html>\r?\n?<body>\r?\n?\x3C!--StartFragment--\>|\x3C!--EndFragment-->\r?\n?<\/body\>\r?\n?<\/html>$/g, ""), d && (r = r.replace(/\n/g, " "), s = s.replace(/\n/g, " ")), r = a.cleanHTML(r, a.pasteTagsWhitelistRegExp, a.pasteTagsBlacklistRegExp));
      const g = a._charCount(a._charTypeHTML ? r : s);
      if (e === "paste" && typeof O.onPaste == "function") {
        const h = O.onPaste(i, r, g, a);
        if (h === !1)
          return !1;
        if (typeof h == "string") {
          if (!h)
            return !1;
          r = h;
        }
      }
      if (e === "drop" && typeof O.onDrop == "function") {
        const h = O.onDrop(i, r, g, a);
        if (h === !1)
          return !1;
        if (typeof h == "string") {
          if (!h)
            return !1;
          r = h;
        }
      }
      const u = f.files;
      if (u.length > 0 && !d)
        return /^image/.test(u[0].type) && a.plugins.image && O.insertImage(u), !1;
      if (!g)
        return !1;
      if (r)
        return O.insertHTML(r, !0, !1), !1;
    },
    onMouseMove_wysiwyg: function(e) {
      if (a.isDisabled || a.isReadOnly)
        return !1;
      const i = t.getParentElement(e.target, t.isComponent), s = a._lineBreaker.style;
      if (i && !a.currentControllerName) {
        const r = n.element;
        let f = 0, d = r.wysiwyg;
        do
          f += d.scrollTop, d = d.parentElement;
        while (d && !/^(BODY|HTML)$/i.test(d.nodeName));
        const o = r.wysiwyg.scrollTop, g = p._getEditorOffsets(null), u = t.getOffset(i, r.wysiwygFrame).top + o, h = e.pageY + f + (c.iframe && !c.toolbarContainer ? r.toolbar.offsetHeight : 0), y = u + (c.iframe ? f : g.top), T = t.isListCell(i.parentNode);
        let L = "", k = "";
        if ((T ? !i.previousSibling : !t.isFormatElement(i.previousElementSibling)) && h < y + 20)
          k = u, L = "t";
        else if ((T ? !i.nextSibling : !t.isFormatElement(i.nextElementSibling)) && h > y + i.offsetHeight - 20)
          k = u + i.offsetHeight, L = "b";
        else {
          s.display = "none";
          return;
        }
        a._variable._lineBreakComp = i, a._variable._lineBreakDir = L, s.top = k - o + "px", a._lineBreakerButton.style.left = t.getOffset(i).left + i.offsetWidth / 2 - 15 + "px", s.display = "block";
      } else
        s.display !== "none" && (s.display = "none");
    },
    _onMouseDown_lineBreak: function(e) {
      e.preventDefault();
    },
    _onLineBreak: function(e) {
      e.preventDefault();
      const i = a._variable._lineBreakComp, s = this ? this : a._variable._lineBreakDir, r = t.isListCell(i.parentNode), f = t.createElement(r ? "BR" : t.isCell(i.parentNode) ? "DIV" : c.defaultTag);
      if (r || (f.innerHTML = "<br>"), a._charTypeHTML && !a.checkCharCount(f.outerHTML, "byte-html"))
        return;
      i.parentNode.insertBefore(f, s === "t" ? i : i.nextSibling), a._lineBreaker.style.display = "none", a._variable._lineBreakComp = null;
      const d = r ? f : f.firstChild;
      a.setRange(d, 1, d, 1), a.history.push(!1);
    },
    _resizeObserver: null,
    _toolbarObserver: null,
    _addEvent: function() {
      const e = c.iframe ? a._ww : n.element.wysiwyg;
      t.isResizeObserverSupported && (this._resizeObserver = new w.ResizeObserver(function(i) {
        a.__callResizeFunction(-1, i[0]);
      })), n.element.toolbar.addEventListener("mousedown", p._buttonsEventHandler, !1), n.element._menuTray.addEventListener("mousedown", p._buttonsEventHandler, !1), n.element.toolbar.addEventListener("click", p.onClick_toolbar, !1), e.addEventListener("mousedown", p.onMouseDown_wysiwyg, !1), e.addEventListener("click", p.onClick_wysiwyg, !1), e.addEventListener(t.isIE ? "textinput" : "input", p.onInput_wysiwyg, !1), e.addEventListener("keydown", p.onKeyDown_wysiwyg, !1), e.addEventListener("keyup", p.onKeyUp_wysiwyg, !1), e.addEventListener("paste", p.onPaste_wysiwyg, !1), e.addEventListener("copy", p.onCopy_wysiwyg, !1), e.addEventListener("cut", p.onCut_wysiwyg, !1), e.addEventListener("drop", p.onDrop_wysiwyg, !1), e.addEventListener("scroll", p.onScroll_wysiwyg, !1), e.addEventListener("focus", p.onFocus_wysiwyg, !1), e.addEventListener("blur", p.onBlur_wysiwyg, !1), p._lineBreakerBind = { a: p._onLineBreak.bind(""), t: p._onLineBreak.bind("t"), b: p._onLineBreak.bind("b") }, e.addEventListener("mousemove", p.onMouseMove_wysiwyg, !1), a._lineBreakerButton.addEventListener("mousedown", p._onMouseDown_lineBreak, !1), a._lineBreakerButton.addEventListener("click", p._lineBreakerBind.a, !1), n.element.lineBreaker_t.addEventListener("mousedown", p._lineBreakerBind.t, !1), n.element.lineBreaker_b.addEventListener("mousedown", p._lineBreakerBind.b, !1), e.addEventListener("touchstart", p.onMouseDown_wysiwyg, { passive: !0, useCapture: !1 }), e.addEventListener("touchend", p.onClick_wysiwyg, { passive: !0, useCapture: !1 }), c.height === "auto" && !c.codeMirrorEditor && (n.element.code.addEventListener("keydown", p._codeViewAutoHeight, !1), n.element.code.addEventListener("keyup", p._codeViewAutoHeight, !1), n.element.code.addEventListener("paste", p._codeViewAutoHeight, !1)), n.element.resizingBar && (/\d+/.test(c.height) && c.resizeEnable ? n.element.resizingBar.addEventListener("mousedown", p.onMouseDown_resizingBar, !1) : t.addClass(n.element.resizingBar, "se-resizing-none")), p._setResponsiveToolbar(), t.isResizeObserverSupported && (this._toolbarObserver = new w.ResizeObserver(a.resetResponsiveToolbar)), w.addEventListener("resize", p.onResize_window, !1), c.stickyToolbar > -1 && w.addEventListener("scroll", p.onScroll_window, !1);
    },
    _removeEvent: function() {
      const e = c.iframe ? a._ww : n.element.wysiwyg;
      n.element.toolbar.removeEventListener("mousedown", p._buttonsEventHandler), n.element._menuTray.removeEventListener("mousedown", p._buttonsEventHandler), n.element.toolbar.removeEventListener("click", p.onClick_toolbar), e.removeEventListener("mousedown", p.onMouseDown_wysiwyg), e.removeEventListener("click", p.onClick_wysiwyg), e.removeEventListener(t.isIE ? "textinput" : "input", p.onInput_wysiwyg), e.removeEventListener("keydown", p.onKeyDown_wysiwyg), e.removeEventListener("keyup", p.onKeyUp_wysiwyg), e.removeEventListener("paste", p.onPaste_wysiwyg), e.removeEventListener("copy", p.onCopy_wysiwyg), e.removeEventListener("cut", p.onCut_wysiwyg), e.removeEventListener("drop", p.onDrop_wysiwyg), e.removeEventListener("scroll", p.onScroll_wysiwyg), e.removeEventListener("mousemove", p.onMouseMove_wysiwyg), a._lineBreakerButton.removeEventListener("mousedown", p._onMouseDown_lineBreak), a._lineBreakerButton.removeEventListener("click", p._lineBreakerBind.a), n.element.lineBreaker_t.removeEventListener("mousedown", p._lineBreakerBind.t), n.element.lineBreaker_b.removeEventListener("mousedown", p._lineBreakerBind.b), p._lineBreakerBind = null, e.removeEventListener("touchstart", p.onMouseDown_wysiwyg, { passive: !0, useCapture: !1 }), e.removeEventListener("touchend", p.onClick_wysiwyg, { passive: !0, useCapture: !1 }), e.removeEventListener("focus", p.onFocus_wysiwyg), e.removeEventListener("blur", p.onBlur_wysiwyg), n.element.code.removeEventListener("keydown", p._codeViewAutoHeight), n.element.code.removeEventListener("keyup", p._codeViewAutoHeight), n.element.code.removeEventListener("paste", p._codeViewAutoHeight), n.element.resizingBar && n.element.resizingBar.removeEventListener("mousedown", p.onMouseDown_resizingBar), p._resizeObserver && (p._resizeObserver.unobserve(n.element.wysiwygFrame), p._resizeObserver = null), p._toolbarObserver && (p._toolbarObserver.unobserve(n.element._toolbarShadow), p._toolbarObserver = null), w.removeEventListener("resize", p.onResize_window), w.removeEventListener("scroll", p.onScroll_window);
    },
    _setResponsiveToolbar: function() {
      if (v.length === 0) {
        v = null;
        return;
      }
      p._responsiveCurrentSize = "default";
      const e = p._responsiveButtonSize = [], i = p._responsiveButtons = { default: v[0] };
      for (let s = 1, r = v.length, f, d; s < r; s++)
        d = v[s], f = d[0] * 1, e.push(f), i[f] = d[1];
      e.sort(function(s, r) {
        return s - r;
      }).unshift("default");
    }
  }, O = {
    /**
     * @description Core, Util object
     */
    core: a,
    util: t,
    /**
     * @description Event functions
     * @param {Object} e Event Object
     * @param {Object} core Core object
     */
    onload: null,
    onScroll: null,
    onMouseDown: null,
    onClick: null,
    onInput: null,
    onKeyDown: null,
    onKeyUp: null,
    onCopy: null,
    onCut: null,
    onFocus: null,
    /**
     * @description Event functions
     * @param {Object} e Event Object
     * @param {Object} core Core object
     * @param {String} contents Current contents
     */
    onBlur: null,
    /**
     * @description Event functions
     * @param {String} contents Current contents
     * @param {Object} core Core object
     */
    onChange: null,
    /**
     * @description Event functions
     * @param {String} contents Current contents
     * @param {Object} core Core object
     */
    onSave: null,
    /**
     * @description Event functions (drop, paste)
     * When false is returned, the default behavior is stopped.
     * If the string is returned, the cleanData value is modified to the return value.
     * @param {Object} e Event object.
     * @param {String} cleanData HTML string modified for editor format.
     * @param {Boolean} maxChartCount option (true if max character is exceeded)
     * @param {Object} core Core object
     * @returns {Boolean|String}
     */
    onDrop: null,
    onPaste: null,
    /**
     * @description Called just before the inline toolbar is positioned and displayed on the screen.
     * @param {Element} toolbar Toolbar Element
     * @param {Object} context The editor's context object (editor.getContext())
     * @param {Object} core Core object
     */
    showInline: null,
    /**
     * @description Called just after the controller is positioned and displayed on the screen.
     * controller - editing elements displayed on the screen [image resizing, table editor, link editor..]]
     * @param {String} name The name of the plugin that called the controller
     * @param {Array} controllers Array of Controller elements
     * @param {Object} core Core object
     */
    showController: null,
    /**
     * @description An event when toggling between code view and wysiwyg view.
     * @param {Boolean} isCodeView Whether the current code view mode
     * @param {Object} core Core object
     */
    toggleCodeView: null,
    /**
     * @description An event when toggling full screen.
     * @param {Boolean} isFullScreen Whether the current full screen mode
     * @param {Object} core Core object
     */
    toggleFullScreen: null,
    /**
     * @description It replaces the default callback function of the image upload
     * @param {Object} response Response object
     * @param {Object} info Input information
     * - linkValue: Link url value
     * - linkNewWindow: Open in new window Check Value
     * - inputWidth: Value of width input
     * - inputHeight: Value of height input
     * - align: Align Check Value
     * - isUpdate: Update image if true, create image if false
     * - element: If isUpdate is true, the currently selected image.
     * @param {Object} core Core object
     */
    imageUploadHandler: null,
    /**
     * @description It replaces the default callback function of the video upload
     * @param xmlHttp xmlHttpRequest object
     * @param info Input information
     * - inputWidth: Value of width input
     * - inputHeight: Value of height input
     * - align: Align Check Value
     * - isUpdate: Update video if true, create video if false
     * - element: If isUpdate is true, the currently selected video.
     * @param core Core object
     */
    videoUploadHandler: null,
    /**
     * @description It replaces the default callback function of the audio upload
     * @param xmlHttp xmlHttpRequest object
     * @param info Input information
     * - isUpdate: Update audio if true, create audio if false
     * - element: If isUpdate is true, the currently selected audio.
     * @param core Core object
     */
    audioUploadHandler: null,
    /**
     * @description Called before the image is uploaded
     * If true is returned, the internal upload process runs normally.
     * If false is returned, no image upload is performed.
     * If new fileList are returned,  replaced the previous fileList
     * If undefined is returned, it waits until "uploadHandler" is executed.
     * @param {Array} files Files array
     * @param {Object} info info: {
     * - linkValue: Link url value
     * - linkNewWindow: Open in new window Check Value
     * - inputWidth: Value of width input
     * - inputHeight: Value of height input
     * - align: Align Check Value
     * - isUpdate: Update image if true, create image if false
     * - element: If isUpdate is true, the currently selected image.
     * }
     * @param {Object} core Core object
     * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
     *                "uploadHandler" is an upload function with "core" and "info" bound.
     *                [upload files] : uploadHandler(files or [new File(...),])
     *                [error]        : uploadHandler("Error message")
     *                [Just finish]  : uploadHandler()
     *                [directly register] : uploadHandler(response) // Same format as "imageUploadUrl" response
     *                                   ex) {
     *                                      // "errorMessage": "insert error message",
     *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
     *                                   }
     * @returns {Boolean|Array|undefined}
     */
    onImageUploadBefore: null,
    /**
     * @description Called before the video is uploaded
     * If true is returned, the internal upload process runs normally.
     * If false is returned, no video(iframe, video) upload is performed.
     * If new fileList are returned,  replaced the previous fileList
     * If undefined is returned, it waits until "uploadHandler" is executed.
     * @param {Array} files Files array
     * @param {Object} info info: {
     * - inputWidth: Value of width input
     * - inputHeight: Value of height input
     * - align: Align Check Value
     * - isUpdate: Update video if true, create video if false
     * - element: If isUpdate is true, the currently selected video.
     * }
     * @param {Object} core Core object
     * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
     *                "uploadHandler" is an upload function with "core" and "info" bound.
     *                [upload files] : uploadHandler(files or [new File(...),])
     *                [error]        : uploadHandler("Error message")
     *                [Just finish]  : uploadHandler()
     *                [directly register] : uploadHandler(response) // Same format as "videoUploadUrl" response
     *                                   ex) {
     *                                      // "errorMessage": "insert error message",
     *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
     *                                   }
     * @returns {Boolean|Array|undefined}
     */
    onVideoUploadBefore: null,
    /**
     * @description Called before the audio is uploaded
     * If true is returned, the internal upload process runs normally.
     * If false is returned, no audio upload is performed.
     * If new fileList are returned,  replaced the previous fileList
     * If undefined is returned, it waits until "uploadHandler" is executed.
     * @param {Array} files Files array
     * @param {Object} info info: {
     * - isUpdate: Update audio if true, create audio if false
     * - element: If isUpdate is true, the currently selected audio.
     * }
     * @param {Object} core Core object
     * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
     *                "uploadHandler" is an upload function with "core" and "info" bound.
     *                [upload files] : uploadHandler(files or [new File(...),])
     *                [error]        : uploadHandler("Error message")
     *                [Just finish]  : uploadHandler()
     *                [directly register] : uploadHandler(response) // Same format as "audioUploadUrl" response
     *                                   ex) {
     *                                      // "errorMessage": "insert error message",
     *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
     *                                   }
     * @returns {Boolean|Array|undefined}
     */
    onAudioUploadBefore: null,
    /**
     * @description Called when the image is uploaded, updated, deleted
     * @param {Element} targetElement Target element
     * @param {Number} index Uploaded index
     * @param {String} state Upload status ('create', 'update', 'delete')
     * @param {Object} info Image info object
     * - index: data index
     * - name: file name
     * - size: file size
     * - select: select function
     * - delete: delete function
     * - element: target element
     * - src: src attribute of tag
     * @param {Number} remainingFilesCount Count of remaining files to upload (0 when added as a url)
     * @param {Object} core Core object
     */
    onImageUpload: null,
    /**
    * @description Called when the video(iframe, video) is is uploaded, updated, deleted
    * -- arguments is same "onImageUpload" --
    */
    onVideoUpload: null,
    /**
    * @description Called when the audio is is uploaded, updated, deleted
    * -- arguments is same "onImageUpload" --
    */
    onAudioUpload: null,
    /**
     * @description Called when the image is upload failed
     * @param {String} errorMessage Error message
     * @param {Object} result Response Object
     * @param {Object} core Core object
     * @returns {Boolean}
     */
    onImageUploadError: null,
    /**
     * @description Called when the video(iframe, video) upload failed
     * -- arguments is same "onImageUploadError" --
     */
    onVideoUploadError: null,
    /**
     * @description Called when the audio upload failed
     * -- arguments is same "onImageUploadError" --
     */
    onAudioUploadError: null,
    /**
     * @description Called when the editor is resized using the bottom bar
     */
    onResizeEditor: null,
    /**
     * @description Called after the "setToolbarButtons" invocation.
     * Can be used to tweak buttons properties (useful for custom buttons)
     * @param {Array} buttonList Button list 
     * @param {Object} core Core object
     */
    onSetToolbarButtons: null,
    /**
     * @description Reset the buttons on the toolbar. (Editor is not reloaded)
     * You cannot set a new plugin for the button.
     * @param {Array} buttonList Button list 
     */
    setToolbarButtons: function(e) {
      a.submenuOff(), a.containerOff(), a.moreLayerOff();
      const i = Ce._createToolBar(E, e, a.plugins, c);
      v = i.responsiveButtons, p._setResponsiveToolbar(), n.element.toolbar.replaceChild(i._buttonTray, n.element._buttonTray);
      const s = be(n.element.originElement, a._getConstructed(n.element), c);
      n.element = s.element, n.tool = s.tool, c.iframe && (n.element.wysiwyg = a._wd.body), a._recoverButtonStates(), a._cachingButtons(), a.history._resetCachingButton(), a.effectNode = null, a.hasFocus && p._applyTagEffects(), a.isReadOnly && t.setDisabledButtons(!0, a.resizingDisabledButtons), typeof O.onSetToolbarButtons == "function" && O.onSetToolbarButtons(i._buttonTray.querySelectorAll("button"), a);
    },
    /**
     * @description Add or reset option property (Editor is reloaded)
     * @param {Object} _options Options
     */
    setOptions: function(e) {
      p._removeEvent(), a._resetComponents(), t.removeClass(a._styleCommandMap.showBlocks, "active"), t.removeClass(a._styleCommandMap.codeView, "active"), a._variable.isCodeView = !1, a._iframeAuto = null, a.plugins = e.plugins || a.plugins;
      const i = [c, e].reduce(function(d, o) {
        for (let g in o)
          if (t.hasOwn(o, g))
            if (g === "plugins" && o[g] && d[g]) {
              let u = d[g], h = o[g];
              u = u.length ? u : w.Object.keys(u).map(function(y) {
                return u[y];
              }), h = h.length ? h : w.Object.keys(h).map(function(y) {
                return h[y];
              }), d[g] = h.filter(function(y) {
                return u.indexOf(y) === -1;
              }).concat(u);
            } else
              d[g] = o[g];
        return d;
      }, {}), s = n.element, r = s.wysiwyg.innerHTML, f = Ce._setOptions(i, n, c);
      f.callButtons && (l = f.callButtons, a.initPlugins = {}), f.plugins && (a.plugins = m = f.plugins), s._menuTray.children.length === 0 && (this._menuTray = {}), v = f.toolbar.responsiveButtons, a.options = c = i, a.lang = C = c.lang, c.iframe && s.wysiwygFrame.addEventListener("load", function() {
        t._setIframeDocument(this, c), a._setOptionsInit(s, r);
      }), s.editorArea.appendChild(s.wysiwygFrame), c.iframe || a._setOptionsInit(s, r);
    },
    /**
     * @description Set "options.defaultStyle" style.
     * Define the style of the edit area
     * It can also be defined with the "setOptions" method, but the "setDefaultStyle" method does not render the editor again.
     * @param {String} style Style string
     */
    setDefaultStyle: function(e) {
      const i = c._editorStyles = t._setDefaultOptionStyle(c, e), s = n.element;
      s.topArea.style.cssText = i.top, s.code.style.cssText = c._editorStyles.frame, s.code.style.display = "none", c.height === "auto" ? s.code.style.overflow = "hidden" : s.code.style.overflow = "", c.iframe ? (s.wysiwygFrame.style.cssText = i.frame, s.wysiwyg.style.cssText = i.editor) : s.wysiwygFrame.style.cssText = i.frame + i.editor;
    },
    /**
     * @description Open a notice area
     * @param {String} message Notice message
     */
    noticeOpen: function(e) {
      a.notice.open.call(a, e);
    },
    /**
     * @description Close a notice area
     */
    noticeClose: function() {
      a.notice.close.call(a);
    },
    /**
     * @description Copying the contents of the editor to the original textarea and execute onSave callback
     * * not working during enabled codeView mode
     */
    save: function() {
      const e = a.getContents(!1);
      n.element.originElement.value = e, p.onSave_wysiwyg(e, a);
    },
    /**
     * @description Gets the suneditor's context object. Contains settings, plugins, and cached element objects
     * @returns {Object}
     */
    getContext: function() {
      return n;
    },
    /**
     * @description Gets the contents of the suneditor
     * * not working during enabled codeView mode
     * @param {Boolean} onlyContents - Return only the contents of the body without headers when the "fullPage" option is true
     * @returns {String}
     */
    getContents: function(e) {
      return a.getContents(e);
    },
    /**
     * @description Gets only the text of the suneditor contents
     * * not working during enabled codeView mode
     * @returns {String}
     */
    getText: function() {
      return n.element.wysiwyg.textContent;
    },
    /**
     * @description Get the editor's number of characters or binary data size.
     * You can use the "charCounterType" option format.
     * @param {String|null} charCounterType options - charCounterType ('char', 'byte', 'byte-html')
     * If argument is no value, the currently set "charCounterType" option is used.
     * @returns {Number}
     */
    getCharCount: function(e) {
      return e = typeof e == "string" ? e : c.charCounterType, a.getCharLength(a._charTypeHTML ? n.element.wysiwyg.innerHTML : n.element.wysiwyg.textContent, e);
    },
    /**
     * @description Gets uploaded images informations
     * - index: data index
     * - name: file name
     * - size: file size
     * - select: select function
     * - delete: delete function
     * - element: target element
     * - src: src attribute of tag
     * @returns {Array}
     */
    getImagesInfo: function() {
      return n.image ? n.image._infoList : [];
    },
    /**
     * @description Gets uploaded files(plugin using fileManager) information list.
     * image: [img], video: [video, iframe], audio: [audio]
     * When the argument value is 'image', it is the same function as "getImagesInfo".
     * - index: data index
     * - name: file name
     * - size: file size
     * - select: select function
     * - delete: delete function
     * - element: target element
     * - src: src attribute of tag
     * @param {String} pluginName Plugin name (image, video, audio)
     * @returns {Array}
     */
    getFilesInfo: function(e) {
      return n[e] ? n[e]._infoList : [];
    },
    /**
     * @description Upload images using image plugin
     * @param {FileList} files FileList
     */
    insertImage: function(e) {
      !a.plugins.image || !e || (a.initPlugins.image ? a.plugins.image.submitAction.call(a, e) : a.callPlugin("image", a.plugins.image.submitAction.bind(a, e), null), a.focus());
    },
    /**
     * @description Inserts an HTML element or HTML string or plain string at the current cursor position
     * @param {Element|String} html HTML Element or HTML string or plain string
     * @param {Boolean} notCleaningData If true, inserts the HTML string without refining it with core.cleanHTML.
     * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
     * @param {Boolean} rangeSelection If true, range select the inserted node.
     */
    insertHTML: function(e, i, s, r) {
      if (n.element.wysiwygFrame.contains(a.getSelection().focusNode) || a.focus(), typeof e == "string") {
        i || (e = a.cleanHTML(e, null, null));
        try {
          if (t.isListCell(t.getFormatElement(a.getSelectionNode(), null))) {
            const k = E.createRange().createContextualFragment(e).childNodes;
            a._isFormatData(k) && (e = a._convertListCell(k));
          }
          const d = E.createRange().createContextualFragment(e).childNodes;
          if (s) {
            const L = a._charTypeHTML ? "outerHTML" : "textContent";
            let k = "";
            for (let N = 0, V = d.length; N < V; N++)
              k += d[N][L];
            if (!a.checkCharCount(k, null))
              return;
          }
          let o, g, u, h, y;
          for (; o = d[0]; ) {
            if (h && h.nodeType === 3 && g && g.nodeType === 1 && t.isBreak(o)) {
              h = o, t.removeItem(o);
              continue;
            }
            u = a.insertNode(o, g, !1), g = u.container || u, y || (y = u), h = o;
          }
          h.nodeType === 3 && g.nodeType === 1 && (g = h);
          const T = g.nodeType === 3 ? u.endOffset || g.textContent.length : g.childNodes.length;
          r ? a.setRange(y.container || y, y.startOffset || 0, g, T) : a.setRange(g, T, g, T);
        } catch (f) {
          if (a.isDisabled || a.isReadOnly)
            return;
          console.warn("[SUNEDITOR.insertHTML.fail] " + f), a.execCommand("insertHTML", !1, e);
        }
      } else if (t.isComponent(e))
        a.insertComponent(e, !1, s, !1);
      else {
        let f = null;
        (t.isFormatElement(e) || t.isMedia(e)) && (f = t.getFormatElement(a.getSelectionNode(), null)), a.insertNode(e, f, s);
      }
      a.effectNode = null, a.focus(), a.history.push(!1);
    },
    /**
     * @description Change the contents of the suneditor
     * @param {String|undefined} contents Contents to Input
     */
    setContents: function(e) {
      a.setContents(e);
    },
    /**
     * @description Add contents to the suneditor
     * @param {String} contents Contents to Input
     */
    appendContents: function(e) {
      const i = a.convertContentsForEditor(e);
      if (a._variable.isCodeView)
        a._setCodeView(a._getCodeView() + `
` + a.convertHTMLForCodeView(i, !1));
      else {
        const s = t.createElement("DIV");
        s.innerHTML = i;
        const r = n.element.wysiwyg, f = s.children;
        for (let d = 0, o = f.length; d < o; d++)
          f[d] && r.appendChild(f[d]);
      }
      a.history.push(!1);
    },
    /**
     * @description Switch to or off "ReadOnly" mode.
     * @param {Boolean} value "readOnly" boolean value.
     */
    readOnly: function(e) {
      a.isReadOnly = e, t.setDisabledButtons(!!e, a.resizingDisabledButtons), e ? (a.controllersOff(), a.submenuActiveButton && a.submenuActiveButton.disabled && a.submenuOff(), a._moreLayerActiveButton && a._moreLayerActiveButton.disabled && a.moreLayerOff(), a.containerActiveButton && a.containerActiveButton.disabled && a.containerOff(), a.modalForm && a.plugins.dialog.close.call(a), n.element.code.setAttribute("readOnly", "true"), t.addClass(n.element.wysiwygFrame, "se-read-only")) : (n.element.code.removeAttribute("readOnly"), t.removeClass(n.element.wysiwygFrame, "se-read-only")), c.codeMirrorEditor && c.codeMirrorEditor.setOption("readOnly", !!e);
    },
    /**
     * @description Disable the suneditor
     */
    disable: function() {
      this.toolbar.disable(), this.wysiwyg.disable();
    },
    /**
     * @description Provided for backward compatibility and will be removed in 3.0.0 version
     */
    disabled: function() {
      this.disable();
    },
    /**
     * @description Enable the suneditor
     */
    enable: function() {
      this.toolbar.enable(), this.wysiwyg.enable();
    },
    /**
     * @description Provided for backward compatibility and will be removed in 3.0.0 version
     */
    enabled: function() {
      this.enable();
    },
    /**
     * @description Show the suneditor
     */
    show: function() {
      const e = n.element.topArea.style;
      e.display === "none" && (e.display = c.display);
    },
    /**
     * @description Hide the suneditor
     */
    hide: function() {
      n.element.topArea.style.display = "none";
    },
    /**
     * @description Destroy the suneditor
     */
    destroy: function() {
      a.submenuOff(), a.containerOff(), a.controllersOff(), a.notice && a.notice.close.call(a), a.modalForm && a.plugins.dialog.close.call(a), a.history._destroy(), p._removeEvent(), t.removeItem(n.element.toolbar), t.removeItem(n.element.topArea);
      for (let e in a.functions)
        t.hasOwn(a, e) && delete a.functions[e];
      for (let e in a)
        t.hasOwn(a, e) && delete a[e];
      for (let e in p)
        t.hasOwn(p, e) && delete p[e];
      for (let e in n)
        t.hasOwn(n, e) && delete n[e];
      for (let e in l)
        t.hasOwn(l, e) && delete l[e];
      for (let e in this)
        t.hasOwn(this, e) && delete this[e];
    },
    /**
     * @description Toolbar methods
     */
    toolbar: {
      /**
       * @description Disable the toolbar
       */
      disable: function() {
        a.submenuOff(), a.moreLayerOff(), a.containerOff(), n.tool.cover.style.display = "block";
      },
      /**
       * @description Provided for backward compatibility and will be removed in 3.0.0 version
       */
      disabled: function() {
        this.disable();
      },
      /**
       * @description Enable the toolbar
       */
      enable: function() {
        n.tool.cover.style.display = "none";
      },
      /**
       * @description Provided for backward compatibility and will be removed in 3.0.0 version
       */
      enabled: function() {
        this.enable();
      },
      /**
       * @description Show the toolbar
       */
      show: function() {
        a._isInline ? p._showToolbarInline() : (n.element.toolbar.style.display = "", n.element._stickyDummy.style.display = ""), p.onResize_window();
      },
      /**
       * @description Hide the toolbar
       */
      hide: function() {
        a._isInline ? p._hideToolbar() : (n.element.toolbar.style.display = "none", n.element._stickyDummy.style.display = "none"), p.onResize_window();
      }
    },
    /**
     * @description Wysiwyg methods
     */
    wysiwyg: {
      /**
       * @description Disable the wysiwyg area
       */
      disable: function() {
        a.controllersOff(), a.modalForm && a.plugins.dialog.close.call(a), n.element.wysiwyg.setAttribute("contenteditable", !1), a.isDisabled = !0, c.codeMirrorEditor ? c.codeMirrorEditor.setOption("readOnly", !0) : n.element.code.setAttribute("disabled", "disabled");
      },
      /**
       * @description Enable the wysiwyg area
       */
      enable: function() {
        n.element.wysiwyg.setAttribute("contenteditable", !0), a.isDisabled = !1, c.codeMirrorEditor ? c.codeMirrorEditor.setOption("readOnly", !1) : n.element.code.removeAttribute("disabled");
      }
    }
  };
  a.functions = O, a.options = c;
  let z = n.element, K = z.originElement, G = z.topArea;
  return K.style.display = "none", G.style.display = "block", c.iframe && z.wysiwygFrame.addEventListener("load", function() {
    t._setIframeDocument(this, c), a._editorInit(!1, c.value), c.value = null;
  }), typeof K.nextElementSibling == "object" ? K.parentNode.insertBefore(G, K.nextElementSibling) : K.parentNode.appendChild(G), z.editorArea.appendChild(z.wysiwygFrame), z = K = G = null, c.iframe || (a._editorInit(!1, c.value), c.value = null), O;
}
const Se = {
  /**
   * @description Returns the create function with preset options.
   * If the options overlap, the options of the 'create' function take precedence.
   * @param {Json} options Initialization options
   * @returns {Object}
   */
  init: function(n) {
    return {
      create: (function(l, m) {
        return this.create(l, m, n);
      }).bind(this)
    };
  },
  /**
   * @description Create the suneditor
   * @param {String|Element} idOrElement textarea Id or textarea element
   * @param {JSON|Object} options user options
   * @returns {Object}
   */
  create: function(n, l, m) {
    q._propertiesInit(), typeof l != "object" && (l = {}), m && (l = [m, l].reduce(function(v, E) {
      for (let w in E)
        if (q.hasOwn(E, w))
          if (w === "plugins" && E[w] && v[w]) {
            let t = v[w], F = E[w];
            t = t.length ? t : Object.keys(t).map(function(a) {
              return t[a];
            }), F = F.length ? F : Object.keys(F).map(function(a) {
              return F[a];
            }), v[w] = F.filter(function(a) {
              return t.indexOf(a) === -1;
            }).concat(t);
          } else
            v[w] = E[w];
      return v;
    }, {}));
    const C = typeof n == "string" ? document.getElementById(n) : n;
    if (!C)
      throw Error(typeof n == "string" ? '[SUNEDITOR.create.fail] The element for that id was not found (ID:"' + n + '")' : "[SUNEDITOR.create.fail] suneditor requires textarea's element or id value");
    const c = Ce.init(C, l);
    if (c.constructed._top.id && document.getElementById(c.constructed._top.id))
      throw Error('[SUNEDITOR.create.fail] The ID of the suneditor you are trying to create already exists (ID:"' + c.constructed._top.id + '")');
    return Le(be(C, c.constructed, c.options), c.pluginCallButtons, c.plugins, c.options.lang, l, c._responsiveButtons);
  }
};
export {
  Se as default
};
